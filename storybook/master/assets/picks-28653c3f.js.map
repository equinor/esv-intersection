{"version":3,"file":"picks-28653c3f.js","sources":["../../../../src/utils/text.ts","../../../../src/layers/CalloutCanvasLayer.ts","../../../../src/datautils/picks.ts"],"sourcesContent":["import { clamp } from '@equinor/videx-math';\n\nimport { BoundingBox } from '../interfaces';\nimport { ScaleLinear } from 'd3-scale';\n\nconst DEFAULT_HORIZONTAL_PADDING = 4;\nconst DEFAULT_VERTICAL_PADDING = 2;\n\nexport function pixelsPerUnit(x: ScaleLinear<number, number>): number {\n  const [min] = x.domain();\n  return Math.abs(x(min + 1));\n}\n\nexport function calcSize(factor: number, min: number, max: number, x: ScaleLinear<number, number>): number {\n  return clamp(pixelsPerUnit(x) * factor, min, max);\n}\n\nexport function isOverlappingHorizontally(r1: BoundingBox, r2: BoundingBox): boolean {\n  const r1x2 = r1.x + r1.width;\n  const r2x2 = r2.x + r2.width;\n\n  if (r2.x > r1x2 || r2x2 < r1.x) {\n    return false;\n  }\n  return true;\n}\n\nexport function isOverlapping(\n  r1: BoundingBox,\n  r2: BoundingBox,\n  horizontalPadding: number = DEFAULT_HORIZONTAL_PADDING,\n  verticalPadding: number = DEFAULT_VERTICAL_PADDING,\n): boolean {\n  const r1x2 = r1.x + r1.width + horizontalPadding;\n  const r2x2 = r2.x + r2.width + horizontalPadding;\n  const r1y2 = r1.y + r1.height + verticalPadding;\n  const r2y2 = r2.y + r2.height + verticalPadding;\n\n  if (r2.x - horizontalPadding > r1x2 || r2.y - verticalPadding > r1y2 || r2x2 + horizontalPadding < r1.x || r2y2 + verticalPadding < r1.y) {\n    return false;\n  }\n  return true;\n}\n\nexport function getOverlap(r1: BoundingBox, r2: BoundingBox): { dx: number; dy: number } {\n  const r1x2 = r1.x + r1.width;\n  const r2x2 = r2.x + r2.width;\n  const r1y2 = r1.y + r1.height;\n  const r2y2 = r2.y + r2.height;\n\n  if (r2.x > r1x2 || r2.y > r1y2 || r2x2 < r1.x || r2y2 < r1.y) {\n    return null;\n  }\n\n  const dx = Math.max(0, Math.min(r1.x + r1.width, r2.x + r2.width) - Math.max(r1.x, r2.x));\n  const dy = Math.max(0, Math.min(r1.y + r1.height, r2.y + r2.height) - Math.max(r1.y, r2.y));\n\n  const newPoints = {\n    dx,\n    dy,\n  };\n  return newPoints;\n}\n\nexport function getOverlapOffset(\n  r1: BoundingBox,\n  r2: BoundingBox,\n  horizontalPadding = DEFAULT_HORIZONTAL_PADDING,\n  verticalPadding = DEFAULT_VERTICAL_PADDING,\n): { dx: number; dy: number } {\n  const r1x2 = r1.x + r1.width;\n  const r2x2 = r2.x + r2.width;\n  const r1y2 = r1.y + r1.height;\n  const r2y2 = r2.y + r2.height;\n\n  if (r2.x - horizontalPadding > r1x2 || r2.y - verticalPadding > r1y2 || r2x2 + horizontalPadding < r1.x || r2y2 + verticalPadding < r1.y) {\n    return null;\n  }\n\n  const dx = r1.x + r1.width - r2.x + horizontalPadding;\n  const dy = r1.y + r1.height - r2.y + verticalPadding;\n\n  const newPoints = {\n    dx,\n    dy,\n  };\n  return newPoints;\n}\n","import { ScaleLinear } from 'd3-scale';\n\nimport { CanvasLayer } from './base/CanvasLayer';\nimport { OnUpdateEvent, Annotation, OnRescaleEvent, BoundingBox } from '../interfaces';\nimport { calcSize, isOverlapping, getOverlapOffset } from '../utils';\nimport { LayerOptions } from './base/Layer';\n\nconst DEFAULT_MIN_FONT_SIZE = 7;\nconst DEFAULT_MAX_FONT_SIZE = 11;\nconst DEFAULT_FONT_SIZE_FACTOR = 7;\n\nconst DEFAULT_OFFSET_MIN = 20;\nconst DEFAULT_OFFSET_MAX = 120;\nconst DEFAULT_OFFSET_FACTOR = 19;\n\nconst Location = {\n  topleft: 'topleft',\n  topright: 'topright',\n  bottomleft: 'bottomleft',\n  bottomright: 'bottomright',\n};\n\nexport type Point = {\n  x: number;\n  y: number;\n};\n\nexport type Callout = {\n  title: string;\n  label: string;\n  color: string;\n  pos: Point;\n  group: string;\n  alignment: string;\n  boundingBox: BoundingBox;\n  dx: number;\n  dy: number;\n};\n\nexport interface CalloutOptions<T extends Annotation[]> extends LayerOptions<T> {\n  minFontSize?: number;\n  maxFontSize?: number;\n  fontSizeFactor?: number;\n  offsetMin?: number;\n  offsetMax?: number;\n  offsetFactor?: number;\n}\n\nexport class CalloutCanvasLayer<T extends Annotation[]> extends CanvasLayer<T> {\n  rescaleEvent: OnRescaleEvent;\n  xRatio: number;\n  callouts: Callout[];\n  groupFilter: string[] = null;\n  minFontSize: number;\n  maxFontSize: number;\n  fontSizeFactor: number;\n  offsetMin: number;\n  offsetMax: number;\n  offsetFactor: number;\n\n  constructor(id?: string, options?: CalloutOptions<T>) {\n    super(id, options);\n    this.minFontSize = options.minFontSize || DEFAULT_MIN_FONT_SIZE;\n    this.maxFontSize = options.maxFontSize || DEFAULT_MAX_FONT_SIZE;\n    this.fontSizeFactor = options.fontSizeFactor || DEFAULT_FONT_SIZE_FACTOR;\n    this.offsetMin = options.offsetMin || DEFAULT_OFFSET_MIN;\n    this.offsetMax = options.offsetMax || DEFAULT_OFFSET_MAX;\n    this.offsetFactor = options.offsetFactor || DEFAULT_OFFSET_FACTOR;\n  }\n\n  setGroupFilter(filter: string[]): void {\n    this.groupFilter = filter;\n    this.callouts = undefined;\n    this.render();\n  }\n\n  onUpdate(event: OnUpdateEvent<T>): void {\n    super.onUpdate(event);\n\n    this.callouts = undefined;\n\n    this.render();\n  }\n\n  onRescale(event: OnRescaleEvent): void {\n    super.onRescale(event);\n    const isPanning = this.rescaleEvent && this.rescaleEvent.xRatio === event.xRatio;\n    this.rescaleEvent = event;\n\n    this.render(isPanning);\n  }\n\n  render(isPanning = false): void {\n    requestAnimationFrame(() => {\n      this.clearCanvas();\n\n      if (!this.data || !this.rescaleEvent || !this.referenceSystem) {\n        return;\n      }\n\n      const { xScale, yScale, xBounds } = this.rescaleEvent;\n\n      const fontSize = calcSize(this.fontSizeFactor, this.minFontSize, this.maxFontSize, xScale);\n\n      if (!isPanning || !this.callouts) {\n        const { data, ctx, groupFilter } = this;\n        const { calculateDisplacementFromBottom } = this.referenceSystem.options;\n        const isLeftToRight = calculateDisplacementFromBottom ? xBounds[0] < xBounds[1] : xBounds[0] > xBounds[1];\n        const scale = 0;\n\n        ctx.font = `bold ${fontSize}px arial`;\n        const filtered = data.filter((d: Annotation) => !groupFilter || groupFilter.includes(d.group));\n        const offset = calcSize(this.offsetFactor, this.offsetMin, this.offsetMax, xScale);\n        this.callouts = this.positionCallouts(filtered, isLeftToRight, xScale, yScale, scale, fontSize, offset);\n      }\n\n      this.callouts.forEach((callout) => {\n        const { pos, title, color } = callout;\n        const x = xScale(pos.x);\n        const y = yScale(pos.y);\n\n        const calloutBB = {\n          x,\n          y,\n          width: callout.boundingBox.width,\n          height: fontSize,\n          offsetX: callout.dx,\n          offsetY: callout.dy,\n        };\n\n        this.renderCallout(title, callout.label, calloutBB, color, callout.alignment);\n      });\n    });\n  }\n\n  private renderAnnotation = (title: string, label: string, x: number, y: number, fontSize: number, color: string): void => {\n    this.renderText(title, x, y - fontSize, fontSize, color, 'arial', 'bold');\n    this.renderText(label, x, y, fontSize, color);\n  };\n\n  private renderText(\n    title: string,\n    x: number,\n    y: number,\n    fontSize: number,\n    color: string,\n    font: string = 'arial',\n    fontStyle: string = 'normal',\n  ): void {\n    const { ctx } = this;\n    ctx.font = `${fontStyle} ${fontSize}px ${font}`;\n    ctx.fillStyle = color;\n    ctx.fillText(title, x, y);\n  }\n\n  private renderPoint(x: number, y: number, radius: number = 3): void {\n    const { ctx } = this;\n    ctx.beginPath();\n    ctx.moveTo(x, y);\n    ctx.arc(x, y, radius, 0, Math.PI * 2);\n    ctx.fill();\n  }\n\n  private renderCallout(title: string, label: string, boundingBox: BoundingBox, color: string, location: string): void {\n    const pos = this.getPosition(boundingBox, location);\n    const { x, y } = pos;\n    const { height, width, x: dotX, y: dotY } = boundingBox;\n\n    const placeLeft = location === Location.topright || location === Location.bottomright;\n    this.renderAnnotation(title, label, x, y, height, color);\n    this.renderPoint(dotX, dotY);\n    this.renderLine(x, y, width, dotX, dotY, color, placeLeft);\n  }\n\n  private renderLine = (x: number, y: number, width: number, dotX: number, dotY: number, color: string, placeLeft: boolean = true): void => {\n    const { ctx } = this;\n    const textX = placeLeft ? x : x + width;\n    const inverseTextX = placeLeft ? x + width : x;\n    const textY = y + 2;\n\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 1;\n\n    ctx.beginPath();\n    ctx.moveTo(dotX, dotY);\n    ctx.lineTo(textX, textY);\n    ctx.lineTo(inverseTextX, textY);\n\n    ctx.stroke();\n  };\n\n  private getPosition(boundingBox: BoundingBox, location: string): Point {\n    const { x, y, offsetX, offsetY, width } = boundingBox;\n    switch (location) {\n      case Location.topleft:\n        return {\n          x: x - width - offsetX,\n          y: y - offsetY,\n        };\n      case Location.topright:\n        return {\n          x: x + offsetX,\n          y: y - offsetY,\n        };\n      case Location.bottomleft:\n        return {\n          x: x - width - offsetX,\n          y: y + offsetY,\n        };\n      case Location.bottomright:\n        return {\n          x: x + offsetX,\n          y: y + offsetY,\n        };\n      default:\n        return {\n          x,\n          y,\n        };\n    }\n  }\n\n  // Calculates position of a list of annotations\n  positionCallouts(\n    annotations: Annotation[],\n    isLeftToRight: boolean,\n    xScale: ScaleLinear<number, number>,\n    yScale: ScaleLinear<number, number>,\n    _scale: number,\n    fontSize: number,\n    offset: number = 20,\n  ): Callout[] {\n    if (annotations.length === 0) {\n      return [];\n    }\n    const alignment = isLeftToRight ? Location.topleft : Location.topright;\n\n    const nodes = annotations.map((a) => {\n      const pos = a.pos ? a.pos : this.referenceSystem.project(a.md);\n      return {\n        title: a.title,\n        label: a.label,\n        color: a.color,\n        pos: { x: pos[0], y: pos[1] },\n        group: a.group,\n        alignment,\n        boundingBox: this.getAnnotationBoundingBox(a.title, a.label, pos, xScale, yScale, fontSize),\n        dx: offset,\n        dy: offset,\n      };\n    });\n\n    const top = [nodes[nodes.length - 1]];\n    const bottom: Callout[] = [];\n\n    // Initial best effort\n    this.chooseTopOrBottomPosition(nodes, bottom, top);\n\n    // Adjust position for top set\n    this.adjustTopPositions(top);\n\n    // Adjust position for bottom set\n    this.adjustBottomPositions(bottom);\n\n    return nodes;\n  }\n\n  getAnnotationBoundingBox(\n    title: string,\n    label: string,\n    pos: number[],\n    xScale: ScaleLinear<number, number>,\n    yScale: ScaleLinear<number, number>,\n    height: number,\n  ): { x: number; y: number; width: number; height: number } {\n    const { ctx } = this;\n    const ax1 = xScale(pos[0]);\n    const ay1 = yScale(pos[1]);\n\n    const labelWidth = ctx.measureText(label).width;\n    const titleWidth = ctx.measureText(title).width;\n    const width = Math.max(labelWidth, titleWidth);\n\n    const bbox = {\n      x: ax1,\n      y: ay1,\n      width,\n      height: height * 2 + 4,\n    };\n    return bbox;\n  }\n\n  chooseTopOrBottomPosition(nodes: Callout[], bottom: Callout[], top: Callout[]): void {\n    for (let i = nodes.length - 2; i >= 0; --i) {\n      const node = nodes[i];\n      const prevNode = top[0];\n\n      const overlap = isOverlapping(node.boundingBox, prevNode.boundingBox);\n      if (overlap) {\n        node.alignment = node.alignment === Location.topleft ? Location.bottomright : Location.bottomleft;\n        bottom.push(node);\n        if (i > 0) {\n          top.unshift(nodes[--i]);\n        }\n      } else {\n        top.unshift(node);\n      }\n    }\n  }\n\n  adjustTopPositions(top: Callout[]): void {\n    for (let i = top.length - 2; i >= 0; --i) {\n      const currentNode = top[i];\n      for (let j = top.length - 1; j > i; --j) {\n        const prevNode = top[j];\n        const overlap = getOverlapOffset(currentNode.boundingBox, prevNode.boundingBox);\n        if (overlap) {\n          currentNode.dy += overlap.dy;\n          currentNode.boundingBox.y -= overlap.dy;\n        }\n      }\n    }\n  }\n\n  adjustBottomPositions(bottom: Callout[]): void {\n    for (let i = bottom.length - 2; i >= 0; --i) {\n      const currentNode = bottom[i];\n      for (let j = bottom.length - 1; j > i; --j) {\n        const prevNode = bottom[j];\n        const overlap = getOverlapOffset(prevNode.boundingBox, currentNode.boundingBox);\n        if (overlap) {\n          currentNode.dy += overlap.dy;\n          currentNode.boundingBox.y += overlap.dy;\n        }\n      }\n    }\n  }\n}\n","import { Annotation } from '../interfaces';\n\ntype Pick = {\n  pickIdentifier?: string;\n  confidence: string | null;\n  depthReferencePoint: string;\n  md: number;\n  mdUnit: string;\n  tvd: number;\n};\n\ntype PickWithId = {\n  identifier: string;\n} & Pick;\n\ntype Unit = {\n  identifier: string;\n  top: string;\n  base: string;\n  baseAge: number;\n  topAge: number;\n  colorR: number;\n  colorG: number;\n  colorB: number;\n  stratUnitLevel: number;\n  lithologyType: number;\n  stratUnitParent: number;\n};\n\ntype UnitDto = {\n  unitName: string;\n  topSurface: string;\n  baseSurface: string;\n  ageBase: number;\n  ageTop: number;\n  color: {\n    r: number;\n    g: number;\n    b: number;\n  };\n  level: number;\n  lithType: number;\n  parent: number;\n};\n\ntype PickAndUnit = PickWithId & UnitDto;\n\ntype PairedPickAndUnit = {\n  name: string;\n  mdEntry: number;\n  tvdEntry: number;\n  color: { r: number; g: number; b: number };\n  level: number;\n  entryPick: PickAndUnit;\n  mdExit: number;\n  tvdExit: number;\n  exitPick: PickAndUnit;\n  confidenceEntry: string;\n  confidenceExit: string;\n  from?: number;\n  to?: number;\n};\n\nconst mapPick = (p: PickWithId, groupName: string): Annotation => ({\n  title: p.pickIdentifier || p.identifier,\n  group: groupName,\n  label: `${p.md} ${p.mdUnit} ${p.depthReferencePoint}`,\n  color: groupName === 'strat-picks' ? '#227' : 'rgba(0,0,0,0.8)',\n  md: p.md,\n});\n\nfunction getReferencePicks(picks: PickWithId[]): Annotation[] {\n  if (!picks) {\n    return [];\n  }\n\n  return picks.map((p: PickWithId) => mapPick(p, 'ref-picks'));\n}\n\nfunction getEntryPicks(formationPicks: PairedPickAndUnit[]): Annotation[] {\n  if (!formationPicks) {\n    return [];\n  }\n\n  return formationPicks\n    .filter((d: PairedPickAndUnit) => d.entryPick.md === d.from)\n    .map((p: PairedPickAndUnit) => mapPick(p.entryPick, 'strat-picks'));\n}\n\nfunction getFilteredExitPicks(formationPicks: PairedPickAndUnit[]): Annotation[] {\n  if (!formationPicks) {\n    return [];\n  }\n\n  return (\n    formationPicks\n      .filter((d: PairedPickAndUnit) => formationPicks.findIndex((p: PairedPickAndUnit) => Math.abs(p.entryPick.md - d.exitPick.md) < 0.5) === -1)\n      .map((p: PairedPickAndUnit) => mapPick(p.exitPick, 'strat-picks'))\n      // Remove duplicates from unitpicks filling in gaps in formation\n      .filter((obj: Annotation, i: number, array: Annotation[]) => i === array.findIndex((v: Annotation) => v.title === obj.title && v.md === obj.md))\n  );\n}\n\nexport const getPicksData = (picksData: { unitPicks: PairedPickAndUnit[]; nonUnitPicks: PickWithId[] }): Annotation[] =>\n  [...getReferencePicks(picksData.nonUnitPicks), ...getEntryPicks(picksData.unitPicks), ...getFilteredExitPicks(picksData.unitPicks)].sort(\n    (a, b) => a.md - b.md,\n  );\n\n/**\n * @param {Unit} u\n */\nconst unitDto = (u: Unit): UnitDto => ({\n  unitName: u.identifier,\n  topSurface: u.top,\n  baseSurface: u.base,\n  ageBase: u.baseAge,\n  ageTop: u.topAge,\n  color: {\n    r: u.colorR === null ? 255 : u.colorR,\n    g: u.colorG === null ? 255 : u.colorG,\n    b: u.colorB === null ? 255 : u.colorB,\n  },\n  level: u.stratUnitLevel,\n  lithType: u.lithologyType,\n  parent: u.stratUnitParent,\n});\n\n/**\n *\n * @param {number} from\n * @param {number} to\n * @param {{ from: number; to: number; itm: PairedPickAndUnit }[]} arr\n * @param {number} arr.to\n * @param {number} arr.from\n * @returns {[number, number][]}\n */\nfunction findGaps(from: number, to: number, arr: { from: number; to: number; itm: PairedPickAndUnit }[]): [number, number][] {\n  if (arr.length === 0) {\n    return [[from, to]];\n  }\n  const gaps: [number, number][] = [];\n  let d = from;\n  let i = 0;\n  while (d < to && i < arr.length) {\n    const itm = arr[i];\n    if (itm.from > d) {\n      gaps.push([d, Math.min(itm.from, to)]);\n    }\n    d = Math.min(to, Math.max(from, itm.to));\n    i += 1;\n  }\n  if (d < to) {\n    gaps.push([d, to]);\n  }\n  return gaps;\n}\n\n/**\n * @param {Unit[]} units\n * @returns {UnitDto[]}\n */\nconst transformStratColumn = (units: Unit[]): UnitDto[] => units.map(unitDto);\n\n/**\n * Join picks data with strat column units\n * @param {Pick[]} picks picks\n * @param {Unit[]} stratColumn strat column\n */\nfunction joinPicksAndStratColumn(picks: Pick[], stratColumn: Unit[]): { joined: PickAndUnit[]; nonUnitPicks: PickWithId[] } {\n  const transformed = transformStratColumn(stratColumn);\n  const nonUnitPicks: PickWithId[] = [];\n  const joined: PickAndUnit[] = [];\n  picks.forEach((p: Pick) => {\n    const matches = transformed.filter((u: UnitDto) => p.pickIdentifier.search(new RegExp(`(${u.topSurface}|${u.baseSurface})`, 'i')) !== -1);\n    if (matches.length > 0) {\n      matches.forEach((u: UnitDto) =>\n        joined.push({\n          md: p.md,\n          tvd: p.tvd,\n          identifier: p.pickIdentifier,\n          confidence: p.confidence,\n          mdUnit: p.mdUnit,\n          depthReferencePoint: p.depthReferencePoint,\n          ...u,\n        }),\n      );\n    } else {\n      nonUnitPicks.push({ identifier: p.pickIdentifier, ...p });\n    }\n  });\n\n  return { joined, nonUnitPicks };\n}\n\n/**\n * Find matching pairs of entry/exit picks\n * @param {PickAndUnit[]} joined picks joined with strat column units\n */\nfunction pairJoinedPicks(joined: PickAndUnit[]): PairedPickAndUnit[] {\n  // pair picks by unit name\n  const pairs = [];\n  let current = null;\n\n  const sorted = joined\n    .filter((d: PickAndUnit) => d.level)\n    .sort((a: PickAndUnit, b: PickAndUnit) => a.unitName.localeCompare(b.unitName) || a.md - b.md || a.ageTop - b.ageTop);\n\n  while (sorted.length > 0) {\n    current = sorted.shift();\n    const name = current.identifier;\n    let pairWithName: string;\n\n    const isTop = name === current.topSurface;\n    const isBase = name === current.baseSurface;\n\n    if (isTop) {\n      pairWithName = current.baseSurface;\n    } else if (isBase) {\n      pairWithName = current.topSurface;\n    } else {\n      console.warn(`Unable to match ${name} with top or base surface, ignored`);\n      continue;\n    }\n\n    let top: PickAndUnit;\n    let base: PickAndUnit;\n\n    const pairWith = sorted.find((p: PickAndUnit) => p.identifier === pairWithName);\n    if (!pairWith) {\n      console.warn(`Unable to find ${pairWithName} pick for ${name}`);\n      if (isTop) {\n        top = current;\n        base = joined\n          .filter((d: PickAndUnit) => d.level)\n          .sort((a: PickAndUnit, b: PickAndUnit) => a.md - b.md)\n          .find((p: PickAndUnit) => p.md > top.md);\n        if (base) {\n          console.warn(`Using ${base.identifier} as base for ${name}`);\n        } else {\n          console.warn(`Unable to find a base pick for ${name} pick at ${top.md}, ignored`);\n          continue;\n        }\n      } else if (isBase) {\n        base = current;\n        top = joined\n          .filter((d: PickAndUnit) => d.level)\n          .sort((a: PickAndUnit, b: PickAndUnit) => b.md - a.md)\n          .find((p: PickAndUnit) => p.md < base.md);\n        if (top) {\n          console.warn(`Using ${top.identifier} as top for ${name}`);\n        } else {\n          console.warn(`Unable to find a top pick for ${name} pick at ${base.md}, ignored`);\n          continue;\n        }\n      } else {\n        console.warn(`${name} ignored`);\n        continue;\n      }\n    } else {\n      top = isTop ? current : pairWith;\n      base = isTop ? pairWith : current;\n\n      if (top.md > base.md) {\n        [top, base] = [base, top];\n      }\n\n      sorted.splice(sorted.indexOf(pairWith), 1);\n    }\n\n    pairs.push(<PairedPickAndUnit>{\n      name: top.unitName,\n      mdEntry: top.md,\n      tvdEntry: top.tvd,\n      color: top.color,\n      level: top.level,\n      entryPick: top,\n      mdExit: base.md,\n      tvdExit: base.tvd,\n      exitPick: base,\n      confidenceEntry: top.confidence,\n      confidenceExit: base.confidence,\n    });\n  }\n\n  return pairs;\n}\n\n/**\n * Transform data for formation track\n * @param {Pick[]} picks picks\n * @param {Unit[]} stratColumn strat column\n */\nexport function transformFormationData(picks: Pick[], stratColumn: Unit[]): { unitPicks: PairedPickAndUnit[]; nonUnitPicks: PickWithId[] } {\n  const { joined, nonUnitPicks } = joinPicksAndStratColumn(picks, stratColumn);\n  const pairs = pairJoinedPicks(joined);\n\n  const itemstack = pairs\n    .filter((d: PairedPickAndUnit) => d.mdEntry < d.mdExit)\n    .sort((a, b) => a.mdEntry - b.mdEntry || a.level - b.level)\n    .reverse();\n\n  // flatten groups of unit picks, so that the highest level is\n  // given presedence over lower levels for overlapping picks.\n  const unitPicks = [];\n  while (itemstack.length > 0) {\n    const first = itemstack.pop();\n    const group: PairedPickAndUnit[] = [];\n    while (itemstack.length > 0 && itemstack[itemstack.length - 1].level > first.level) {\n      group.push(itemstack.pop());\n    }\n    group.reverse();\n    group.push(first);\n    const arr: { from: number; to: number; itm: PairedPickAndUnit }[] = [];\n    group.forEach((itm: PairedPickAndUnit) => {\n      const gaps = findGaps(itm.mdEntry, itm.mdExit, arr);\n      arr.push(...gaps.map((g) => ({ from: g[0], to: g[1], itm })));\n    });\n    arr.sort((a, b) => a.from - b.from);\n    unitPicks.push(\n      ...arr.map((d) => ({\n        from: d.from,\n        to: d.to,\n        ...d.itm,\n      })),\n    );\n  }\n  return { unitPicks, nonUnitPicks };\n}\n"],"names":["DEFAULT_HORIZONTAL_PADDING","DEFAULT_VERTICAL_PADDING","pixelsPerUnit","x","min","calcSize","factor","max","clamp","isOverlapping","r1","r2","horizontalPadding","verticalPadding","r1x2","r2x2","r1y2","r2y2","getOverlapOffset","dx","dy","DEFAULT_MIN_FONT_SIZE","DEFAULT_MAX_FONT_SIZE","DEFAULT_FONT_SIZE_FACTOR","DEFAULT_OFFSET_MIN","DEFAULT_OFFSET_MAX","DEFAULT_OFFSET_FACTOR","Location","CalloutCanvasLayer","CanvasLayer","id","options","title","label","y","fontSize","color","width","dotX","dotY","placeLeft","ctx","textX","inverseTextX","textY","filter","event","isPanning","xScale","yScale","xBounds","data","groupFilter","calculateDisplacementFromBottom","isLeftToRight","scale","filtered","d","offset","callout","pos","calloutBB","font","fontStyle","radius","boundingBox","location","height","offsetX","offsetY","annotations","_scale","alignment","nodes","a","top","bottom","ax1","ay1","labelWidth","titleWidth","i","node","prevNode","currentNode","j","overlap","mapPick","p","groupName","getReferencePicks","picks","getEntryPicks","formationPicks","getFilteredExitPicks","obj","array","v","getPicksData","picksData","b","unitDto","u","findGaps","from","to","arr","gaps","itm","transformStratColumn","units","joinPicksAndStratColumn","stratColumn","transformed","nonUnitPicks","joined","matches","pairJoinedPicks","pairs","current","sorted","name","pairWithName","isTop","isBase","base","pairWith","transformFormationData","itemstack","unitPicks","first","group","g"],"mappings":"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"}