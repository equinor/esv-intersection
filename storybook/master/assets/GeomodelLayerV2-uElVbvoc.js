import{C as K,j as L,k as $,h as Q,l as tt,G as k}from"./elements-Cmzd0ne_.js";import{f as P}from"./findsample-BL-n9qHX.js";const et=18,st=8,nt=13,it="black",ot="Arial",at=70;class ct extends K{constructor(t,e){super(t,e),this.defaultMargins=et,this.defaultMinFontSize=st,this.defaultMaxFontSize=nt,this.defaultTextColor=it,this.defaultFont=ot,this.isLabelsOnLeftSide=!0,this.maxFontSizeInWorldCoordinates=at,this.isXFlipped=!1,this.areasWithAvgTopDepth=[],this.drawAreaLabel=(n,s,a,l)=>{const{data:r}=n,{ctx:o,maxFontSizeInWorldCoordinates:u,isXFlipped:i}=this,{xScale:d,yScale:h,xRatio:g,yRatio:f,zFactor:p}=this.rescaleEvent;if(o==null)return;let c=this.checkDrawLabelsOnLeftSide();const v=(this.options.margins||this.defaultMargins)*(i?-1:1)/g,D=this.options.minFontSize||this.defaultMinFontSize;let m=(this.options.maxFontSize||this.defaultMaxFontSize)/f;m>u&&(m=u,m*f<D&&(m=D/f));const I=d.invert(d.range()[0])+v,S=d.invert(d.range()[1])-v,[x,b]=this.getSurfacesAreaEdges();o.save(),o.font=`${m*f}px ${this.options.font||this.defaultFont}`;let M=o.measureText(n.label??""),F=M.width/g;if(c){const E=I+(i?-F:F);(!i&&E>b||i&&E<b)&&(c=!1)}else{const E=S+(i?F:-F);(!i&&E<x||i&&E>x)&&(c=!0)}let A;const y=.07;c?A=i?Math.min(x,I):Math.max(x,I):A=i?Math.max(b,S):Math.min(b,S);const W=h.invert(h.range()[0]),R=h.invert(h.range()[1]),w=5,X=3,Y=y*(F/X)*(c?1:-1)*(i?-1:1),G=F/w*(c?1:-1)*(i?-1:1),U=r.map(E=>[E[0],E[1]]),O=this.calcPos(U,A,X,Y,W,R);if(!O)return;const N=r.map(E=>[E[0],E[2]]);let z=this.calcPos(N,A,X,Y,W,R,(s==null?void 0:s.data.map(E=>[E[0],E[1]]))??[],a,l);z||(z=new L(O.x,R));const _=z.y-O.y;if(_<m){if(_*f<D)return;m=_,o.font=`${m*f}px ${this.options.font||this.defaultFont}`,M=o.measureText(n.label??""),F=M.width/g}const Z=c!==i?L.right:L.left,j=this.calcAreaDir(U,N,A,w,G,Z,W,R,0,Math.PI/4,4,(s==null?void 0:s.data.map(E=>[E[0],E[1]]))??[],a,l),V=Math.atan(Math.tan(j)*p),q=A,H=(O.y+z.y)/2,J=i?-V:V;o&&(o.textAlign=c?"left":"right",o.translate(d(q),h(H)),o.rotate(J),o.fillStyle=this.options.textColor||this.defaultTextColor,o.font=`${m*f}px ${this.options.font||this.defaultFont}`,o.textBaseline="middle",o.fillText(n.label??"",0,0),o.restore())},this.drawLineLabel=n=>{const{ctx:s,isXFlipped:a}=this,{xScale:l,yScale:r,xRatio:o,yRatio:u,zFactor:i}=this.rescaleEvent;if(s==null)return;const d=this.checkDrawLabelsOnLeftSide(),h=this.getMarginsInWorldCoordinates(),f=(this.options.maxFontSize||this.defaultMaxFontSize)/u;s.save(),s.font=`${f*u}px ${this.options.font||this.defaultFont}`;const c=s.measureText(n.label).width/o,C=l.invert(l.range()[0])+h,v=l.invert(l.range()[1])-h,[D,T]=this.getSurfacesAreaEdges();let m;const I=5;d?m=a?Math.max(T,v):Math.min(T,v):m=a?Math.min(D,C):Math.max(D,C);const S=c/I*(d?-1:1),{data:x}=n,b=this.calcPos(x,m,I,S),M=this.calcLineDir(x,m,I,S,i,d?L.left:L.right);if(!b||!M)return;const F=m,A=b.y-$-f/2,y=L.angleRight(M)-(d?Math.PI:0);s&&(s.textAlign=d?"right":"left",s.translate(l(F),r(A)),s.rotate(y),s.fillStyle=this.colorToCSSColor(n.color),s.textBaseline="middle",s.fillText(n.label,0,0),s.restore())},this.render=this.render.bind(this),this.getMarginsInWorldCoordinates=this.getMarginsInWorldCoordinates.bind(this),this.getSurfacesAreaEdges=this.getSurfacesAreaEdges.bind(this),this.updateXFlipped=this.updateXFlipped.bind(this),this.generateSurfacesWithAvgDepth=this.generateSurfacesWithAvgDepth.bind(this)}get options(){return this._options}setData(t){super.setData(t),this.areasWithAvgTopDepth=[]}generateSurfacesWithAvgDepth(){var e;const t=((e=this.data)==null?void 0:e.areas)??[];this.areasWithAvgTopDepth=t.reduce((n,s)=>{if(!s.label)return n;const a=s.data.reduce((r,o)=>(o[1]!=null&&(r.sum+=o[1],r.count++),r),{sum:0,count:0});if(a.count===0)return n;const l=a.sum/a.count;return n.push({...s,avgTopDepth:l}),n},[])}onMount(t){super.onMount(t)}onUpdate(t){super.onUpdate(t),this.render()}onRescale(t){this.rescaleEvent=t,this.updateXFlipped(),this.resetTransform(),this.render()}render(){this.rescaleEvent&&requestAnimationFrame(()=>{this.clearCanvas(),this.data&&(this.areasWithAvgTopDepth.length<=0&&this.generateSurfacesWithAvgDepth(),this.drawAreaLabels(),this.drawLineLabels())})}drawAreaLabels(){this.areasWithAvgTopDepth.forEach((t,e,n)=>{const s=n.reduce((a,l,r)=>(r>e&&(a==null||l.avgTopDepth<a.avgTopDepth)&&(a=l),a),null);this.drawAreaLabel(t,s,n,e)})}drawLineLabels(){var t;(t=this.data)==null||t.lines.filter(e=>e.label).forEach(e=>this.drawLineLabel(e))}colorToCSSColor(t){if(typeof t=="string")return t;let e=t.toString(16);return e="000000".substr(0,6-e.length)+e,`#${e}`}calcPos(t,e,n,s,a,l,r,o=null,u){const i=L.zero.mutable;let d=0;for(let h=0;h<n;h++){const g=e+h*s,f=P(t,g,a,l);if(f){const p=this.getAlternativeYValueIfAvailable(g,a,l,r,o,u),c=p?Math.min(f,p):f;i.add(g,c),d++}}return d===0?null:L.divide(i,d)}getAlternativeYValueIfAvailable(t,e,n,s,a=null,l){if(!s)return null;let r=P(s,t,e,n);if(r==null&&a&&l!=null){let o=l+1;for(;r==null&&o<a.length;){const u=a[o++];r=P((u==null?void 0:u.data.map(i=>[i[0],i[1]]))??[],t,e,n)}}return r}calcLineDir(t,e,n,s,a,l=L.left,r,o){const u=l.mutable,i=P(t,e,r,o);if(i===null)return u;const d=new L(e,i*a),h=L.zero.mutable;for(let g=1;g<=n;g++){const f=e+g*s,p=P(t,e,r,o);p!==null&&(h.set(f,p*a),h.sub(d),u.add(h))}return u}calcAreaDir(t,e,n,s,a,l=L.left,r,o,u=0,i=Math.PI/4,d=4,h,g=null,f){const p=[],c=L.zero.mutable;let C;for(let S=0;S<=s;S++){const x=n+S*a,b=P(t,x,r,o),M=P(e,x,r,o)||o,F=this.getAlternativeYValueIfAvailable(x,r,o,h,g,f),A=F?Math.min(M,F):M;if(S===0){if(b===null)return L.angleRight(l);const y=(b+A)/2;C=new L(n,y)}else b!==null?(c.set(x,(b+A)/2),c.sub(C),p.push(L.angleRight(c))):p.push(L.angleRight(l))}const v=p[0],D=p.map(S=>S-v);let T=0;return D.reduce((S,x)=>{const b=(Math.abs(x)-u)/i,M=Math.pow(1-Q(b,0,1),d);return T+=M,S+x*M},0)/T+v}updateXFlipped(){const{xBounds:t}=this.rescaleEvent;this.isXFlipped=t[0]>t[1]}getMarginsInWorldCoordinates(){const{xRatio:t}=this.rescaleEvent;return(this.options.margins||this.defaultMargins)*(this.isXFlipped?-1:1)/t}getSurfacesAreaEdges(){var o,u;const t=((o=this.data)==null?void 0:o.areas.reduce((i,d)=>{var f,p;const{data:h}=d,g=h.find(c=>c[1]!=null);g&&i.push(g[0]);for(let c=h.length-1;c>=0;c--)if(((f=h[c])==null?void 0:f[1])!=null){i.push((p=h[c])==null?void 0:p[0]);break}return i},[]))??[];t.push(...((u=this.data)==null?void 0:u.lines.reduce((i,d)=>{var f,p;const{data:h}=d,g=h.find(c=>c[1]!=null);g&&i.push(g[0]);for(let c=h.length-1;c>=0;c--)if(((f=h[c])==null?void 0:f[1])!=null){i.push((p=h[c])==null?void 0:p[0]);break}return i},[]))??[]);const e=Math.min(...t),n=Math.max(...t),s=this.getMarginsInWorldCoordinates(),{isXFlipped:a}=this,l=a?n+s:e+s,r=a?e-s:n-s;return[l,r]}checkDrawLabelsOnLeftSide(){var A,y,W,R,w;const{referenceSystem:t,isXFlipped:e}=this;if(!t)return!0;const{xScale:n,yScale:s,xRatio:a}=this.rescaleEvent,l=200,[r,o]=n.domain(),[u,i]=s.domain();let d=t.interpolators.curtain.getIntersects(u,1,0);d.length===0&&(d=[t.interpolators.curtain.getPointAt(0)]);let h=t.interpolators.curtain.getIntersects(i,1,0);h.length===0&&(h=[t.interpolators.curtain.getPointAt(1)]);const g=Math.max((A=d[0])==null?void 0:A[0],(y=h[0])==null?void 0:y[0]),f=Math.min((W=d[0])==null?void 0:W[0],(R=h[0])==null?void 0:R[0]),p={left:e?g:f,right:e?f:g},c=this.getMarginsInWorldCoordinates(),C=r+c,v=o-c,[D,T]=this.getSurfacesAreaEdges(),m=e?Math.min(C,D):Math.max(C,D),I=e?Math.max(v,T):Math.min(v,T),S=Math.max(e?m-p.left:p.left-m,0),x=Math.max(e?p.right-I:I-p.right,0),b=S*a,M=x*a;return S>x||b>l||b<l&&M<l&&e||((w=h[0])==null?void 0:w[1])<u}}const rt=1e4;class dt extends tt{constructor(){super(...arguments),this.isPreRendered=!1,this.createPolygons=t=>{var s,a,l,r,o,u;const e=[];let n;for(let i=0;i<t.length;i++){const d=!!((s=t[i])!=null&&s[1]);d&&(n==null&&(n=[]),n.push((a=t[i])==null?void 0:a[0],(l=t[i])==null?void 0:l[1]));const h=i===t.length-1;if((!d||h)&&n){for(let g=d?i:i-1;g>=0&&((r=t[g])!=null&&r[1]);g--)n.push((o=t[g])==null?void 0:o[0],((u=t[g])==null?void 0:u[2])||rt);e.push(n),n=void 0}}return e},this.generateAreaPolygon=t=>{const e=new k;e.lineStyle(1,t.color,1),e.beginFill(t.color),this.createPolygons(t.data).forEach(s=>e.drawPolygon(s)),e.endFill(),this.addChild(e)},this.generateSurfaceLine=t=>{const e=new k,{data:n}=t;e.lineStyle($,t.color,1,.5,!0);let a=!1;for(let l=0;l<n.length;l++){const r=n[l];r&&r[1]&&r[0]?a?e.lineTo(r[0],r[1]):(e.moveTo(r[0],r[1]),a=!0):a=!1}this.addChild(e)}}onRescale(t){super.onRescale(t),this.isPreRendered||(this.clearLayer(),this.preRender()),this.render()}onUpdate(t){super.onUpdate(t),this.isPreRendered=!1,this.clearLayer(),this.preRender(),this.render()}preRender(){const{data:t}=this;t&&(t.areas.forEach(e=>this.generateAreaPolygon(e)),t.lines.forEach(e=>this.generateSurfaceLine(e)),this.isPreRendered=!0)}}export{dt as G,ct as a};
