{"version":3,"file":"geomodel-layer.stories.27cd06d8.js","sources":["../../../../src/layers/GeomodelCanvasLayer.ts","../../../../.storybook/src/features/geomodel-layer.stories.ts"],"sourcesContent":["import { SurfaceArea, SurfaceData, SurfaceLine } from '../datautils';\nimport { OnUpdateEvent, OnRescaleEvent } from '../interfaces';\nimport { colorToCSSColor } from '../utils/color';\nimport { LayerOptions } from './base';\nimport { CanvasLayer } from './base/CanvasLayer';\n\nconst DEFAULT_MAX_DEPTH = 10000;\n\ntype SurfacePaths = {\n  color: string;\n  path: Path2D;\n};\n\nexport class GeomodelCanvasLayer<T extends SurfaceData> extends CanvasLayer<T> {\n  rescaleEvent: OnRescaleEvent;\n\n  surfaceAreasPaths: SurfacePaths[] = [];\n\n  surfaceLinesPaths: SurfacePaths[] = [];\n\n  maxDepth: number = DEFAULT_MAX_DEPTH;\n\n  constructor(id?: string, options?: LayerOptions<T>) {\n    super(id, options);\n    this.render = this.render.bind(this);\n    this.generateSurfaceAreasPaths = this.generateSurfaceAreasPaths.bind(this);\n    this.generateSurfaceLinesPaths = this.generateSurfaceLinesPaths.bind(this);\n    this.drawPolygonPath = this.drawPolygonPath.bind(this);\n    this.drawLinePath = this.drawLinePath.bind(this);\n    this.updatePaths = this.updatePaths.bind(this);\n  }\n\n  onUpdate(event: OnUpdateEvent<T>): void {\n    super.onUpdate(event);\n    this.updatePaths();\n    this.render();\n  }\n\n  onRescale(event: OnRescaleEvent): void {\n    this.rescaleEvent = event;\n    this.setTransform(this.rescaleEvent);\n    this.render();\n  }\n\n  updatePaths(): void {\n    if (!this.data) {\n      this.surfaceAreasPaths = [];\n      this.surfaceLinesPaths = [];\n    } else {\n      this.generateSurfaceAreasPaths();\n      this.generateSurfaceLinesPaths();\n    }\n  }\n\n  render(): void {\n    if (!this.ctx || !this.rescaleEvent) {\n      return;\n    }\n\n    requestAnimationFrame(() => {\n      this.clearCanvas();\n      this.surfaceAreasPaths.forEach((p: SurfacePaths) => this.drawPolygonPath(p.color, p.path));\n      this.surfaceLinesPaths.forEach((l: SurfacePaths) => this.drawLinePath(l.color, l.path));\n    });\n  }\n\n  colorToCSSColor(color: number | string): string {\n    return colorToCSSColor(color);\n  }\n\n  generateSurfaceAreasPaths(): void {\n    this.surfaceAreasPaths = this.data.areas.reduce((acc: SurfacePaths[], s: SurfaceArea) => {\n      const polygons = this.createPolygons(s.data);\n      const mapped: SurfacePaths[] = polygons.map((polygon: number[]) => ({\n        color: this.colorToCSSColor(s.color),\n        path: this.generatePolygonPath(polygon),\n      }));\n      acc.push(...mapped);\n      return acc;\n    }, []);\n  }\n\n  generateSurfaceLinesPaths(): void {\n    this.surfaceLinesPaths = this.data.lines.reduce((acc: SurfacePaths[], l: SurfaceLine) => {\n      const lines = this.generateLinePaths(l);\n      const mapped: SurfacePaths[] = lines.map((path: Path2D) => ({ color: this.colorToCSSColor(l.color), path }));\n      acc.push(...mapped);\n      return acc;\n    }, []);\n  }\n\n  drawPolygonPath = (color: string, path: Path2D): void => {\n    const { ctx } = this;\n    ctx.fillStyle = color;\n    ctx.fill(path);\n  };\n\n  drawLinePath = (color: string, path: Path2D): void => {\n    const { ctx } = this;\n    ctx.strokeStyle = color;\n    ctx.stroke(path);\n  };\n\n  createPolygons = (data: number[][]): number[][] => {\n    const polygons: number[][] = [];\n    let polygon: number[] = null;\n\n    // Start generating polygons\n    for (let i = 0; i < data.length; i++) {\n      // Generate top of polygon as long as we have valid values\n      const topIsValid = !!data[i][1];\n      if (topIsValid) {\n        if (polygon === null) {\n          polygon = [];\n        }\n        polygon.push(data[i][0], data[i][1]);\n      }\n\n      const endIsReached = i === data.length - 1;\n      if (!topIsValid || endIsReached) {\n        if (polygon) {\n          // Generate bottom of polygon\n          for (let j: number = !topIsValid ? i - 1 : i; j >= 0; j--) {\n            if (!data[j][1]) {\n              break;\n            }\n            polygon.push(data[j][0], data[j][2] || this.maxDepth);\n          }\n          polygons.push(polygon);\n          polygon = null;\n        }\n      }\n    }\n\n    return polygons;\n  };\n\n  generatePolygonPath = (polygon: number[]): Path2D => {\n    const path = new Path2D();\n\n    path.moveTo(polygon[0], polygon[1]);\n    for (let i = 2; i < polygon.length; i += 2) {\n      path.lineTo(polygon[i], polygon[i + 1]);\n    }\n    path.closePath();\n\n    return path;\n  };\n\n  generateLinePaths = (s: SurfaceLine): Path2D[] => {\n    const paths: Path2D[] = [];\n    const { data: d } = s;\n\n    let penDown = false;\n    let path = null;\n    for (let i = 0; i < d.length; i++) {\n      if (d[i][1]) {\n        if (penDown) {\n          path.lineTo(d[i][0], d[i][1]);\n        } else {\n          path = new Path2D();\n          path.moveTo(d[i][0], d[i][1]);\n          penDown = true;\n        }\n      } else if (penDown) {\n        paths.push(path);\n        penDown = false;\n      }\n    }\n    if (penDown) {\n      paths.push(path);\n    }\n\n    return paths;\n  };\n}\n","import { GeomodelCanvasLayer, GeomodelLayerV2, GeomodelLabelsLayer, ZoomPanHandler, OnRescaleEvent, IntersectionReferenceSystem, Controller, GeomodelLayerLabelsOptions, PixiRenderApplication, LayerOptions } from '../../../src';\nimport { generateSurfaceData, SurfaceData } from '../../../src/datautils';\nimport { getSurfaces, getStratColumns, getPositionLog, getWellborePath } from '../data';\nimport { createRootContainer, createLayerContainer, createFPSLabel, createHelpText } from '../utils';\nconst width = 700;\nconst height = 600;\nexport const GeoModelUsingLowLevelInterface = () => {\n  const root = createRootContainer(width);\n  const container = createLayerContainer(width, height);\n  const fpsLabel = createFPSLabel();\n  const options: LayerOptions<SurfaceData> = {\n    order: 1\n  };\n  const pixiContext = new PixiRenderApplication({\n    width,\n    height\n  });\n  const geoModelLayer = new GeomodelLayerV2(pixiContext, 'webgl', options);\n  geoModelLayer.onMount({\n    elm: container,\n    height,\n    width\n  });\n  Promise.all([getWellborePath(), getSurfaces(), getStratColumns(), getPositionLog()]).then(values => {\n    const [path, surfaces, stratColumns] = values;\n    const referenceSystem = new IntersectionReferenceSystem(path);\n    const displacement = referenceSystem.displacement || 1;\n    const extend = 1000 / displacement;\n    const steps = surfaces[0]?.data?.values?.length || 1;\n    const traj = referenceSystem.getTrajectory(steps, 0, 1 + extend);\n    const trajectory: number[][] = IntersectionReferenceSystem.toDisplacement(traj.points, traj.offset);\n    const geolayerdata: SurfaceData = generateSurfaceData(trajectory, stratColumns, surfaces);\n    geoModelLayer.onUpdate({\n      data: geolayerdata\n    });\n  });\n  const zoomHandler = new ZoomPanHandler(container, (event: OnRescaleEvent) => {\n    geoModelLayer.onRescale(event);\n  });\n  zoomHandler.setBounds([0, 1000], [0, 1000]);\n  zoomHandler.adjustToSize(width, height);\n  zoomHandler.zFactor = 1;\n  zoomHandler.setTranslateBounds([-5000, 6000], [-5000, 6000]);\n  zoomHandler.enableTranslateExtent = false;\n  zoomHandler.setViewport(1000, 1000, 5000);\n  root.appendChild(createHelpText('Low level interface for creating and displaying geo model (aka surfaces). This layer is made using webGL.'));\n  root.appendChild(container);\n  root.appendChild(fpsLabel);\n  return root;\n};\nexport const GeoModelWithLabelsUsingLowLevelInterface = () => {\n  const root = createRootContainer(width);\n  const container = createLayerContainer(width, height);\n  const fpsLabel = createFPSLabel();\n  const options: LayerOptions<SurfaceData> = {\n    order: 1\n  };\n  const pixiContext = new PixiRenderApplication({\n    width,\n    height\n  });\n  const geoModelLayer = new GeomodelLayerV2(pixiContext, 'geomodels', options);\n  geoModelLayer.onMount({\n    elm: container,\n    height,\n    width\n  });\n  const options2: GeomodelLayerLabelsOptions<SurfaceData> = {\n    order: 1\n  };\n  const geoModelLabelsLayer = new GeomodelLabelsLayer('labels', options2);\n  geoModelLabelsLayer.onMount({\n    elm: container\n  });\n  const zoomHandler = new ZoomPanHandler(root, (event: OnRescaleEvent) => {\n    geoModelLayer.onRescale(event);\n    geoModelLabelsLayer.onRescale({\n      ...event\n    });\n  });\n  Promise.all([getWellborePath(), getSurfaces(), getStratColumns()]).then(values => {\n    const [path, surfaces, stratColumns] = values;\n    const referenceSystem = new IntersectionReferenceSystem(path);\n    const displacement = referenceSystem.displacement || 1;\n    const extend = 1000 / displacement;\n    const steps = surfaces[0]?.data?.values?.length || 1;\n    const traj = referenceSystem.getTrajectory(steps, 0, 1 + extend);\n    const trajectory: number[][] = IntersectionReferenceSystem.toDisplacement(traj.points, traj.offset);\n    const geolayerdata: SurfaceData = generateSurfaceData(trajectory, stratColumns, surfaces);\n    geoModelLayer.referenceSystem = referenceSystem;\n    geoModelLabelsLayer.referenceSystem = referenceSystem;\n    geoModelLayer.setData(geolayerdata);\n    geoModelLabelsLayer.setData(geolayerdata);\n  });\n  zoomHandler.setBounds([0, 1000], [0, 1000]);\n  zoomHandler.adjustToSize(width, height);\n  zoomHandler.zFactor = 1;\n  zoomHandler.setTranslateBounds([-5000, 6000], [-5000, 6000]);\n  zoomHandler.enableTranslateExtent = false;\n  zoomHandler.setViewport(1000, 1000, 5000);\n  root.appendChild(createHelpText('Low level interface for creating and displaying geo model (aka surfaces) with labels. The geo model layer is made using webGL and the labels using canvas.'));\n  root.appendChild(container);\n  root.appendChild(fpsLabel);\n  return root;\n};\nexport const GeoModelUsingHighLevelInterface = () => {\n  const root = createRootContainer(width);\n  const container = createLayerContainer(width, height);\n  const fpsLabel = createFPSLabel();\n  const options: LayerOptions<SurfaceData> = {\n    order: 1\n  };\n  const pixiContext = new PixiRenderApplication({\n    width,\n    height\n  });\n  const geoModelLayer = new GeomodelLayerV2(pixiContext, 'webgl', options);\n  Promise.all([getWellborePath(), getSurfaces(), getStratColumns(), getPositionLog()]).then(values => {\n    const [path, surfaces, stratColumns] = values;\n    const referenceSystem = new IntersectionReferenceSystem(path);\n    const displacement = referenceSystem.displacement || 1;\n    const extend = 1000 / displacement;\n    const steps = surfaces[0]?.data?.values?.length || 1;\n    const traj = referenceSystem.getTrajectory(steps, 0, 1 + extend);\n    const trajectory: number[][] = IntersectionReferenceSystem.toDisplacement(traj.points, traj.offset);\n    const geolayerdata: SurfaceData = generateSurfaceData(trajectory, stratColumns, surfaces);\n    geoModelLayer.setData(geolayerdata);\n  });\n  const controller = new Controller({\n    container,\n    layers: [geoModelLayer]\n  });\n  controller.setBounds([0, 1000], [0, 1000]);\n  controller.adjustToSize(width, height);\n  controller.zoomPanHandler.zFactor = 1;\n  controller.zoomPanHandler.setTranslateBounds([-5000, 6000], [-5000, 6000]);\n  controller.zoomPanHandler.enableTranslateExtent = false;\n  controller.setViewport(1000, 1000, 5000);\n  root.appendChild(createHelpText('High level interface for creating and displaying geo model (aka surfaces). This layer is made using webGL.'));\n  root.appendChild(container);\n  root.appendChild(fpsLabel);\n  return root;\n};\nexport const GeoModelWithLabelsUsingHighLevelInterface = () => {\n  const root = createRootContainer(width);\n  const container = createLayerContainer(width, height);\n  const fpsLabel = createFPSLabel();\n  const options: LayerOptions<SurfaceData> = {\n    order: 1\n  };\n  const pixiContext = new PixiRenderApplication({\n    width,\n    height\n  });\n  const geoModelLayer = new GeomodelLayerV2(pixiContext, 'geomodels', options);\n  geoModelLayer.onMount({\n    elm: container,\n    height,\n    width\n  });\n  const options2: GeomodelLayerLabelsOptions<SurfaceData> = {\n    order: 1\n  };\n  const geoModelLabelsLayer = new GeomodelLabelsLayer('labels', options2);\n  geoModelLabelsLayer.onMount({\n    elm: container\n  });\n  Promise.all([getWellborePath(), getSurfaces(), getStratColumns()]).then(values => {\n    const [path, surfaces, stratColumns] = values;\n    const referenceSystem = new IntersectionReferenceSystem(path);\n    const displacement = referenceSystem.displacement || 1;\n    const extend = 1000 / displacement;\n    const steps = surfaces[0]?.data?.values?.length || 1;\n    const traj = referenceSystem.getTrajectory(steps, 0, 1 + extend);\n    const trajectory: number[][] = IntersectionReferenceSystem.toDisplacement(traj.points, traj.offset);\n    const geolayerdata: SurfaceData = generateSurfaceData(trajectory, stratColumns, surfaces);\n    const controller = new Controller({\n      container,\n      layers: [geoModelLayer, geoModelLabelsLayer]\n    });\n    controller.setReferenceSystem(referenceSystem);\n    geoModelLayer.setData(geolayerdata);\n    geoModelLabelsLayer.setData(geolayerdata);\n    controller.setBounds([0, 1000], [0, 1000]);\n    controller.adjustToSize(width, height);\n    controller.zoomPanHandler.zFactor = 1;\n    controller.zoomPanHandler.setTranslateBounds([-5000, 6000], [-5000, 6000]);\n    controller.zoomPanHandler.enableTranslateExtent = false;\n    controller.setViewport(1000, 1000, 5000);\n  });\n  root.appendChild(createHelpText('High level interface for creating and displaying geo model (aka surfaces) with labels. The geo model layer is made using webGL and the labels using canvas.'));\n  root.appendChild(container);\n  root.appendChild(fpsLabel);\n  return root;\n};\nexport const GeoModelCanvasUsingHighLevelInterface = () => {\n  const root = createRootContainer(width);\n  const container = createLayerContainer(width, height);\n  const fpsLabel = createFPSLabel();\n  const options: LayerOptions<SurfaceData> = {\n    order: 1\n  };\n  const geoModelLayer = new GeomodelCanvasLayer('canvas', options);\n  Promise.all([getWellborePath(), getSurfaces(), getStratColumns(), getPositionLog()]).then(values => {\n    const [path, surfaces, stratColumns] = values;\n    const referenceSystem = new IntersectionReferenceSystem(path);\n    const displacement = referenceSystem.displacement || 1;\n    const extend = 1000 / displacement;\n    const steps = surfaces[0]?.data?.values?.length || 1;\n    const traj = referenceSystem.getTrajectory(steps, 0, 1 + extend);\n    const trajectory: number[][] = IntersectionReferenceSystem.toDisplacement(traj.points, traj.offset);\n    const geolayerdata: SurfaceData = generateSurfaceData(trajectory, stratColumns, surfaces);\n    geoModelLayer.setData(geolayerdata);\n  });\n  const controller = new Controller({\n    container,\n    layers: [geoModelLayer]\n  });\n  controller.setBounds([0, 1000], [0, 1000]);\n  controller.adjustToSize(width, height);\n  controller.zoomPanHandler.zFactor = 1;\n  controller.zoomPanHandler.setTranslateBounds([-5000, 6000], [-5000, 6000]);\n  controller.zoomPanHandler.enableTranslateExtent = false;\n  controller.setViewport(1000, 1000, 5000);\n  root.appendChild(createHelpText('High level interface for creating and displaying geo model (aka surfaces). This layer is made using plain HTML canvas. GeomodelLayer is preferred for rendering geo models if your browser supports WebGL.'));\n  root.appendChild(container);\n  root.appendChild(fpsLabel);\n  return root;\n};\nexport default {\n  title: 'ESV Intersection/Features/Geo Model',\n  component: GeoModelUsingLowLevelInterface\n};\nGeoModelUsingLowLevelInterface.parameters = {\n  ...GeoModelUsingLowLevelInterface.parameters,\n  storySource: {\n    source: \"() => {\\n  const root = createRootContainer(width);\\n  const container = createLayerContainer(width, height);\\n  const fpsLabel = createFPSLabel();\\n  const options: LayerOptions<SurfaceData> = {\\n    order: 1\\n  };\\n  const pixiContext = new PixiRenderApplication({\\n    width,\\n    height\\n  });\\n  const geoModelLayer = new GeomodelLayerV2(pixiContext, 'webgl', options);\\n  geoModelLayer.onMount({\\n    elm: container,\\n    height,\\n    width\\n  });\\n  Promise.all([getWellborePath(), getSurfaces(), getStratColumns(), getPositionLog()]).then(values => {\\n    const [path, surfaces, stratColumns] = values;\\n    const referenceSystem = new IntersectionReferenceSystem(path);\\n    const displacement = referenceSystem.displacement || 1;\\n    const extend = 1000 / displacement;\\n    const steps = surfaces[0]?.data?.values?.length || 1;\\n    const traj = referenceSystem.getTrajectory(steps, 0, 1 + extend);\\n    const trajectory: number[][] = IntersectionReferenceSystem.toDisplacement(traj.points, traj.offset);\\n    const geolayerdata: SurfaceData = generateSurfaceData(trajectory, stratColumns, surfaces);\\n    geoModelLayer.onUpdate({\\n      data: geolayerdata\\n    });\\n  });\\n  const zoomHandler = new ZoomPanHandler(container, (event: OnRescaleEvent) => {\\n    geoModelLayer.onRescale(event);\\n  });\\n  zoomHandler.setBounds([0, 1000], [0, 1000]);\\n  zoomHandler.adjustToSize(width, height);\\n  zoomHandler.zFactor = 1;\\n  zoomHandler.setTranslateBounds([-5000, 6000], [-5000, 6000]);\\n  zoomHandler.enableTranslateExtent = false;\\n  zoomHandler.setViewport(1000, 1000, 5000);\\n  root.appendChild(createHelpText('Low level interface for creating and displaying geo model (aka surfaces). This layer is made using webGL.'));\\n  root.appendChild(container);\\n  root.appendChild(fpsLabel);\\n  return root;\\n}\",\n    ...GeoModelUsingLowLevelInterface.parameters?.storySource\n  }\n};\nGeoModelWithLabelsUsingLowLevelInterface.parameters = {\n  ...GeoModelWithLabelsUsingLowLevelInterface.parameters,\n  storySource: {\n    source: \"() => {\\n  const root = createRootContainer(width);\\n  const container = createLayerContainer(width, height);\\n  const fpsLabel = createFPSLabel();\\n  const options: LayerOptions<SurfaceData> = {\\n    order: 1\\n  };\\n  const pixiContext = new PixiRenderApplication({\\n    width,\\n    height\\n  });\\n  const geoModelLayer = new GeomodelLayerV2(pixiContext, 'geomodels', options);\\n  geoModelLayer.onMount({\\n    elm: container,\\n    height,\\n    width\\n  });\\n  const options2: GeomodelLayerLabelsOptions<SurfaceData> = {\\n    order: 1\\n  };\\n  const geoModelLabelsLayer = new GeomodelLabelsLayer('labels', options2);\\n  geoModelLabelsLayer.onMount({\\n    elm: container\\n  });\\n  const zoomHandler = new ZoomPanHandler(root, (event: OnRescaleEvent) => {\\n    geoModelLayer.onRescale(event);\\n    geoModelLabelsLayer.onRescale({\\n      ...event\\n    });\\n  });\\n  Promise.all([getWellborePath(), getSurfaces(), getStratColumns()]).then(values => {\\n    const [path, surfaces, stratColumns] = values;\\n    const referenceSystem = new IntersectionReferenceSystem(path);\\n    const displacement = referenceSystem.displacement || 1;\\n    const extend = 1000 / displacement;\\n    const steps = surfaces[0]?.data?.values?.length || 1;\\n    const traj = referenceSystem.getTrajectory(steps, 0, 1 + extend);\\n    const trajectory: number[][] = IntersectionReferenceSystem.toDisplacement(traj.points, traj.offset);\\n    const geolayerdata: SurfaceData = generateSurfaceData(trajectory, stratColumns, surfaces);\\n    geoModelLayer.referenceSystem = referenceSystem;\\n    geoModelLabelsLayer.referenceSystem = referenceSystem;\\n    geoModelLayer.setData(geolayerdata);\\n    geoModelLabelsLayer.setData(geolayerdata);\\n  });\\n  zoomHandler.setBounds([0, 1000], [0, 1000]);\\n  zoomHandler.adjustToSize(width, height);\\n  zoomHandler.zFactor = 1;\\n  zoomHandler.setTranslateBounds([-5000, 6000], [-5000, 6000]);\\n  zoomHandler.enableTranslateExtent = false;\\n  zoomHandler.setViewport(1000, 1000, 5000);\\n  root.appendChild(createHelpText('Low level interface for creating and displaying geo model (aka surfaces) with labels. The geo model layer is made using webGL and the labels using canvas.'));\\n  root.appendChild(container);\\n  root.appendChild(fpsLabel);\\n  return root;\\n}\",\n    ...GeoModelWithLabelsUsingLowLevelInterface.parameters?.storySource\n  }\n};\nGeoModelUsingHighLevelInterface.parameters = {\n  ...GeoModelUsingHighLevelInterface.parameters,\n  storySource: {\n    source: \"() => {\\n  const root = createRootContainer(width);\\n  const container = createLayerContainer(width, height);\\n  const fpsLabel = createFPSLabel();\\n  const options: LayerOptions<SurfaceData> = {\\n    order: 1\\n  };\\n  const pixiContext = new PixiRenderApplication({\\n    width,\\n    height\\n  });\\n  const geoModelLayer = new GeomodelLayerV2(pixiContext, 'webgl', options);\\n  Promise.all([getWellborePath(), getSurfaces(), getStratColumns(), getPositionLog()]).then(values => {\\n    const [path, surfaces, stratColumns] = values;\\n    const referenceSystem = new IntersectionReferenceSystem(path);\\n    const displacement = referenceSystem.displacement || 1;\\n    const extend = 1000 / displacement;\\n    const steps = surfaces[0]?.data?.values?.length || 1;\\n    const traj = referenceSystem.getTrajectory(steps, 0, 1 + extend);\\n    const trajectory: number[][] = IntersectionReferenceSystem.toDisplacement(traj.points, traj.offset);\\n    const geolayerdata: SurfaceData = generateSurfaceData(trajectory, stratColumns, surfaces);\\n    geoModelLayer.setData(geolayerdata);\\n  });\\n  const controller = new Controller({\\n    container,\\n    layers: [geoModelLayer]\\n  });\\n  controller.setBounds([0, 1000], [0, 1000]);\\n  controller.adjustToSize(width, height);\\n  controller.zoomPanHandler.zFactor = 1;\\n  controller.zoomPanHandler.setTranslateBounds([-5000, 6000], [-5000, 6000]);\\n  controller.zoomPanHandler.enableTranslateExtent = false;\\n  controller.setViewport(1000, 1000, 5000);\\n  root.appendChild(createHelpText('High level interface for creating and displaying geo model (aka surfaces). This layer is made using webGL.'));\\n  root.appendChild(container);\\n  root.appendChild(fpsLabel);\\n  return root;\\n}\",\n    ...GeoModelUsingHighLevelInterface.parameters?.storySource\n  }\n};\nGeoModelWithLabelsUsingHighLevelInterface.parameters = {\n  ...GeoModelWithLabelsUsingHighLevelInterface.parameters,\n  storySource: {\n    source: \"() => {\\n  const root = createRootContainer(width);\\n  const container = createLayerContainer(width, height);\\n  const fpsLabel = createFPSLabel();\\n  const options: LayerOptions<SurfaceData> = {\\n    order: 1\\n  };\\n  const pixiContext = new PixiRenderApplication({\\n    width,\\n    height\\n  });\\n  const geoModelLayer = new GeomodelLayerV2(pixiContext, 'geomodels', options);\\n  geoModelLayer.onMount({\\n    elm: container,\\n    height,\\n    width\\n  });\\n  const options2: GeomodelLayerLabelsOptions<SurfaceData> = {\\n    order: 1\\n  };\\n  const geoModelLabelsLayer = new GeomodelLabelsLayer('labels', options2);\\n  geoModelLabelsLayer.onMount({\\n    elm: container\\n  });\\n  Promise.all([getWellborePath(), getSurfaces(), getStratColumns()]).then(values => {\\n    const [path, surfaces, stratColumns] = values;\\n    const referenceSystem = new IntersectionReferenceSystem(path);\\n    const displacement = referenceSystem.displacement || 1;\\n    const extend = 1000 / displacement;\\n    const steps = surfaces[0]?.data?.values?.length || 1;\\n    const traj = referenceSystem.getTrajectory(steps, 0, 1 + extend);\\n    const trajectory: number[][] = IntersectionReferenceSystem.toDisplacement(traj.points, traj.offset);\\n    const geolayerdata: SurfaceData = generateSurfaceData(trajectory, stratColumns, surfaces);\\n    const controller = new Controller({\\n      container,\\n      layers: [geoModelLayer, geoModelLabelsLayer]\\n    });\\n    controller.setReferenceSystem(referenceSystem);\\n    geoModelLayer.setData(geolayerdata);\\n    geoModelLabelsLayer.setData(geolayerdata);\\n    controller.setBounds([0, 1000], [0, 1000]);\\n    controller.adjustToSize(width, height);\\n    controller.zoomPanHandler.zFactor = 1;\\n    controller.zoomPanHandler.setTranslateBounds([-5000, 6000], [-5000, 6000]);\\n    controller.zoomPanHandler.enableTranslateExtent = false;\\n    controller.setViewport(1000, 1000, 5000);\\n  });\\n  root.appendChild(createHelpText('High level interface for creating and displaying geo model (aka surfaces) with labels. The geo model layer is made using webGL and the labels using canvas.'));\\n  root.appendChild(container);\\n  root.appendChild(fpsLabel);\\n  return root;\\n}\",\n    ...GeoModelWithLabelsUsingHighLevelInterface.parameters?.storySource\n  }\n};\nGeoModelCanvasUsingHighLevelInterface.parameters = {\n  ...GeoModelCanvasUsingHighLevelInterface.parameters,\n  storySource: {\n    source: \"() => {\\n  const root = createRootContainer(width);\\n  const container = createLayerContainer(width, height);\\n  const fpsLabel = createFPSLabel();\\n  const options: LayerOptions<SurfaceData> = {\\n    order: 1\\n  };\\n  const geoModelLayer = new GeomodelCanvasLayer('canvas', options);\\n  Promise.all([getWellborePath(), getSurfaces(), getStratColumns(), getPositionLog()]).then(values => {\\n    const [path, surfaces, stratColumns] = values;\\n    const referenceSystem = new IntersectionReferenceSystem(path);\\n    const displacement = referenceSystem.displacement || 1;\\n    const extend = 1000 / displacement;\\n    const steps = surfaces[0]?.data?.values?.length || 1;\\n    const traj = referenceSystem.getTrajectory(steps, 0, 1 + extend);\\n    const trajectory: number[][] = IntersectionReferenceSystem.toDisplacement(traj.points, traj.offset);\\n    const geolayerdata: SurfaceData = generateSurfaceData(trajectory, stratColumns, surfaces);\\n    geoModelLayer.setData(geolayerdata);\\n  });\\n  const controller = new Controller({\\n    container,\\n    layers: [geoModelLayer]\\n  });\\n  controller.setBounds([0, 1000], [0, 1000]);\\n  controller.adjustToSize(width, height);\\n  controller.zoomPanHandler.zFactor = 1;\\n  controller.zoomPanHandler.setTranslateBounds([-5000, 6000], [-5000, 6000]);\\n  controller.zoomPanHandler.enableTranslateExtent = false;\\n  controller.setViewport(1000, 1000, 5000);\\n  root.appendChild(createHelpText('High level interface for creating and displaying geo model (aka surfaces). This layer is made using plain HTML canvas. GeomodelLayer is preferred for rendering geo models if your browser supports WebGL.'));\\n  root.appendChild(container);\\n  root.appendChild(fpsLabel);\\n  return root;\\n}\",\n    ...GeoModelCanvasUsingHighLevelInterface.parameters?.storySource\n  }\n};"],"names":["DEFAULT_MAX_DEPTH","GeomodelCanvasLayer","CanvasLayer","id","options","__publicField","color","path","ctx","data","polygons","polygon","i","topIsValid","endIsReached","j","s","paths","d","penDown","event","p","l","colorToCSSColor","acc","mapped","width","height","GeoModelUsingLowLevelInterface","root","createRootContainer","container","createLayerContainer","fpsLabel","createFPSLabel","pixiContext","PixiRenderApplication","geoModelLayer","GeomodelLayerV2","getWellborePath","getSurfaces","getStratColumns","getPositionLog","values","surfaces","stratColumns","referenceSystem","IntersectionReferenceSystem","extend","steps","_c","_b","_a","traj","trajectory","geolayerdata","generateSurfaceData","zoomHandler","ZoomPanHandler","createHelpText","GeoModelWithLabelsUsingLowLevelInterface","options2","geoModelLabelsLayer","GeomodelLabelsLayer","GeoModelUsingHighLevelInterface","controller","Controller","GeoModelWithLabelsUsingHighLevelInterface","GeoModelCanvasUsingHighLevelInterface","geomodelLayer_stories"],"mappings":"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"}