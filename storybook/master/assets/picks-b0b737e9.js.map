{"version":3,"file":"picks-b0b737e9.js","sources":["../../../../src/utils/text.ts","../../../../src/layers/CalloutCanvasLayer.ts","../../../../src/datautils/picks.ts"],"sourcesContent":["import { clamp } from '@equinor/videx-math';\n\nimport { BoundingBox } from '../interfaces';\nimport { ScaleLinear } from 'd3-scale';\n\nconst DEFAULT_HORIZONTAL_PADDING = 4;\nconst DEFAULT_VERTICAL_PADDING = 2;\n\nexport function pixelsPerUnit(x: ScaleLinear<number, number>): number {\n  const [min] = x.domain() as [number, number];\n  return Math.abs(x(min + 1));\n}\n\nexport function calcSize(factor: number, min: number, max: number, x: ScaleLinear<number, number>): number {\n  return clamp(pixelsPerUnit(x) * factor, min, max);\n}\n\nexport function isOverlappingHorizontally(r1: BoundingBox, r2: BoundingBox): boolean {\n  const r1x2 = r1.x + r1.width;\n  const r2x2 = r2.x + r2.width;\n\n  if (r2.x > r1x2 || r2x2 < r1.x) {\n    return false;\n  }\n  return true;\n}\n\nexport function isOverlapping(\n  r1: BoundingBox,\n  r2: BoundingBox,\n  horizontalPadding: number = DEFAULT_HORIZONTAL_PADDING,\n  verticalPadding: number = DEFAULT_VERTICAL_PADDING,\n): boolean {\n  const r1x2 = r1.x + r1.width + horizontalPadding;\n  const r2x2 = r2.x + r2.width + horizontalPadding;\n  const r1y2 = r1.y + r1.height + verticalPadding;\n  const r2y2 = r2.y + r2.height + verticalPadding;\n\n  if (r2.x - horizontalPadding > r1x2 || r2.y - verticalPadding > r1y2 || r2x2 + horizontalPadding < r1.x || r2y2 + verticalPadding < r1.y) {\n    return false;\n  }\n  return true;\n}\n\nexport function getOverlap(r1: BoundingBox, r2: BoundingBox): { dx: number; dy: number } | undefined {\n  const r1x2 = r1.x + r1.width;\n  const r2x2 = r2.x + r2.width;\n  const r1y2 = r1.y + r1.height;\n  const r2y2 = r2.y + r2.height;\n\n  if (r2.x > r1x2 || r2.y > r1y2 || r2x2 < r1.x || r2y2 < r1.y) {\n    return undefined;\n  }\n\n  const dx = Math.max(0, Math.min(r1.x + r1.width, r2.x + r2.width) - Math.max(r1.x, r2.x));\n  const dy = Math.max(0, Math.min(r1.y + r1.height, r2.y + r2.height) - Math.max(r1.y, r2.y));\n\n  const newPoints = {\n    dx,\n    dy,\n  };\n  return newPoints;\n}\n\nexport function getOverlapOffset(\n  r1: BoundingBox,\n  r2: BoundingBox,\n  horizontalPadding = DEFAULT_HORIZONTAL_PADDING,\n  verticalPadding = DEFAULT_VERTICAL_PADDING,\n): { dx: number; dy: number } | undefined {\n  const r1x2 = r1.x + r1.width;\n  const r2x2 = r2.x + r2.width;\n  const r1y2 = r1.y + r1.height;\n  const r2y2 = r2.y + r2.height;\n\n  if (r2.x - horizontalPadding > r1x2 || r2.y - verticalPadding > r1y2 || r2x2 + horizontalPadding < r1.x || r2y2 + verticalPadding < r1.y) {\n    return undefined;\n  }\n\n  const dx = r1.x + r1.width - r2.x + horizontalPadding;\n  const dy = r1.y + r1.height - r2.y + verticalPadding;\n\n  const newPoints = {\n    dx,\n    dy,\n  };\n  return newPoints;\n}\n","import { ScaleLinear } from 'd3-scale';\n\nimport { CanvasLayer } from './base/CanvasLayer';\nimport { OnUpdateEvent, Annotation, OnRescaleEvent, BoundingBox } from '../interfaces';\nimport { calcSize, isOverlapping, getOverlapOffset } from '../utils';\nimport { LayerOptions } from './base/Layer';\n\nconst DEFAULT_MIN_FONT_SIZE = 7;\nconst DEFAULT_MAX_FONT_SIZE = 11;\nconst DEFAULT_FONT_SIZE_FACTOR = 7;\n\nconst DEFAULT_OFFSET_MIN = 20;\nconst DEFAULT_OFFSET_MAX = 120;\nconst DEFAULT_OFFSET_FACTOR = 19;\n\nconst DEFAULT_BACKGROUND_COLOR = 'rgba(0, 0, 0, 0.5)';\nconst DEFAULT_BACKGROUND_PADDING = 5;\nconst DEFAULT_BACKGROUND_BORDER_RADIUS = 5;\n\n/** Input returned if present, defaultValue used as fallback. */\nfunction getValueOrDefault<T>(input: T | null | undefined, defaultValue: T): T {\n  return input === null || input === undefined ? defaultValue : input;\n}\n\nconst Location = {\n  topleft: 'topleft',\n  topright: 'topright',\n  bottomleft: 'bottomleft',\n  bottomright: 'bottomright',\n};\n\nexport type Point = {\n  x: number;\n  y: number;\n};\n\nexport type Callout = {\n  title: string;\n  label: string;\n  color: string;\n  pos: Point;\n  group: string;\n  alignment: string;\n  boundingBox: BoundingBox;\n  dx: number;\n  dy: number;\n};\n\nexport interface CalloutOptions<T extends Annotation[]> extends LayerOptions<T> {\n  minFontSize?: number;\n  maxFontSize?: number;\n  fontSizeFactor?: number;\n  offsetMin?: number;\n  offsetMax?: number;\n  offsetFactor?: number;\n  fontColor?: string;\n  backgroundColor?: string;\n  backgroundPadding?: number;\n  backgroundBorderRadius?: number;\n}\n\nexport class CalloutCanvasLayer<T extends Annotation[]> extends CanvasLayer<T> {\n  rescaleEvent: OnRescaleEvent | undefined;\n  xRatio: number | undefined;\n  callouts: Callout[] = [];\n  groupFilter: string[] = [];\n  minFontSize: number;\n  maxFontSize: number;\n  fontSizeFactor: number;\n  offsetMin: number;\n  offsetMax: number;\n  offsetFactor: number;\n\n  fontColor: string | undefined;\n\n  backgroundActive: boolean;\n  backgroundColor: string;\n  backgroundPadding: number;\n  backgroundBorderRadius: number;\n\n  constructor(id?: string, options?: CalloutOptions<T>) {\n    super(id, options);\n    this.minFontSize = options?.minFontSize || DEFAULT_MIN_FONT_SIZE;\n    this.maxFontSize = options?.maxFontSize || DEFAULT_MAX_FONT_SIZE;\n    this.fontSizeFactor = options?.fontSizeFactor || DEFAULT_FONT_SIZE_FACTOR;\n    this.offsetMin = options?.offsetMin || DEFAULT_OFFSET_MIN;\n    this.offsetMax = options?.offsetMax || DEFAULT_OFFSET_MAX;\n    this.offsetFactor = options?.offsetFactor || DEFAULT_OFFSET_FACTOR;\n\n    this.fontColor = options?.fontColor;\n\n    // Set background as active if 'backgroundColor' is defined\n    if (options?.backgroundColor) {\n      this.backgroundActive = true;\n      this.backgroundColor = options.backgroundColor;\n    } else {\n      this.backgroundActive = false;\n      this.backgroundColor = DEFAULT_BACKGROUND_COLOR;\n    }\n\n    this.backgroundPadding = options?.backgroundPadding || DEFAULT_BACKGROUND_PADDING;\n    this.backgroundBorderRadius = getValueOrDefault(options?.backgroundBorderRadius, DEFAULT_BACKGROUND_BORDER_RADIUS);\n  }\n\n  setGroupFilter(filter: string[]): void {\n    this.groupFilter = filter;\n    this.callouts = [];\n    this.render();\n  }\n\n  override onUpdate(event: OnUpdateEvent<T>): void {\n    super.onUpdate(event);\n    this.callouts = [];\n    this.render();\n  }\n\n  override onRescale(event: OnRescaleEvent): void {\n    super.onRescale(event);\n    const isPanning = this.rescaleEvent && this.rescaleEvent.xRatio === event.xRatio;\n    this.rescaleEvent = event;\n\n    this.render(isPanning);\n  }\n\n  render(isPanning = false): void {\n    requestAnimationFrame(() => {\n      this.clearCanvas();\n\n      if (!this.data || !this.rescaleEvent || !this.referenceSystem) {\n        return;\n      }\n\n      const { xScale, yScale, xBounds } = this.rescaleEvent;\n\n      const fontSize = calcSize(this.fontSizeFactor, this.minFontSize, this.maxFontSize, xScale);\n\n      if (!isPanning || this.callouts.length <= 0) {\n        const { data, ctx, groupFilter } = this;\n        const { calculateDisplacementFromBottom } = this.referenceSystem.options;\n        const isLeftToRight = calculateDisplacementFromBottom ? xBounds[0] < xBounds[1] : xBounds[0] > xBounds[1];\n        const scale = 0;\n\n        ctx != null && (ctx.font = `bold ${fontSize}px arial`);\n        const filtered = data.filter((d: Annotation) => groupFilter.length <= 0 || groupFilter.includes(d.group));\n        const offset = calcSize(this.offsetFactor, this.offsetMin, this.offsetMax, xScale);\n        this.callouts = this.positionCallouts(filtered, isLeftToRight, xScale, yScale, scale, fontSize, offset);\n      }\n\n      this.callouts.forEach((callout) => {\n        const { pos, title, color } = callout;\n        const x = xScale(pos.x);\n        const y = yScale(pos.y);\n\n        const calloutBB = {\n          x,\n          y,\n          width: callout.boundingBox.width,\n          height: fontSize,\n          offsetX: callout.dx,\n          offsetY: callout.dy,\n        };\n\n        this.renderCallout(title, callout.label, calloutBB, color, callout.alignment);\n      });\n    });\n  }\n\n  private renderBackground(title: string, label: string, x: number, y: number, fontSize: number): void {\n    const { ctx } = this;\n\n    if (ctx == null) {\n      return;\n    }\n\n    const padding = this.backgroundPadding;\n    const borderRadius = this.backgroundBorderRadius;\n\n    const titleWidth = this.measureTextWidth(title, fontSize, 'arial', 'bold');\n    const labelWidth = this.measureTextWidth(label, fontSize);\n\n    // Determine width and height of annotation\n    const width = Math.max(titleWidth, labelWidth) + padding * 2;\n    const height = (fontSize + padding) * 2;\n\n    const xMin = x - padding;\n    const yMin = y - 2 * fontSize - padding;\n\n    ctx.fillStyle = this.backgroundColor;\n\n    if (borderRadius > 0) {\n      const xMax = xMin + width;\n      const yMax = yMin + height;\n\n      // Draw rounded rect\n      ctx.beginPath();\n      ctx.moveTo(xMin + borderRadius, yMin); // Top left\n      ctx.lineTo(xMax - borderRadius, yMin);\n      ctx.quadraticCurveTo(xMax, yMin, xMax, yMin + borderRadius); // Top right corner\n      ctx.lineTo(xMax, yMax - borderRadius);\n      ctx.quadraticCurveTo(xMax, yMax, xMax - borderRadius, yMax); // Bottom right corner\n      ctx.lineTo(xMin + borderRadius, yMax);\n      ctx.quadraticCurveTo(xMin, yMax, xMin, yMax - borderRadius); // Bottom left corner\n      ctx.lineTo(xMin, yMin + borderRadius);\n      ctx.quadraticCurveTo(xMin, yMin, xMin + borderRadius, yMin); // Top left corner\n      ctx.fill();\n    } else {\n      // Draw rect if no border radius\n      ctx.fillRect(xMin, yMin, width, height);\n    }\n  }\n\n  private renderAnnotation = (title: string, label: string, x: number, y: number, fontSize: number, color: string): void => {\n    this.renderText(title, x, y - fontSize, fontSize, color, 'arial', 'bold');\n    this.renderText(label, x, y, fontSize, color);\n  };\n\n  private renderText(title: string, x: number, y: number, fontSize: number, color: string, font = 'arial', fontStyle = 'normal'): void {\n    const { ctx } = this;\n    if (ctx != null) {\n      ctx.font = `${fontStyle} ${fontSize}px ${font}`;\n      ctx.fillStyle = this.fontColor || color;\n      ctx.fillText(title, x, y);\n    }\n  }\n\n  private measureTextWidth(title: string, fontSize: number, font = 'arial', fontStyle = 'normal'): number {\n    const { ctx } = this;\n\n    if (ctx == null) {\n      return 0;\n    }\n\n    ctx.font = `${fontStyle} ${fontSize}px ${font}`;\n    return ctx.measureText(title).width;\n  }\n\n  private renderPoint(x: number, y: number, color: string, radius = 3): void {\n    const { ctx } = this;\n\n    if (ctx != null) {\n      ctx.fillStyle = color;\n      ctx.beginPath();\n      ctx.moveTo(x, y);\n      ctx.arc(x, y, radius, 0, Math.PI * 2);\n      ctx.fill();\n    }\n  }\n\n  private renderCallout(title: string, label: string, boundingBox: BoundingBox, color: string, location: string): void {\n    const pos = this.getPosition(boundingBox, location);\n    const { x, y } = pos;\n    const { height, width, x: dotX, y: dotY } = boundingBox;\n\n    const placeLeft = location === Location.topright || location === Location.bottomright;\n\n    if (this.backgroundActive) {\n      this.renderBackground(title, label, x, y, height);\n    }\n\n    this.renderAnnotation(title, label, x, y, height, color);\n    this.renderPoint(dotX, dotY, color);\n    this.renderLine(x, y, width, dotX, dotY, color, placeLeft);\n  }\n\n  private renderLine = (x: number, y: number, width: number, dotX: number, dotY: number, color: string, placeLeft = true): void => {\n    const { ctx } = this;\n    const textX = placeLeft ? x : x + width;\n    const inverseTextX = placeLeft ? x + width : x;\n    const textY = y + 2;\n\n    if (ctx != null) {\n      ctx.strokeStyle = color;\n      ctx.lineWidth = 1;\n\n      ctx.beginPath();\n      ctx.moveTo(dotX, dotY);\n      ctx.lineTo(textX, textY);\n      ctx.lineTo(inverseTextX, textY);\n\n      ctx.stroke();\n    }\n  };\n\n  private getPosition(boundingBox: BoundingBox, location: string): Point {\n    const { x, y, offsetX = 0, offsetY = 0, width } = boundingBox;\n    switch (location) {\n      case Location.topleft:\n        return {\n          x: x - width - offsetX,\n          y: y - offsetY,\n        };\n      case Location.topright:\n        return {\n          x: x + offsetX,\n          y: y - offsetY,\n        };\n      case Location.bottomleft:\n        return {\n          x: x - width - offsetX,\n          y: y + offsetY,\n        };\n      case Location.bottomright:\n        return {\n          x: x + offsetX,\n          y: y + offsetY,\n        };\n      default:\n        return {\n          x,\n          y,\n        };\n    }\n  }\n\n  // Calculates position of a list of annotations\n  positionCallouts(\n    annotations: Annotation[],\n    isLeftToRight: boolean,\n    xScale: ScaleLinear<number, number>,\n    yScale: ScaleLinear<number, number>,\n    _scale: number,\n    fontSize: number,\n    offset = 20,\n  ): Callout[] {\n    if (annotations.length === 0) {\n      return [];\n    }\n    const alignment = isLeftToRight ? Location.topleft : Location.topright;\n\n    const nodes = annotations.map((a) => {\n      const pos = a.pos ? a.pos : this.referenceSystem?.project(a.md!)!;\n      return {\n        title: a.title,\n        label: a.label,\n        color: a.color,\n        pos: { x: pos?.[0]!, y: pos?.[1]! },\n        group: a.group,\n        alignment,\n        boundingBox: this.getAnnotationBoundingBox(a.title, a.label, pos, xScale, yScale, fontSize),\n        dx: offset,\n        dy: offset,\n      };\n    });\n\n    const top = [nodes[nodes.length - 1]!];\n    const bottom: Callout[] = [];\n\n    // Initial best effort\n    this.chooseTopOrBottomPosition(nodes, bottom, top);\n\n    // Adjust position for top set\n    this.adjustTopPositions(top);\n\n    // Adjust position for bottom set\n    this.adjustBottomPositions(bottom);\n\n    return nodes;\n  }\n\n  getAnnotationBoundingBox(\n    title: string,\n    label: string,\n    pos: number[],\n    xScale: ScaleLinear<number, number>,\n    yScale: ScaleLinear<number, number>,\n    height: number,\n  ): { x: number; y: number; width: number; height: number } {\n    const { ctx } = this;\n    const ax1 = xScale(pos[0]!);\n    const ay1 = yScale(pos[1]!);\n\n    const labelWidth = ctx?.measureText(label).width ?? 0;\n    const titleWidth = ctx?.measureText(title).width ?? 0;\n    const width = Math.max(labelWidth, titleWidth);\n\n    const bbox = {\n      x: ax1,\n      y: ay1,\n      width,\n      height: height * 2 + 4,\n    };\n    return bbox;\n  }\n\n  chooseTopOrBottomPosition(nodes: Callout[], bottom: Callout[], top: Callout[]): void {\n    for (let i = nodes.length - 2; i >= 0; --i) {\n      const node = nodes[i]!;\n      const prevNode = top[0]!;\n\n      const overlap = isOverlapping(node.boundingBox, prevNode.boundingBox);\n      if (overlap) {\n        node.alignment = node.alignment === Location.topleft ? Location.bottomright : Location.bottomleft;\n        bottom.push(node);\n        if (i > 0) {\n          top.unshift(nodes[--i]!);\n        }\n      } else {\n        top.unshift(node);\n      }\n    }\n  }\n\n  adjustTopPositions(top: Callout[]): void {\n    for (let i = top.length - 2; i >= 0; --i) {\n      const currentNode = top[i]!;\n      for (let j = top.length - 1; j > i; --j) {\n        const prevNode = top[j]!;\n        const overlap = getOverlapOffset(currentNode.boundingBox, prevNode.boundingBox);\n        if (overlap) {\n          currentNode.dy += overlap.dy;\n          currentNode.boundingBox.y -= overlap.dy;\n        }\n      }\n    }\n  }\n\n  adjustBottomPositions(bottom: Callout[]): void {\n    for (let i = bottom.length - 2; i >= 0; --i) {\n      const currentNode = bottom[i]!;\n      for (let j = bottom.length - 1; j > i; --j) {\n        const prevNode = bottom[j]!;\n        const overlap = getOverlapOffset(prevNode.boundingBox, currentNode.boundingBox);\n        if (overlap) {\n          currentNode.dy += overlap.dy;\n          currentNode.boundingBox.y += overlap.dy;\n        }\n      }\n    }\n  }\n}\n","import { Annotation } from '../interfaces';\n\ntype Pick = {\n  pickIdentifier?: string;\n  confidence: string | null;\n  depthReferencePoint: string;\n  md: number;\n  mdUnit: string;\n  tvd: number;\n};\n\ntype PickWithId = {\n  identifier: string;\n} & Pick;\n\ntype Unit = {\n  identifier: string;\n  top: string;\n  base: string;\n  baseAge: number;\n  topAge: number;\n  colorR: number;\n  colorG: number;\n  colorB: number;\n  stratUnitLevel: number;\n  lithologyType: number;\n  stratUnitParent: number;\n};\n\ntype UnitDto = {\n  unitName: string;\n  topSurface: string;\n  baseSurface: string;\n  ageBase: number;\n  ageTop: number;\n  color: {\n    r: number;\n    g: number;\n    b: number;\n  };\n  level: number;\n  lithType: number;\n  parent: number;\n};\n\ntype PickAndUnit = PickWithId & UnitDto;\n\ntype PairedPickAndUnit = {\n  name: string;\n  mdEntry: number;\n  tvdEntry: number;\n  color: { r: number; g: number; b: number };\n  level: number;\n  entryPick: PickAndUnit;\n  mdExit: number;\n  tvdExit: number;\n  exitPick: PickAndUnit;\n  confidenceEntry: string;\n  confidenceExit: string;\n  from?: number;\n  to?: number;\n};\n\nconst mapPick = (p: PickWithId, groupName: string): Annotation => ({\n  title: p.pickIdentifier || p.identifier,\n  group: groupName,\n  label: `${p.md} ${p.mdUnit} ${p.depthReferencePoint}`,\n  color: groupName === 'strat-picks' ? '#227' : 'rgba(0,0,0,0.8)',\n  md: p.md,\n});\n\nfunction getReferencePicks(picks: PickWithId[]): Annotation[] {\n  if (!picks) {\n    return [];\n  }\n\n  return picks.map((p: PickWithId) => mapPick(p, 'ref-picks'));\n}\n\nfunction getEntryPicks(formationPicks: PairedPickAndUnit[]): Annotation[] {\n  if (!formationPicks) {\n    return [];\n  }\n\n  return formationPicks\n    .filter((d: PairedPickAndUnit) => d.entryPick.md === d.from)\n    .map((p: PairedPickAndUnit) => mapPick(p.entryPick, 'strat-picks'));\n}\n\nfunction getFilteredExitPicks(formationPicks: PairedPickAndUnit[]): Annotation[] {\n  if (!formationPicks) {\n    return [];\n  }\n\n  return (\n    formationPicks\n      .filter((d: PairedPickAndUnit) => formationPicks.findIndex((p: PairedPickAndUnit) => Math.abs(p.entryPick.md - d.exitPick.md) < 0.5) === -1)\n      .map((p: PairedPickAndUnit) => mapPick(p.exitPick, 'strat-picks'))\n      // Remove duplicates from unitpicks filling in gaps in formation\n      .filter((obj: Annotation, i: number, array: Annotation[]) => i === array.findIndex((v: Annotation) => v.title === obj.title && v.md === obj.md))\n  );\n}\n\nexport const getPicksData = (picksData: { unitPicks: PairedPickAndUnit[]; nonUnitPicks: PickWithId[] }): Annotation[] =>\n  [...getReferencePicks(picksData.nonUnitPicks), ...getEntryPicks(picksData.unitPicks), ...getFilteredExitPicks(picksData.unitPicks)].sort(\n    (a, b) => a.md! - b.md!,\n  );\n\n/**\n * @param {Unit} u\n */\nconst unitDto = (u: Unit): UnitDto => ({\n  unitName: u.identifier,\n  topSurface: u.top,\n  baseSurface: u.base,\n  ageBase: u.baseAge,\n  ageTop: u.topAge,\n  color: {\n    r: u.colorR === null ? 255 : u.colorR,\n    g: u.colorG === null ? 255 : u.colorG,\n    b: u.colorB === null ? 255 : u.colorB,\n  },\n  level: u.stratUnitLevel,\n  lithType: u.lithologyType,\n  parent: u.stratUnitParent,\n});\n\n/**\n *\n * @param {number} from\n * @param {number} to\n * @param {{ from: number; to: number; itm: PairedPickAndUnit }[]} arr\n * @param {number} arr.to\n * @param {number} arr.from\n * @returns {[number, number][]}\n */\nfunction findGaps(from: number, to: number, arr: { from: number; to: number; itm: PairedPickAndUnit }[]): [number, number][] {\n  if (arr.length === 0) {\n    return [[from, to]];\n  }\n  const gaps: [number, number][] = [];\n  let d = from;\n  let i = 0;\n  while (d < to && i < arr.length) {\n    const itm = arr[i]!;\n    if (itm.from > d) {\n      gaps.push([d, Math.min(itm.from, to)]);\n    }\n    d = Math.min(to, Math.max(from, itm.to));\n    i += 1;\n  }\n  if (d < to) {\n    gaps.push([d, to]);\n  }\n  return gaps;\n}\n\n/**\n * @param {Unit[]} units\n * @returns {UnitDto[]}\n */\nconst transformStratColumn = (units: Unit[]): UnitDto[] => units.map(unitDto);\n\n/**\n * Join picks data with strat column units\n * @param {Pick[]} picks picks\n * @param {Unit[]} stratColumn strat column\n */\nfunction joinPicksAndStratColumn(picks: Pick[], stratColumn: Unit[]): { joined: PickAndUnit[]; nonUnitPicks: PickWithId[] } {\n  const transformed = transformStratColumn(stratColumn);\n  const nonUnitPicks: PickWithId[] = [];\n  const joined: PickAndUnit[] = [];\n  picks.forEach((p: Pick) => {\n    const matches = transformed.filter((u: UnitDto) => p.pickIdentifier?.search(new RegExp(`(${u.topSurface}|${u.baseSurface})`, 'i')) !== -1);\n    if (matches.length > 0) {\n      matches.forEach((u: UnitDto) =>\n        joined.push({\n          md: p.md,\n          tvd: p.tvd,\n          identifier: p.pickIdentifier!,\n          confidence: p.confidence,\n          mdUnit: p.mdUnit,\n          depthReferencePoint: p.depthReferencePoint,\n          ...u,\n        }),\n      );\n    } else {\n      nonUnitPicks.push({ identifier: p.pickIdentifier!, ...p });\n    }\n  });\n\n  return { joined, nonUnitPicks };\n}\n\n/**\n * Find matching pairs of entry/exit picks\n * @param {PickAndUnit[]} joined picks joined with strat column units\n */\nfunction pairJoinedPicks(joined: PickAndUnit[]): PairedPickAndUnit[] {\n  // pair picks by unit name\n  const pairs = [];\n  let current = null;\n\n  const sorted = joined\n    .filter((d: PickAndUnit) => d.level)\n    .sort((a: PickAndUnit, b: PickAndUnit) => a.unitName.localeCompare(b.unitName) || a.md - b.md || a.ageTop - b.ageTop);\n\n  while (sorted.length > 0) {\n    current = sorted.shift()!;\n    const name = current.identifier;\n    let pairWithName: string;\n\n    const isTop = name === current.topSurface;\n    const isBase = name === current.baseSurface;\n\n    if (isTop) {\n      pairWithName = current.baseSurface;\n    } else if (isBase) {\n      pairWithName = current.topSurface;\n    } else {\n      console.warn(`Unable to match ${name} with top or base surface, ignored`);\n      continue;\n    }\n\n    let top: PickAndUnit | undefined;\n    let base: PickAndUnit | undefined;\n\n    const pairWith = sorted.find((p: PickAndUnit) => p.identifier === pairWithName);\n    if (!pairWith) {\n      console.warn(`Unable to find ${pairWithName} pick for ${name}`);\n      if (isTop) {\n        top = current;\n        base = joined\n          .filter((d: PickAndUnit) => d.level)\n          .sort((a: PickAndUnit, b: PickAndUnit) => a.md - b.md)\n          .find((p: PickAndUnit) => p.md > top!.md);\n        if (base) {\n          console.warn(`Using ${base.identifier} as base for ${name}`);\n        } else {\n          console.warn(`Unable to find a base pick for ${name} pick at ${top.md}, ignored`);\n          continue;\n        }\n      } else if (isBase) {\n        base = current;\n        top = joined\n          .filter((d: PickAndUnit) => d.level)\n          .sort((a: PickAndUnit, b: PickAndUnit) => b.md - a.md)\n          .find((p: PickAndUnit) => p.md < base!.md);\n        if (top) {\n          console.warn(`Using ${top.identifier} as top for ${name}`);\n        } else {\n          console.warn(`Unable to find a top pick for ${name} pick at ${base.md}, ignored`);\n          continue;\n        }\n      } else {\n        console.warn(`${name} ignored`);\n        continue;\n      }\n    } else {\n      top = isTop ? current : pairWith;\n      base = isTop ? pairWith : current;\n\n      if (top.md > base.md) {\n        [top, base] = [base, top];\n      }\n\n      sorted.splice(sorted.indexOf(pairWith), 1);\n    }\n\n    pairs.push(<PairedPickAndUnit>{\n      name: top.unitName,\n      mdEntry: top.md,\n      tvdEntry: top.tvd,\n      color: top.color,\n      level: top.level,\n      entryPick: top,\n      mdExit: base.md,\n      tvdExit: base.tvd,\n      exitPick: base,\n      confidenceEntry: top.confidence,\n      confidenceExit: base.confidence,\n    });\n  }\n\n  return pairs;\n}\n\n/**\n * Transform data for formation track\n * @param {Pick[]} picks picks\n * @param {Unit[]} stratColumn strat column\n */\nexport function transformFormationData(picks: Pick[], stratColumn: Unit[]): { unitPicks: PairedPickAndUnit[]; nonUnitPicks: PickWithId[] } {\n  const { joined, nonUnitPicks } = joinPicksAndStratColumn(picks, stratColumn);\n  const pairs = pairJoinedPicks(joined);\n\n  const itemstack = pairs\n    .filter((d: PairedPickAndUnit) => d.mdEntry < d.mdExit)\n    .sort((a, b) => a.mdEntry - b.mdEntry || a.level - b.level)\n    .reverse();\n\n  // flatten groups of unit picks, so that the highest level is\n  // given presedence over lower levels for overlapping picks.\n  const unitPicks = [];\n  while (itemstack.length > 0) {\n    const first = itemstack.pop()!;\n    const group: PairedPickAndUnit[] = [];\n    while (itemstack.length > 0 && itemstack[itemstack.length - 1]?.level! > first.level) {\n      group.push(itemstack.pop()!);\n    }\n    group.reverse();\n    group.push(first);\n    const arr: { from: number; to: number; itm: PairedPickAndUnit }[] = [];\n    group.forEach((itm: PairedPickAndUnit) => {\n      const gaps = findGaps(itm.mdEntry, itm.mdExit, arr);\n      arr.push(...gaps.map((g) => ({ from: g[0], to: g[1], itm })));\n    });\n    arr.sort((a, b) => a.from - b.from);\n    unitPicks.push(\n      ...arr.map((d) => ({\n        from: d.from,\n        to: d.to,\n        ...d.itm,\n      })),\n    );\n  }\n  return { unitPicks, nonUnitPicks };\n}\n"],"names":["DEFAULT_HORIZONTAL_PADDING","DEFAULT_VERTICAL_PADDING","pixelsPerUnit","x","min","calcSize","factor","max","clamp","isOverlapping","r1","r2","horizontalPadding","verticalPadding","r1x2","r2x2","r1y2","r2y2","getOverlapOffset","dx","dy","DEFAULT_MIN_FONT_SIZE","DEFAULT_MAX_FONT_SIZE","DEFAULT_FONT_SIZE_FACTOR","DEFAULT_OFFSET_MIN","DEFAULT_OFFSET_MAX","DEFAULT_OFFSET_FACTOR","DEFAULT_BACKGROUND_COLOR","DEFAULT_BACKGROUND_PADDING","DEFAULT_BACKGROUND_BORDER_RADIUS","getValueOrDefault","input","defaultValue","Location","CalloutCanvasLayer","CanvasLayer","id","options","title","label","y","fontSize","color","width","dotX","dotY","placeLeft","ctx","textX","inverseTextX","textY","filter","event","isPanning","xScale","yScale","xBounds","data","groupFilter","calculateDisplacementFromBottom","isLeftToRight","scale","filtered","d","offset","callout","pos","calloutBB","padding","borderRadius","titleWidth","labelWidth","height","xMin","yMin","xMax","yMax","font","fontStyle","radius","boundingBox","location","offsetX","offsetY","annotations","_scale","alignment","nodes","a","_a","top","bottom","ax1","ay1","node","prevNode","i","currentNode","j","overlap","mapPick","p","groupName","getReferencePicks","picks","getEntryPicks","formationPicks","getFilteredExitPicks","obj","array","v","getPicksData","picksData","b","unitDto","u","findGaps","from","to","arr","gaps","itm","transformStratColumn","units","joinPicksAndStratColumn","stratColumn","transformed","nonUnitPicks","joined","matches","pairJoinedPicks","pairs","current","sorted","name","pairWithName","isTop","isBase","base","pairWith","transformFormationData","itemstack","unitPicks","first","group","g"],"mappings":"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"}