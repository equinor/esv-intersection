{"version":3,"file":"intersection.stories-39252d96.js","sources":["../../../../src/layers/ReferenceLineLayer.ts"],"sourcesContent":["import { calcSize } from '../utils';\nimport { CanvasLayer, LayerOptions } from './base';\nimport { assertNever } from './schematicInterfaces';\nimport { OnUpdateEvent, OnRescaleEvent, OnMountEvent } from '../interfaces';\nimport { ScaleLinear } from 'd3-scale';\n\nexport type ReferenceLineType = 'wavy' | 'dashed' | 'solid';\n\nexport type ReferenceLine = {\n  text?: string;\n  lineType: ReferenceLineType;\n  color: string;\n  depth: number;\n  lineWidth?: number;\n  textColor?: string;\n  fontSize?: string;\n};\n\nexport interface ReferenceLineLayerOptions extends LayerOptions<ReferenceLine[]> {}\n\nconst foldReferenceLine = <T>(\n  options: {\n    wavy: (wavy: ReferenceLine) => T;\n    dashed: (dashed: ReferenceLine) => T;\n    solid: (solid: ReferenceLine) => T;\n  },\n  refLine: ReferenceLine,\n): T => {\n  switch (refLine.lineType) {\n    case 'wavy':\n      return options.wavy(refLine);\n\n    case 'dashed':\n      return options.dashed(refLine);\n\n    case 'solid':\n      return options.solid(refLine);\n\n    default:\n      return assertNever(refLine.lineType);\n  }\n};\n\nexport class ReferenceLineLayer extends CanvasLayer<ReferenceLine[]> {\n  yScale: ScaleLinear<number, number, never> | null = null;\n  xScale: ScaleLinear<number, number, never> | null = null;\n\n  onMount(event: OnMountEvent) {\n    super.onMount(event);\n  }\n\n  onUpdate(event: OnUpdateEvent<ReferenceLine[]>) {\n    super.onUpdate(event);\n    this.clearCanvas();\n    this.render();\n  }\n\n  onRescale(event: OnRescaleEvent) {\n    super.onRescale(event);\n    this.yScale = event.yScale;\n    this.xScale = event.xScale;\n    this.resetTransform();\n    this.render();\n  }\n\n  private drawDashed(dashed: ReferenceLine) {\n    const { ctx } = this;\n    const { canvas } = this;\n    const y = this.yScale(dashed.depth);\n    ctx.save();\n    ctx.strokeStyle = dashed.color;\n    this.setCtxLineStyle(ctx, dashed);\n    this.setCtxLineWidth(ctx, dashed);\n    ctx.beginPath();\n    ctx.moveTo(0, y);\n    ctx.lineTo(canvas.width, y);\n    ctx.stroke();\n    ctx.restore();\n    if (dashed.text) {\n      this.drawText(ctx, dashed, ctx.canvas.width, y);\n    }\n  }\n\n  private drawSolid(solid: ReferenceLine) {\n    const { ctx } = this;\n    const { canvas } = this;\n    const y = this.yScale(solid.depth);\n    ctx.save();\n    ctx.strokeStyle = solid.color;\n    this.setCtxLineStyle(ctx, solid);\n    this.setCtxLineWidth(ctx, solid);\n    ctx.beginPath();\n    ctx.moveTo(0, y);\n    ctx.lineTo(canvas.width, y);\n    ctx.stroke();\n    ctx.restore();\n    if (solid.text) {\n      this.drawText(ctx, solid, ctx.canvas.width, y);\n    }\n  }\n\n  private drawWavy(wavy: ReferenceLine): void {\n    const factor = 4;\n    const min = 2.5;\n    const max = 500;\n    const { ctx } = this;\n    const { canvas } = this;\n    const waveHeight = calcSize(factor, min, max, this.yScale);\n    const wavePeriod = waveHeight * 2;\n    const y = this.yScale(wavy.depth) - waveHeight;\n    const steps = Math.ceil(canvas.width / wavePeriod) + 1;\n    const xOffset = this.xScale(0) % wavePeriod;\n    ctx.save();\n    ctx.strokeStyle = wavy.color;\n    this.setCtxLineStyle(ctx, wavy);\n    this.setCtxLineWidth(ctx, wavy);\n    for (let i = -1; i < steps; i++) {\n      ctx.beginPath();\n      ctx.arc(i * wavePeriod + xOffset + waveHeight, y, waveHeight, 0, Math.PI);\n      ctx.stroke();\n    }\n    ctx.restore();\n    if (wavy.text) {\n      this.drawText(ctx, wavy, ctx.canvas.width, y);\n    }\n  }\n\n  private drawText(ctx: CanvasRenderingContext2D, refLine: ReferenceLine, x: number, y: number) {\n    const textColor = refLine.textColor || '#000';\n    const fontSize = refLine.fontSize || '10px sans-serif';\n    const textOffsetX = 10;\n    ctx.save();\n    ctx.strokeStyle = textColor;\n    ctx.font = fontSize;\n    ctx.textAlign = 'end';\n    ctx.textBaseline = 'bottom';\n    ctx.fillText(refLine.text, x - textOffsetX, y);\n    ctx.restore();\n  }\n\n  private setCtxLineStyle(ctx: CanvasRenderingContext2D, refLine: ReferenceLine): void {\n    const a = 8;\n    const b = 10;\n    foldReferenceLine(\n      {\n        solid: () => {\n          ctx.setLineDash([]);\n        },\n        dashed: () => {\n          ctx.setLineDash([a, b]);\n        },\n        wavy: () => {\n          ctx.setLineDash([]);\n        },\n      },\n      refLine,\n    );\n  }\n\n  private setCtxLineWidth(ctx: CanvasRenderingContext2D, refLine: ReferenceLine) {\n    const defaultLineWidth = 1;\n    ctx.lineWidth = refLine.lineWidth || defaultLineWidth;\n  }\n\n  private render() {\n    if (!this.ctx || !this.yScale || !this.xScale) {\n      return;\n    }\n\n    requestAnimationFrame(() => {\n      this.clearCanvas();\n\n      this.data?.forEach((refLine) => {\n        foldReferenceLine(\n          {\n            solid: (solid) => this.drawSolid(solid),\n            dashed: (dashed) => this.drawDashed(dashed),\n            wavy: (wavy) => this.drawWavy(wavy),\n          },\n          refLine,\n        );\n      });\n    });\n  }\n}\n"],"names":["foldReferenceLine","options","refLine","assertNever","ReferenceLineLayer","CanvasLayer","event","dashed","ctx","canvas","y","solid","wavy","waveHeight","calcSize","wavePeriod","steps","xOffset","i","x","textColor","fontSize","textOffsetX","_a"],"mappings":"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"}