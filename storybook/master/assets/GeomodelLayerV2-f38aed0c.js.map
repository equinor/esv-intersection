{"version":3,"file":"GeomodelLayerV2-f38aed0c.js","sources":["../../../../src/layers/GeomodelLabelsLayer.ts","../../../../src/layers/GeomodelLayerV2.ts"],"sourcesContent":["import Vector2 from '@equinor/videx-vector2';\nimport { clamp } from '@equinor/videx-math';\n\nimport { CanvasLayer } from './base/CanvasLayer';\nimport { OnUpdateEvent, OnRescaleEvent, OnMountEvent } from '../interfaces';\nimport { SurfaceArea, SurfaceLine, findSampleAtPos, SurfaceData } from '../datautils';\nimport { SURFACE_LINE_WIDTH } from '../constants';\nimport { LayerOptions } from './base/Layer';\n\nconst DEFAULT_MARGINS = 18;\nconst DEFAULT_MIN_FONT_SIZE = 8;\nconst DEFAULT_MAX_FONT_SIZE = 13;\nconst DEFAULT_TEXT_COLOR = 'black';\nconst DEFAULT_FONT = 'Arial';\nconst MAX_FONT_SIZE_IN_WORLD_COORDINATES = 70;\n\nexport interface GeomodelLayerLabelsOptions<T extends SurfaceData> extends LayerOptions<T> {\n  margins?: number;\n  minFontSize?: number;\n  maxFontSize?: number;\n  textColor?: string;\n  font?: string;\n}\n\ninterface SurfaceAreaWithAvgTopDepth extends SurfaceArea {\n  avgTopDepth: number;\n}\n\nexport class GeomodelLabelsLayer<T extends SurfaceData> extends CanvasLayer<T> {\n  defaultMargins: number = DEFAULT_MARGINS;\n  defaultMinFontSize: number = DEFAULT_MIN_FONT_SIZE;\n  defaultMaxFontSize: number = DEFAULT_MAX_FONT_SIZE;\n  defaultTextColor: string = DEFAULT_TEXT_COLOR;\n  defaultFont: string = DEFAULT_FONT;\n\n  rescaleEvent: OnRescaleEvent;\n  isLabelsOnLeftSide: boolean = true;\n  maxFontSizeInWorldCoordinates: number = MAX_FONT_SIZE_IN_WORLD_COORDINATES;\n  isXFlipped: boolean = false;\n  areasWithAvgTopDepth: SurfaceAreaWithAvgTopDepth[] = null;\n\n  constructor(id?: string, options?: GeomodelLayerLabelsOptions<T>) {\n    super(id, options);\n    this.render = this.render.bind(this);\n    this.getMarginsInWorldCoordinates = this.getMarginsInWorldCoordinates.bind(this);\n    this.getSurfacesAreaEdges = this.getSurfacesAreaEdges.bind(this);\n    this.updateXFlipped = this.updateXFlipped.bind(this);\n    this.generateSurfacesWithAvgDepth = this.generateSurfacesWithAvgDepth.bind(this);\n  }\n\n  override get options(): GeomodelLayerLabelsOptions<T> {\n    return this._options;\n  }\n\n  override setData(data: T): void {\n    super.setData(data);\n    this.areasWithAvgTopDepth = null;\n  }\n\n  generateSurfacesWithAvgDepth(): void {\n    const { areas } = this.data;\n    this.areasWithAvgTopDepth = areas.reduce((acc: SurfaceAreaWithAvgTopDepth[], area: SurfaceArea) => {\n      // Filter surfaces without label\n      if (!area.label) {\n        return acc;\n      }\n      const sumAndCount = area.data.reduce(\n        (a: { sum: number; count: number }, d: number[]) => {\n          if (d[1] != null) {\n            a.sum += d[1];\n            a.count++;\n          }\n          return a;\n        },\n        {\n          sum: 0,\n          count: 0,\n        },\n      );\n      if (sumAndCount.count === 0) {\n        return acc;\n      }\n      const avgTopDepth = sumAndCount.sum / sumAndCount.count;\n\n      acc.push({\n        ...area,\n        avgTopDepth,\n      });\n      return acc;\n    }, []);\n  }\n\n  override onMount(event: OnMountEvent): void {\n    super.onMount(event);\n  }\n\n  override onUpdate(event: OnUpdateEvent<T>): void {\n    super.onUpdate(event);\n    this.render();\n  }\n\n  override onRescale(event: OnRescaleEvent): void {\n    this.rescaleEvent = event;\n    this.updateXFlipped();\n    this.resetTransform();\n    this.render();\n  }\n\n  render(): void {\n    if (!this.rescaleEvent) {\n      return;\n    }\n\n    requestAnimationFrame(() => {\n      this.clearCanvas();\n\n      if (!this.data) {\n        return;\n      }\n\n      if (!this.areasWithAvgTopDepth) {\n        this.generateSurfacesWithAvgDepth();\n      }\n\n      this.drawAreaLabels();\n      this.drawLineLabels();\n    });\n  }\n\n  drawAreaLabels(): void {\n    this.areasWithAvgTopDepth.forEach((s: SurfaceAreaWithAvgTopDepth, i: number, array: SurfaceAreaWithAvgTopDepth[]) => {\n      const topmostSurfaceNotDrawnYet = array.reduce((acc: SurfaceAreaWithAvgTopDepth | null, v, index): SurfaceAreaWithAvgTopDepth | null => {\n        if (index > i) {\n          if (acc == null) {\n            acc = v;\n          } else {\n            if (v.avgTopDepth < acc.avgTopDepth) {\n              acc = v;\n            }\n          }\n        }\n        return acc;\n      }, null);\n\n      this.drawAreaLabel(s, topmostSurfaceNotDrawnYet, array, i);\n    });\n  }\n\n  drawLineLabels(): void {\n    this.data.lines.filter((surfaceLine: SurfaceLine) => surfaceLine.label).forEach((surfaceLine: SurfaceLine) => this.drawLineLabel(surfaceLine));\n  }\n\n  drawAreaLabel = (surfaceArea: SurfaceArea, nextSurfaceArea: SurfaceArea | null, surfaces: SurfaceArea[], i: number): void => {\n    const { data } = surfaceArea;\n    const { ctx, maxFontSizeInWorldCoordinates, isXFlipped } = this;\n    const { xScale, yScale, xRatio, yRatio, zFactor } = this.rescaleEvent;\n    let isLabelsOnLeftSide = this.checkDrawLabelsOnLeftSide();\n    const margins = (this.options.margins || this.defaultMargins) * (isXFlipped ? -1 : 1);\n    const marginsInWorldCoords = margins / xRatio;\n    const minFontSize = this.options.minFontSize || this.defaultMinFontSize;\n    const maxFontSize = this.options.maxFontSize || this.defaultMaxFontSize;\n\n    let fontSizeInWorldCoords = maxFontSize / yRatio;\n    if (fontSizeInWorldCoords > maxFontSizeInWorldCoordinates) {\n      fontSizeInWorldCoords = maxFontSizeInWorldCoordinates;\n      if (fontSizeInWorldCoords * yRatio < minFontSize) {\n        fontSizeInWorldCoords = minFontSize / yRatio;\n      }\n    }\n\n    const leftEdge = xScale.invert(xScale.range()[0]) + marginsInWorldCoords;\n    const rightEdge = xScale.invert(xScale.range()[1]) - marginsInWorldCoords;\n    const [surfaceAreaLeftEdge, surfaceAreaRightEdge] = this.getSurfacesAreaEdges();\n\n    // Get label metrics\n    ctx.save();\n    ctx.font = `${fontSizeInWorldCoords * yRatio}px ${this.options.font || this.defaultFont}`;\n    let labelMetrics = ctx.measureText(surfaceArea.label);\n    let labelLengthInWorldCoords = labelMetrics.width / xRatio;\n\n    // Check if label will fit horizontally\n    if (isLabelsOnLeftSide) {\n      const labelRightEdge = leftEdge + (isXFlipped ? -labelLengthInWorldCoords : labelLengthInWorldCoords);\n      if ((!isXFlipped && labelRightEdge > surfaceAreaRightEdge) || (isXFlipped && labelRightEdge < surfaceAreaRightEdge)) {\n        isLabelsOnLeftSide = false;\n      }\n    } else {\n      const labelLeftEdge = rightEdge + (isXFlipped ? labelLengthInWorldCoords : -labelLengthInWorldCoords);\n      if ((!isXFlipped && labelLeftEdge < surfaceAreaLeftEdge) || (isXFlipped && labelLeftEdge > surfaceAreaLeftEdge)) {\n        isLabelsOnLeftSide = true;\n      }\n    }\n\n    // Find edge where to draw\n    let startPos: number;\n    const portionOfLabelLengthUsedForPosCalc = 0.07;\n    if (isLabelsOnLeftSide) {\n      startPos = isXFlipped ? Math.min(surfaceAreaLeftEdge, leftEdge) : Math.max(surfaceAreaLeftEdge, leftEdge);\n    } else {\n      startPos = isXFlipped ? Math.max(surfaceAreaRightEdge, rightEdge) : Math.min(surfaceAreaRightEdge, rightEdge);\n    }\n\n    const topEdge = yScale.invert(yScale.range()[0]);\n    const bottomEdge = yScale.invert(yScale.range()[1]);\n\n    // Calculate where to sample points\n    const dirSteps = 5;\n    const posSteps = 3;\n    const posStep =\n      portionOfLabelLengthUsedForPosCalc * (labelLengthInWorldCoords / posSteps) * (isLabelsOnLeftSide ? 1 : -1) * (isXFlipped ? -1 : 1);\n    const dirStep = (labelLengthInWorldCoords / dirSteps) * (isLabelsOnLeftSide ? 1 : -1) * (isXFlipped ? -1 : 1);\n\n    // Sample points from top and calculate position\n    const topData = data.map((d) => [d[0], d[1]]);\n    const topPos = this.calcPos(topData, startPos, posSteps, posStep, topEdge, bottomEdge);\n    if (!topPos) {\n      return;\n    }\n\n    // Sample points from bottom and calculate position\n    const bottomData = data.map((d) => [d[0], d[2]]);\n    let bottomPos = this.calcPos(\n      bottomData,\n      startPos,\n      posSteps,\n      posStep,\n      topEdge,\n      bottomEdge,\n      nextSurfaceArea ? nextSurfaceArea.data.map((d) => [d[0], d[1]]) : null,\n      surfaces,\n      i,\n    );\n    if (!bottomPos) {\n      bottomPos = new Vector2(topPos.x, bottomEdge);\n    }\n\n    // Check if there is enough height for label\n    const thickness = bottomPos.y - topPos.y;\n    if (thickness < fontSizeInWorldCoords) {\n      // Check minimum fontsize\n      if (thickness * yRatio < minFontSize) {\n        return;\n      }\n      // Use reduced fontsize\n      fontSizeInWorldCoords = thickness;\n      ctx.font = `${fontSizeInWorldCoords * yRatio}px ${this.options.font || this.defaultFont}`;\n      labelMetrics = ctx.measureText(surfaceArea.label);\n      labelLengthInWorldCoords = labelMetrics.width / xRatio;\n    }\n    // Sample points from top and bottom and calculate direction vector\n    const initialDirVec = isLabelsOnLeftSide !== isXFlipped ? Vector2.right : Vector2.left;\n    const areaDir = this.calcAreaDir(\n      topData,\n      bottomData,\n      startPos,\n      dirSteps,\n      dirStep,\n      initialDirVec,\n      topEdge,\n      bottomEdge,\n      0,\n      Math.PI / 4,\n      4,\n      nextSurfaceArea ? nextSurfaceArea.data.map((d) => [d[0], d[1]]) : null,\n      surfaces,\n      i,\n    );\n    const scaledAngle = Math.atan(Math.tan(areaDir) * zFactor);\n\n    // Draw label\n    const textX = startPos;\n    const textY = (topPos.y + bottomPos.y) / 2;\n    const textAngle = isXFlipped ? -scaledAngle : scaledAngle;\n    ctx.textAlign = isLabelsOnLeftSide ? 'left' : 'right';\n    ctx.translate(xScale(textX), yScale(textY));\n    ctx.rotate(textAngle);\n    ctx.fillStyle = this.options.textColor || this.defaultTextColor;\n    ctx.font = `${fontSizeInWorldCoords * yRatio}px ${this.options.font || this.defaultFont}`;\n    ctx.textBaseline = 'middle';\n    ctx.fillText(surfaceArea.label, 0, 0);\n\n    ctx.restore();\n  };\n\n  drawLineLabel = (s: SurfaceLine): void => {\n    const { ctx, isXFlipped } = this;\n    const { xScale, yScale, xRatio, yRatio, zFactor } = this.rescaleEvent;\n    const isLabelsOnLeftSide = this.checkDrawLabelsOnLeftSide();\n    const marginsInWorldCoords = this.getMarginsInWorldCoordinates();\n    const maxFontSize = this.options.maxFontSize || this.defaultMaxFontSize;\n\n    const fontSizeInWorldCoords = maxFontSize / yRatio;\n\n    ctx.save();\n    ctx.font = `${fontSizeInWorldCoords * yRatio}px ${this.options.font || this.defaultFont}`;\n    const labelMetrics = ctx.measureText(s.label);\n    const labelLengthInWorldCoords = labelMetrics.width / xRatio;\n\n    const leftEdge = xScale.invert(xScale.range()[0]) + marginsInWorldCoords;\n    const rightEdge = xScale.invert(xScale.range()[1]) - marginsInWorldCoords;\n    const [surfaceAreaLeftEdge, surfaceAreaRightEdge] = this.getSurfacesAreaEdges();\n\n    // Find edge where to draw\n    let startPos: number;\n    const steps = 5;\n    if (isLabelsOnLeftSide) {\n      startPos = isXFlipped ? Math.max(surfaceAreaRightEdge, rightEdge) : Math.min(surfaceAreaRightEdge, rightEdge);\n    } else {\n      startPos = isXFlipped ? Math.min(surfaceAreaLeftEdge, leftEdge) : Math.max(surfaceAreaLeftEdge, leftEdge);\n    }\n\n    // Calculate where to sample points\n    const step = (labelLengthInWorldCoords / steps) * (isLabelsOnLeftSide ? -1 : 1);\n\n    // Sample points and calculate position and direction vector\n    const { data } = s;\n    const pos = this.calcPos(data, startPos, steps, step);\n    const dir = this.calcLineDir(data, startPos, steps, step, zFactor, isLabelsOnLeftSide ? Vector2.left : Vector2.right);\n    if (!pos || !dir) {\n      return;\n    }\n\n    // Calculate position and direction for label\n    const textX = startPos;\n    const textY = pos.y - SURFACE_LINE_WIDTH - fontSizeInWorldCoords / 2;\n    const textDir = Vector2.angleRight(dir) - (isLabelsOnLeftSide ? Math.PI : 0);\n\n    // Draw label\n    ctx.textAlign = isLabelsOnLeftSide ? 'right' : 'left';\n    ctx.translate(xScale(textX), yScale(textY));\n    ctx.rotate(textDir);\n    ctx.fillStyle = this.colorToCSSColor(s.color);\n    ctx.textBaseline = 'middle';\n    ctx.fillText(s.label, 0, 0);\n\n    ctx.restore();\n  };\n\n  colorToCSSColor(color: number | string): string {\n    if (typeof color === 'string') {\n      return color;\n    }\n\n    let hexString = color.toString(16);\n    // eslint-disable-next-line no-magic-numbers\n    hexString = '000000'.substr(0, 6 - hexString.length) + hexString;\n    return `#${hexString}`;\n  }\n\n  calcPos(\n    data: number[][],\n    offset: number,\n    count: number,\n    step: number,\n    topLimit: number = null,\n    bottomLimit: number = null,\n    alternativeSurfaceData: number[][] = null,\n    surfaces: SurfaceArea[] | null = null,\n    currentSurfaceIndex: number = null,\n  ): Vector2 {\n    const pos = Vector2.zero.mutable;\n    let samples = 0;\n    for (let i = 0; i < count; i++) {\n      const x = offset + i * step;\n      const y = findSampleAtPos(data, x, topLimit, bottomLimit);\n      if (y) {\n        const alternativeY = this.getAlternativeYValueIfAvailable(x, topLimit, bottomLimit, alternativeSurfaceData, surfaces, currentSurfaceIndex);\n        // Use topmost of value from current surface and alternative surface\n        const usedY = alternativeY ? Math.min(y, alternativeY) : y;\n        pos.add(x, usedY);\n        samples++;\n      }\n    }\n\n    if (samples === 0) {\n      return null;\n    }\n\n    return Vector2.divide(pos, samples);\n  }\n\n  getAlternativeYValueIfAvailable(\n    x: number,\n    topLimit: number,\n    bottomLimit: number,\n    alternativeSurfaceData: number[][],\n    surfaces: SurfaceArea[] | null,\n    currentSurfaceIndex: number,\n  ): number {\n    if (!alternativeSurfaceData) {\n      return null;\n    }\n    // Find sample from passed in surface data\n    let altY = findSampleAtPos(alternativeSurfaceData, x, topLimit, bottomLimit);\n    if (altY == null && surfaces && currentSurfaceIndex != null) {\n      //Find topmost surface after current which gives us data\n      let si = currentSurfaceIndex + 1;\n      while (altY == null && si < surfaces.length) {\n        const altSurface = surfaces[si++];\n        altY = findSampleAtPos(\n          altSurface.data.map((d: number[]) => [d[0], d[1]]),\n          x,\n          topLimit,\n          bottomLimit,\n        );\n      }\n    }\n    return altY;\n  }\n\n  calcLineDir(\n    data: number[][],\n    offset: number,\n    count: number,\n    step: number,\n    zFactor: number,\n    initalVector: Vector2 = Vector2.left,\n    topLimit: number = null,\n    bottomLimit: number = null,\n  ): Vector2 {\n    const dir = initalVector.mutable;\n\n    const startY = findSampleAtPos(data, offset, topLimit, bottomLimit);\n    if (startY === null) {\n      return dir;\n    }\n\n    const vecAtEnd = new Vector2(offset, startY * zFactor);\n    const tmpVec = Vector2.zero.mutable;\n    for (let i = 1; i <= count; i++) {\n      const x = offset + i * step;\n      const y = findSampleAtPos(data, offset, topLimit, bottomLimit);\n      if (y !== null) {\n        tmpVec.set(x, y * zFactor);\n        tmpVec.sub(vecAtEnd);\n        dir.add(tmpVec);\n      }\n    }\n\n    return dir;\n  }\n\n  calcAreaDir(\n    top: number[][],\n    bottom: number[][],\n    offset: number,\n    count: number,\n    step: number,\n    initalVector: Vector2 = Vector2.left,\n    topLimit: number = null,\n    bottomLimit: number = null,\n    minReductionAngle: number = 0,\n    maxReductionAngle: number = Math.PI / 4,\n    angleReductionExponent: number = 4,\n    alternativeSurfaceBottomData: number[][] = null,\n    surfaces: SurfaceArea[] | null = null,\n    currentSurfaceIndex: number = null,\n  ): number {\n    const angles: number[] = [];\n    const tmpVec = Vector2.zero.mutable;\n    let vecAtEnd: Vector2;\n    for (let i = 0; i <= count; i++) {\n      const x = offset + i * step;\n      const topY = findSampleAtPos(top, x, topLimit, bottomLimit);\n      const bottomY = findSampleAtPos(bottom, x, topLimit, bottomLimit) || bottomLimit;\n      // Find position of next surface in case it's higher than current base\n      const alternativeBottomY = this.getAlternativeYValueIfAvailable(\n        x,\n        topLimit,\n        bottomLimit,\n        alternativeSurfaceBottomData,\n        surfaces,\n        currentSurfaceIndex,\n      );\n      // Use topmost of value from current surface and alternative surface\n      const usedBottomY = alternativeBottomY ? Math.min(bottomY, alternativeBottomY) : bottomY;\n      if (i === 0) {\n        if (topY === null) {\n          return Vector2.angleRight(initalVector);\n        }\n        const startY = (topY + usedBottomY) / 2;\n        vecAtEnd = new Vector2(offset, startY);\n      } else {\n        if (topY !== null) {\n          tmpVec.set(x, (topY + usedBottomY) / 2);\n          tmpVec.sub(vecAtEnd);\n\n          angles.push(Vector2.angleRight(tmpVec));\n        } else {\n          angles.push(Vector2.angleRight(initalVector));\n        }\n      }\n    }\n\n    const refAngle = angles[0];\n    const offsetAngles = angles.map((d: number) => d - refAngle);\n    let factors = 0;\n    const offsetSum = offsetAngles.reduce((acc: number, v: number) => {\n      const ratio = (Math.abs(v) - minReductionAngle) / maxReductionAngle;\n      const factor = Math.pow(1 - clamp(ratio, 0, 1), angleReductionExponent);\n      factors += factor;\n      return acc + v * factor;\n    }, 0);\n    const angle = offsetSum / factors + refAngle;\n    return angle;\n  }\n\n  updateXFlipped(): void {\n    const { xBounds } = this.rescaleEvent;\n    this.isXFlipped = xBounds[0] > xBounds[1];\n  }\n\n  getMarginsInWorldCoordinates(): number {\n    const { xRatio } = this.rescaleEvent;\n    const margins = (this.options.margins || this.defaultMargins) * (this.isXFlipped ? -1 : 1);\n    const marginsInWorldCoords = margins / xRatio;\n    return marginsInWorldCoords;\n  }\n\n  getSurfacesAreaEdges(): number[] {\n    const endPoints = this.data.areas.reduce((acc, area) => {\n      const { data } = area;\n      const firstValidPoint = data.find((d: number[]) => d[1] != null);\n      if (firstValidPoint) {\n        acc.push(firstValidPoint[0]);\n      }\n      // TODO: Use findLast() when TypeScript stops complaining about it\n      for (let i = data.length - 1; i >= 0; i--) {\n        if (data[i][1] != null) {\n          acc.push(data[i][0]);\n          break;\n        }\n      }\n\n      return acc;\n    }, []);\n    endPoints.push(\n      ...this.data.lines.reduce((acc, line) => {\n        const { data } = line;\n        const firstValidPoint = data.find((d: number[]) => d[1] != null);\n        if (firstValidPoint) {\n          acc.push(firstValidPoint[0]);\n        }\n        // TODO: Use findLast() when TypeScript stops complaining about it\n        for (let i = data.length - 1; i >= 0; i--) {\n          if (data[i][1] != null) {\n            acc.push(data[i][0]);\n            break;\n          }\n        }\n        return acc;\n      }, []),\n    );\n\n    const minX = Math.min(...endPoints);\n    const maxX = Math.max(...endPoints);\n    const marginsInWorldCoords = this.getMarginsInWorldCoordinates();\n    const { isXFlipped } = this;\n    const surfaceAreaLeftEdge = isXFlipped ? maxX + marginsInWorldCoords : minX + marginsInWorldCoords;\n    const surfaceAreaRightEdge = isXFlipped ? minX - marginsInWorldCoords : maxX - marginsInWorldCoords;\n    return [surfaceAreaLeftEdge, surfaceAreaRightEdge];\n  }\n\n  checkDrawLabelsOnLeftSide(): boolean {\n    const { referenceSystem, isXFlipped } = this;\n    if (!referenceSystem) {\n      return true;\n    }\n\n    const { xScale, yScale, xRatio } = this.rescaleEvent;\n    const t = 200; // TODO: Use actual size of largest label or average size of all\n\n    const [dx1, dx2] = xScale.domain();\n    const [dy1, dy2] = yScale.domain();\n\n    let top = referenceSystem.interpolators.curtain.getIntersects(dy1, 1, 0) as number[][];\n    if (top.length === 0) {\n      top = [referenceSystem.interpolators.curtain.getPointAt(0.0) as number[]];\n    }\n    let bottom = referenceSystem.interpolators.curtain.getIntersects(dy2, 1, 0) as number[][];\n    if (bottom.length === 0) {\n      bottom = [referenceSystem.interpolators.curtain.getPointAt(1.0) as number[]];\n    }\n\n    const maxX = Math.max(top[0][0], bottom[0][0]);\n    const minX = Math.min(top[0][0], bottom[0][0]);\n\n    const wbBBox = {\n      left: isXFlipped ? maxX : minX,\n      right: isXFlipped ? minX : maxX,\n    };\n\n    const margin = this.getMarginsInWorldCoordinates();\n    const screenLeftEdge = dx1 + margin;\n    const screenRightEdge = dx2 - margin;\n\n    const [surfaceAreaLeftEdge, surfaceAreaRightEdge] = this.getSurfacesAreaEdges();\n\n    const leftLimit = isXFlipped ? Math.min(screenLeftEdge, surfaceAreaLeftEdge) : Math.max(screenLeftEdge, surfaceAreaLeftEdge);\n    const rightLimit = isXFlipped ? Math.max(screenRightEdge, surfaceAreaRightEdge) : Math.min(screenRightEdge, surfaceAreaRightEdge);\n\n    const spaceOnLeftSide = Math.max(isXFlipped ? leftLimit - wbBBox.left : wbBBox.left - leftLimit, 0);\n    const spaceOnRightSide = Math.max(isXFlipped ? wbBBox.right - rightLimit : rightLimit - wbBBox.right, 0);\n\n    const spaceOnLeftSideInScreenCoordinates = spaceOnLeftSide * xRatio;\n    const spaceOnRightSideInScreenCoordinates = spaceOnRightSide * xRatio;\n    const isLabelsOnLeftSide =\n      spaceOnLeftSide > spaceOnRightSide ||\n      spaceOnLeftSideInScreenCoordinates > t ||\n      (spaceOnLeftSideInScreenCoordinates < t && spaceOnRightSideInScreenCoordinates < t && isXFlipped) ||\n      bottom[0][1] < dy1;\n\n    return isLabelsOnLeftSide;\n  }\n}\n","import { Graphics } from 'pixi.js';\nimport { PixiLayer } from './base/PixiLayer';\nimport { OnUpdateEvent, OnRescaleEvent } from '../interfaces';\nimport { SurfaceArea, SurfaceData, SurfaceLine } from '../datautils';\nimport { SURFACE_LINE_WIDTH } from '../constants';\n\nconst DEFAULT_Y_BOTTOM = 10000;\n\nexport class GeomodelLayerV2<T extends SurfaceData> extends PixiLayer<T> {\n  private isPreRendered: boolean = false;\n\n  override onRescale(event: OnRescaleEvent): void {\n    super.onRescale(event);\n\n    if (!this.isPreRendered) {\n      this.clearLayer();\n      this.preRender();\n    }\n\n    this.render();\n  }\n\n  override onUpdate(event: OnUpdateEvent<T>): void {\n    super.onUpdate(event);\n\n    this.isPreRendered = false;\n    this.clearLayer();\n    this.preRender();\n    this.render();\n  }\n\n  preRender(): void {\n    const { data }: { data: SurfaceData } = this;\n\n    if (!data) {\n      return;\n    }\n\n    data.areas.forEach((a: SurfaceArea) => this.generateAreaPolygon(a));\n    data.lines.forEach((l: SurfaceLine) => this.generateSurfaceLine(l));\n\n    this.isPreRendered = true;\n  }\n\n  createPolygons = (data: number[][]): number[][] => {\n    const polygons: number[][] = [];\n    let polygon: number[] = null;\n\n    // Start generating polygons\n    for (let i = 0; i < data.length; i++) {\n      // Generate top of polygon as long as we have valid values\n      const topIsValid = !!data[i][1];\n      if (topIsValid) {\n        if (polygon === null) {\n          polygon = [];\n        }\n        polygon.push(data[i][0], data[i][1]);\n      }\n\n      const endIsReached = i === data.length - 1;\n      if (!topIsValid || endIsReached) {\n        if (polygon) {\n          // Generate bottom of polygon\n          for (let j: number = !topIsValid ? i - 1 : i; j >= 0; j--) {\n            if (!data[j][1]) {\n              break;\n            }\n            polygon.push(data[j][0], data[j][2] || DEFAULT_Y_BOTTOM);\n          }\n          polygons.push(polygon);\n          polygon = null;\n        }\n      }\n    }\n    return polygons;\n  };\n\n  generateAreaPolygon = (s: SurfaceArea): void => {\n    const g = new Graphics();\n    g.lineStyle(1, s.color as number, 1);\n    g.beginFill(s.color as number);\n    const polygons = this.createPolygons(s.data);\n    polygons.forEach((polygon: number[]) => g.drawPolygon(polygon));\n    g.endFill();\n    this.addChild(g);\n  };\n\n  generateSurfaceLine = (s: SurfaceLine): void => {\n    const g = new Graphics();\n    const { data: d } = s;\n\n    const alignment = 0.5;\n    g.lineStyle(SURFACE_LINE_WIDTH, s.color as number, 1, alignment, true);\n\n    let penDown = false;\n    for (let i = 0; i < d.length; i++) {\n      const lineData = d[i];\n      if (lineData && lineData[1] && lineData[0]) {\n        if (penDown) {\n          g.lineTo(lineData[0], lineData[1]);\n        } else {\n          g.moveTo(lineData[0], lineData[1]);\n          penDown = true;\n        }\n      } else {\n        penDown = false;\n      }\n    }\n    this.addChild(g);\n  };\n}\n"],"names":["DEFAULT_MARGINS","DEFAULT_MIN_FONT_SIZE","DEFAULT_MAX_FONT_SIZE","DEFAULT_TEXT_COLOR","DEFAULT_FONT","MAX_FONT_SIZE_IN_WORLD_COORDINATES","GeomodelLabelsLayer","CanvasLayer","id","options","surfaceArea","nextSurfaceArea","surfaces","i","data","ctx","maxFontSizeInWorldCoordinates","isXFlipped","xScale","yScale","xRatio","yRatio","zFactor","isLabelsOnLeftSide","marginsInWorldCoords","minFontSize","fontSizeInWorldCoords","leftEdge","rightEdge","surfaceAreaLeftEdge","surfaceAreaRightEdge","labelMetrics","labelLengthInWorldCoords","labelRightEdge","labelLeftEdge","startPos","portionOfLabelLengthUsedForPosCalc","topEdge","bottomEdge","dirSteps","posSteps","posStep","dirStep","topData","d","topPos","bottomData","bottomPos","Vector2","thickness","initialDirVec","areaDir","scaledAngle","textX","textY","textAngle","s","steps","step","pos","dir","SURFACE_LINE_WIDTH","textDir","areas","acc","area","sumAndCount","avgTopDepth","event","array","topmostSurfaceNotDrawnYet","v","index","surfaceLine","color","hexString","offset","count","topLimit","bottomLimit","alternativeSurfaceData","currentSurfaceIndex","samples","y","findSampleAtPos","alternativeY","usedY","x","altY","si","altSurface","initalVector","startY","vecAtEnd","tmpVec","top","bottom","minReductionAngle","maxReductionAngle","angleReductionExponent","alternativeSurfaceBottomData","angles","topY","bottomY","alternativeBottomY","usedBottomY","refAngle","offsetAngles","factors","ratio","factor","clamp","xBounds","endPoints","firstValidPoint","line","minX","maxX","referenceSystem","t","dx1","dx2","dy1","dy2","wbBBox","margin","screenLeftEdge","screenRightEdge","leftLimit","rightLimit","spaceOnLeftSide","spaceOnRightSide","spaceOnLeftSideInScreenCoordinates","spaceOnRightSideInScreenCoordinates","DEFAULT_Y_BOTTOM","GeomodelLayerV2","PixiLayer","polygons","polygon","topIsValid","endIsReached","j","g","Graphics","alignment","penDown","lineData","a","l"],"mappings":"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"}