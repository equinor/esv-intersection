var K=Object.defineProperty;var Q=(y,T,t)=>T in y?K(y,T,{enumerable:!0,configurable:!0,writable:!0,value:t}):y[T]=t;var A=(y,T,t)=>(Q(y,typeof T!="symbol"?T+"":T,t),t);import{C as tt,V as b,S as B,f as et,G as $}from"./elements.b2968f38.js";import{f as P}from"./findsample.2f856921.js";import{a as nt}from"./PixiLayer.23a66b84.js";const st=18,it=8,ot=13,at="black",rt="Arial",lt=70;class gt extends tt{constructor(t,e){super(t,e);A(this,"defaultMargins",st);A(this,"defaultMinFontSize",it);A(this,"defaultMaxFontSize",ot);A(this,"defaultTextColor",at);A(this,"defaultFont",rt);A(this,"rescaleEvent");A(this,"isLabelsOnLeftSide",!0);A(this,"maxFontSizeInWorldCoordinates",lt);A(this,"isXFlipped",!1);A(this,"areasWithAvgTopDepth",null);A(this,"drawAreaLabel",(t,e,s,i)=>{const{data:a}=t,{ctx:n,maxFontSizeInWorldCoordinates:l,isXFlipped:r}=this,{xScale:h,yScale:c,xRatio:d,yRatio:o,zFactor:L}=this.rescaleEvent;let u=this.checkDrawLabelsOnLeftSide();const M=(this.options.margins||this.defaultMargins)*(r?-1:1)/d,v=this.options.minFontSize||this.defaultMinFontSize;let f=(this.options.maxFontSize||this.defaultMaxFontSize)/o;f>l&&(f=l,f*o<v&&(f=v/o));const F=h.invert(h.range()[0])+M,D=h.invert(h.range()[1])-M,[C,p]=this.getSurfacesAreaEdges();n.save(),n.font=`${f*o}px ${this.options.font||this.defaultFont}`;let S=n.measureText(t.label),m=S.width/d;if(u){const x=F+(r?-m:m);(!r&&x>p||r&&x<p)&&(u=!1)}else{const x=D+(r?m:-m);(!r&&x<C||r&&x>C)&&(u=!0)}let E;const R=.07;u?E=r?Math.min(C,F):Math.max(C,F):E=r?Math.max(p,D):Math.min(p,D);const W=c.invert(c.range()[0]),w=c.invert(c.range()[1]),Y=5,X=3,U=R*(m/X)*(u?1:-1)*(r?-1:1),G=m/Y*(u?1:-1)*(r?-1:1),V=a.map(x=>[x[0],x[1]]),O=this.calcPos(V,E,X,U,W,w);if(!O)return;const k=a.map(x=>[x[0],x[2]]);let z=this.calcPos(k,E,X,U,W,w,e?e.data.map(x=>[x[0],x[1]]):null,s,i);z||(z=new b(O.x,w));const _=z.y-O.y;if(_<f){if(_*o<v)return;f=_,n.font=`${f*o}px ${this.options.font||this.defaultFont}`,S=n.measureText(t.label),m=S.width/d}const Z=u!==r?b.right:b.left,j=this.calcAreaDir(V,k,E,Y,G,Z,W,w,0,Math.PI/4,4,e?e.data.map(x=>[x[0],x[1]]):null,s,i),N=Math.atan(Math.tan(j)*L),q=E,H=(O.y+z.y)/2,J=r?-N:N;n.textAlign=u?"left":"right",n.translate(h(q),c(H)),n.rotate(J),n.fillStyle=this.options.textColor||this.defaultTextColor,n.font=`${f*o}px ${this.options.font||this.defaultFont}`,n.textBaseline="middle",n.fillText(t.label,0,0),n.restore()});A(this,"drawLineLabel",t=>{const{ctx:e,isXFlipped:s}=this,{xScale:i,yScale:a,xRatio:n,yRatio:l,zFactor:r}=this.rescaleEvent,h=this.checkDrawLabelsOnLeftSide(),c=this.getMarginsInWorldCoordinates(),o=(this.options.maxFontSize||this.defaultMaxFontSize)/l;e.save(),e.font=`${o*l}px ${this.options.font||this.defaultFont}`;const u=e.measureText(t.label).width/n,g=i.invert(i.range()[0])+c,M=i.invert(i.range()[1])-c,[v,I]=this.getSurfacesAreaEdges();let f;const F=5;h?f=s?Math.max(I,M):Math.min(I,M):f=s?Math.min(v,g):Math.max(v,g);const D=u/F*(h?-1:1),{data:C}=t,p=this.calcPos(C,f,F,D),S=this.calcLineDir(C,f,F,D,r,h?b.left:b.right);if(!p||!S)return;const m=f,E=p.y-B-o/2,R=b.angleRight(S)-(h?Math.PI:0);e.textAlign=h?"right":"left",e.translate(i(m),a(E)),e.rotate(R),e.fillStyle=this.colorToCSSColor(t.color),e.textBaseline="middle",e.fillText(t.label,0,0),e.restore()});this.render=this.render.bind(this),this.getMarginsInWorldCoordinates=this.getMarginsInWorldCoordinates.bind(this),this.getSurfacesAreaEdges=this.getSurfacesAreaEdges.bind(this),this.updateXFlipped=this.updateXFlipped.bind(this),this.generateSurfacesWithAvgDepth=this.generateSurfacesWithAvgDepth.bind(this)}get options(){return this._options}setData(t){super.setData(t),this.areasWithAvgTopDepth=null}generateSurfacesWithAvgDepth(){const{areas:t}=this.data;this.areasWithAvgTopDepth=t.reduce((e,s)=>{if(!s.label)return e;const i=s.data.reduce((n,l)=>(l[1]!=null&&(n.sum+=l[1],n.count++),n),{sum:0,count:0});if(i.count===0)return e;const a=i.sum/i.count;return e.push({...s,avgTopDepth:a}),e},[])}onMount(t){super.onMount(t)}onUpdate(t){super.onUpdate(t),this.render()}onRescale(t){this.rescaleEvent=t,this.updateXFlipped(),this.resetTransform(),this.render()}render(){!this.rescaleEvent||requestAnimationFrame(()=>{this.clearCanvas(),this.data&&(this.areasWithAvgTopDepth||this.generateSurfacesWithAvgDepth(),this.drawAreaLabels(),this.drawLineLabels())})}drawAreaLabels(){this.areasWithAvgTopDepth.forEach((t,e,s)=>{const i=s.reduce((a,n,l)=>(l>e&&(a==null||n.avgTopDepth<a.avgTopDepth)&&(a=n),a),null);!i||this.drawAreaLabel(t,i,s,e)})}drawLineLabels(){this.data.lines.filter(t=>t.label).forEach(t=>this.drawLineLabel(t))}colorToCSSColor(t){if(typeof t=="string")return t;let e=t.toString(16);return e="000000".substr(0,6-e.length)+e,`#${e}`}calcPos(t,e,s,i,a=null,n=null,l=null,r=null,h=null){const c=b.zero.mutable;let d=0;for(let o=0;o<s;o++){const L=e+o*i,u=P(t,L,a,n);if(u){const g=this.getAlternativeYValueIfAvailable(L,a,n,l,r,h),M=g?Math.min(u,g):u;c.add(L,M),d++}}return d===0?null:b.divide(c,d)}getAlternativeYValueIfAvailable(t,e,s,i,a,n){if(!i)return null;let l=P(i,t,e,s);if(l==null&&a&&n!=null){let r=n+1;for(;l==null&&r<a.length;){const h=a[r++];l=P(h.data.map(c=>[c[0],c[1]]),t,e,s)}}return l}calcLineDir(t,e,s,i,a,n=b.left,l=null,r=null){const h=n.mutable,c=P(t,e,l,r);if(c===null)return h;const d=new b(e,c*a),o=b.zero.mutable;for(let L=1;L<=s;L++){const u=e+L*i,g=P(t,e,l,r);g!==null&&(o.set(u,g*a),o.sub(d),h.add(o))}return h}calcAreaDir(t,e,s,i,a,n=b.left,l=null,r=null,h=0,c=Math.PI/4,d=4,o=null,L=null,u=null){const g=[],M=b.zero.mutable;let v;for(let p=0;p<=i;p++){const S=s+p*a,m=P(t,S,l,r),E=P(e,S,l,r)||r,R=this.getAlternativeYValueIfAvailable(S,l,r,o,L,u),W=R?Math.min(E,R):E;if(p===0){if(m===null)return b.angleRight(n);const w=(m+W)/2;v=new b(s,w)}else m!==null?(M.set(S,(m+W)/2),M.sub(v),g.push(b.angleRight(M))):g.push(b.angleRight(n))}const I=g[0],f=g.map(p=>p-I);let F=0;return f.reduce((p,S)=>{const m=(Math.abs(S)-h)/c,E=Math.pow(1-et(m,0,1),d);return F+=E,p+S*E},0)/F+I}updateXFlipped(){const{xBounds:t}=this.rescaleEvent;this.isXFlipped=t[0]>t[1]}getMarginsInWorldCoordinates(){const{xRatio:t}=this.rescaleEvent;return(this.options.margins||this.defaultMargins)*(this.isXFlipped?-1:1)/t}getSurfacesAreaEdges(){const t=this.data.areas.reduce((r,h)=>{const{data:c}=h,d=c.find(o=>o[1]!=null);d&&r.push(d[0]);for(let o=c.length-1;o>=0;o--)if(c[o][1]!=null){r.push(c[o][0]);break}return r},[]);t.push(...this.data.lines.reduce((r,h)=>{const{data:c}=h,d=c.find(o=>o[1]!=null);d&&r.push(d[0]);for(let o=c.length-1;o>=0;o--)if(c[o][1]!=null){r.push(c[o][0]);break}return r},[]));const e=Math.min(...t),s=Math.max(...t),i=this.getMarginsInWorldCoordinates(),{isXFlipped:a}=this,n=a?s+i:e+i,l=a?e-i:s-i;return[n,l]}checkDrawLabelsOnLeftSide(){const{referenceSystem:t,isXFlipped:e}=this;if(!t)return!0;const{xScale:s,yScale:i,xRatio:a}=this.rescaleEvent,n=200,[l,r]=s.domain(),[h,c]=i.domain();let d=t.interpolators.curtain.lookup(h,1,0);d.length===0&&(d=[t.interpolators.curtain.getPointAt(0)]);let o=t.interpolators.curtain.lookup(c,1,0);o.length===0&&(o=[t.interpolators.curtain.getPointAt(1)]);const L=Math.max(d[0][0],o[0][0]),u=Math.min(d[0][0],o[0][0]),g={left:e?L:u,right:e?u:L},M=this.getMarginsInWorldCoordinates(),v=l+M,I=r-M,[f,F]=this.getSurfacesAreaEdges(),D=e?Math.min(v,f):Math.max(v,f),C=e?Math.max(I,F):Math.min(I,F),p=Math.max(e?D-g.left:g.left-D,0),S=Math.max(e?g.right-C:C-g.right,0),m=p*a,E=S*a;return p>S||m>n||m<n&&E<n&&e||o[0][1]<h}}const ct=1e4;class pt extends nt{constructor(){super(...arguments);A(this,"isPreRendered",!1);A(this,"createPolygons",t=>{const e=[];let s=null;for(let i=0;i<t.length;i++){const a=!!t[i][1];a&&(s===null&&(s=[]),s.push(t[i][0],t[i][1]));const n=i===t.length-1;if((!a||n)&&s){for(let l=a?i:i-1;l>=0&&t[l][1];l--)s.push(t[l][0],t[l][2]||ct);e.push(s),s=null}}return e});A(this,"generateAreaPolygon",t=>{const e=new $;e.lineStyle(1,t.color,1),e.beginFill(t.color),this.createPolygons(t.data).forEach(i=>e.drawPolygon(i)),e.endFill(),this.addChild(e)});A(this,"generateSurfaceLine",t=>{const e=new $,{data:s}=t,i=.5;e.lineStyle(B,t.color,1,i,!0);let a=!1;for(let n=0;n<s.length;n++)s[n][1]?a?e.lineTo(s[n][0],s[n][1]):(e.moveTo(s[n][0],s[n][1]),a=!0):a=!1;this.addChild(e)})}onRescale(t){super.onRescale(t),this.isPreRendered||(this.clearLayer(),this.preRender()),this.render()}onUpdate(t){super.onUpdate(t),this.isPreRendered=!1,this.clearLayer(),this.preRender(),this.render()}preRender(){const{data:t}=this;!t||(t.areas.forEach(e=>this.generateAreaPolygon(e)),t.lines.forEach(e=>this.generateSurfaceLine(e)),this.isPreRendered=!0)}}export{pt as G,gt as a};
//# sourceMappingURL=GeomodelLayerV2.6dc21a8a.js.map
