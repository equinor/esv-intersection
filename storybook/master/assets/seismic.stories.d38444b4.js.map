{"version":3,"file":"seismic.stories.d38444b4.js","sources":["../../../../src/datautils/trajectory.ts","../../../../.storybook/src/features/seismic.stories.ts"],"sourcesContent":["import Vector2 from '@equinor/videx-vector2';\nimport { seqI } from '@equinor/videx-math';\nimport { CurveInterpolator } from 'curve-interpolator';\nimport { SurveySample } from './interfaces';\n\nconst stepSize = 0.1;\nconst extensionLength = 1000;\nconst thresholdRelativeDist = 150;\nconst thresholdDirectionDist = 30;\n\nconst pathSteps = 10;\n\n/**\n * Generate projected wellbore path for drawing using wellbore path layer\n * Code originally developed for REP\n * @param {[]} poslog Position log from SMDA\n */\nexport function generateProjectedWellborePath(poslog: SurveySample[]): number[][] {\n  if (!poslog || poslog.length === 0) {\n    return [];\n  }\n\n  const points: number[][] = poslog ? poslog.map((p: SurveySample) => [p.easting, p.northing, p.tvd, p.md]) : [];\n\n  const projection: number[][] = simplify(projectCurtain(points));\n  const offset: number = projection[projection.length - 1][0];\n\n  projection.forEach((p, i) => {\n    projection[i][0] = offset - p[0];\n  });\n\n  return projection;\n}\n\n/**\n * Generate Trajectory\n * Code originally developed for REP\n * @param {[]} poslog Position log from SMDA\n * @param {number} defaultIntersectionAngle Default intersection angle for the field\n */\nexport function generateProjectedTrajectory(poslog: SurveySample[], defaultIntersectionAngle: number): number[][] {\n  if (!poslog || poslog.length === 0) {\n    return [];\n  }\n\n  const points: number[][] = poslog ? poslog.map((p) => [p.easting, p.northing, p.tvd, p.md]) : [];\n\n  const interpolator: CurveInterpolator = new CurveInterpolator(points, { tension: 0.75, arcDivisions: 5000 });\n  const displacement: number = interpolator.length;\n\n  const nPoints: number = Math.round(displacement * pathSteps);\n  let path: number[][] = null;\n  if (nPoints > 0) {\n    const maxOffset = 0.0005;\n    const maxDistance = 10;\n    path = simplify(interpolator.getPoints(nPoints), maxOffset, maxDistance);\n  } else {\n    path = [[points[0][0], points[0][1]]];\n  }\n\n  const first: number[] = path[0];\n  const last: number[] = path[path.length - 1];\n  const relativeDist: number = Vector2.distance(first, last);\n  let v: Vector2 = null;\n\n  if (relativeDist < thresholdRelativeDist) {\n    const oneEighty = 180;\n    const radCurtainDirection = (defaultIntersectionAngle / oneEighty) * Math.PI;\n    v = new Vector2(Math.cos(radCurtainDirection), Math.sin(radCurtainDirection)).mutable;\n  } else {\n    v = getDirectionVector(path, thresholdDirectionDist);\n  }\n  const extensionLengthStart: number = Math.max(0, extensionLength - displacement);\n  const offset: number = extensionLengthStart + displacement;\n  const trajectory: number[][] = [];\n\n  let firstPoints: number[][] = [];\n\n  // Reference to initial vector\n  const initial: number[] = v.toArray();\n\n  if (extensionLengthStart > 0) {\n    // extend from start\n    firstPoints = seqI(Math.ceil(extensionLengthStart * stepSize)).map((t) =>\n      v\n        .set(initial)\n        .scale(extensionLengthStart * (1 - t))\n        .subFrom(first)\n        .toArray(),\n    );\n    firstPoints.pop();\n    trajectory.push(...firstPoints);\n  }\n  trajectory.push(...path);\n\n  const endPoints: number[][] = seqI(Math.ceil(extensionLength * stepSize))\n    .map((t) =>\n      v\n        .set(initial)\n        .scale(extensionLength * t)\n        .add(last)\n        .toArray(),\n    )\n    .splice(1);\n\n  trajectory.push(...endPoints);\n\n  const projectedTrajectory: number[][] = projectCurtain(trajectory, null, offset);\n\n  return projectedTrajectory;\n}\n\n/**\n * Get direction vector\n * Code originally developed for REP\n * @param {[]} path\n * @param {number} threshold\n * @returns {Vector2}\n */\nfunction getDirectionVector(path: number[][], threshold: number): Vector2 {\n  const res: Vector2 = Vector2.zero.mutable;\n  let len = 0;\n  const temp: Vector2 = Vector2.zero.mutable;\n\n  for (let i = 0; i < path.length - 1; i++) {\n    const index = path.length - 1 - i;\n    temp.set(path[index]).sub(path[index - 1]);\n    res.add(temp);\n\n    len = res.magnitude;\n    if (len > threshold) {\n      break;\n    }\n  }\n\n  if (len === 0) {\n    return new Vector2([0, 0]);\n  }\n  return res.scale(1 / len);\n}\n\n/**\n * Simplify array\n *\n * Simplifies an array using given parameters.\n * Code originally developed for REP\n * @access public\n *\n * @param {Number[]}      inputArr           Array to simplify\n * @param {Number}        [maxOffset=0.001]  Max offset (Default = 0.001)\n * @param {Number}        [maxDistance=10]   Max distance (Default = 10)\n *\n * @return {Number[]}    Simplified array\n */\nfunction simplify(inputArr: number[][], maxOffset = 0.001, maxDistance = 10): number[][] {\n  if (inputArr.length <= 4) {\n    return inputArr;\n  }\n  const [o0, o1] = inputArr[0];\n  const arr = inputArr.map((d) => [d[0] - o0, d[1] - o1]);\n  let [a0, a1] = arr[0];\n  const sim: number[][] = [inputArr[0]];\n\n  for (let i = 1; i + 1 < arr.length; i++) {\n    const [t0, t1] = arr[i];\n    const [b0, b1] = arr[i + 1];\n\n    // If t->b vector is NOT [0, 0]\n    if (b0 - t0 !== 0 || b1 - t1 !== 0) {\n      // Proximity check\n      const proximity: number = Math.abs(a0 * b1 - a1 * b0 + b0 * t1 - b1 * t0 + a1 * t0 - a0 * t1) / Math.sqrt((b0 - a0) ** 2 + (b1 - a1) ** 2);\n\n      const dir: number[] = [a0 - t0, a1 - t1];\n      const len: number = Math.sqrt(dir[0] ** 2 + dir[1] ** 2);\n\n      if (proximity > maxOffset || len >= maxDistance) {\n        sim.push([t0 + o0, t1 + o1]);\n        [a0, a1] = [t0, t1];\n      }\n    }\n  }\n  const last: number[] = arr[arr.length - 1];\n  sim.push([last[0] + o0, last[1] + o1]);\n\n  return sim;\n}\n\n/**\n * Perform a curtain projection on a set of points in 3D\n * @param points\n * @param origin\n * @param offset\n * @returns {array}\n */\nfunction projectCurtain(points: number[][], origin: number[] = null, offset = 0): number[][] {\n  let p0: number[] = origin || points[0];\n  let l = 0;\n  const projected = points.map((p1: number[]) => {\n    const dx = p1[0] - p0[0];\n    const dy = p1[1] - p0[1];\n    l += Math.sqrt(dx ** 2 + dy ** 2);\n    p0 = p1;\n    return [offset > 0 ? offset - l : l, p1[2] || 0];\n  });\n  return projected;\n}\n","import { SeismicCanvasLayer, ZoomPanHandler, OnRescaleEvent } from '../../../src';\nimport { generateProjectedTrajectory, getSeismicInfo, generateSeismicSliceImage, getSeismicOptions } from '../../../src/datautils';\nimport { getSeismic, getPositionLog } from '../data';\nimport { seismicColorMap } from '../exampledata';\nimport { createRootContainer, createLayerContainer, createFPSLabel } from '../utils';\nconst width: number = 700;\nconst height: number = 600;\nexport const SeismicUsingLowLevelInterface = () => {\n  const root = createRootContainer(width);\n  const container = createLayerContainer(width, height);\n  Promise.all([getPositionLog(), getSeismic()]).then(values => {\n    const [poslog, seismic] = values;\n    const seismicLayer = new SeismicCanvasLayer('seismic', {\n      order: 2,\n      layerOpacity: 1\n    });\n    const ev = {\n      elm: container,\n      width,\n      height\n    };\n    seismicLayer.onMount({\n      ...ev\n    });\n    const trajectory: number[][] = generateProjectedTrajectory(poslog, 45);\n    const seismicInfo = getSeismicInfo(seismic, trajectory);\n    generateSeismicSliceImage(seismic, trajectory, seismicColorMap).then((seismicImage: ImageBitmap) => {\n      seismicLayer.data = {\n        image: seismicImage,\n        options: getSeismicOptions(seismicInfo)\n      };\n    });\n    const zoomHandler = new ZoomPanHandler(container, (event: OnRescaleEvent) => {\n      seismicLayer.onRescale(event);\n    });\n    zoomHandler.setBounds([0, width], [0, height]);\n    zoomHandler.adjustToSize(width, height);\n    zoomHandler.setViewport(width / 2, height / 2, width / 2);\n  });\n  root.appendChild(container);\n  root.appendChild(createFPSLabel());\n  return root;\n};\nexport default {\n  title: 'ESV Intersection/Features/Seismic',\n  component: SeismicUsingLowLevelInterface\n};\nSeismicUsingLowLevelInterface.parameters = {\n  ...SeismicUsingLowLevelInterface.parameters,\n  storySource: {\n    source: \"() => {\\n  const root = createRootContainer(width);\\n  const container = createLayerContainer(width, height);\\n  Promise.all([getPositionLog(), getSeismic()]).then(values => {\\n    const [poslog, seismic] = values;\\n    const seismicLayer = new SeismicCanvasLayer('seismic', {\\n      order: 2,\\n      layerOpacity: 1\\n    });\\n    const ev = {\\n      elm: container,\\n      width,\\n      height\\n    };\\n    seismicLayer.onMount({\\n      ...ev\\n    });\\n    const trajectory: number[][] = generateProjectedTrajectory(poslog, 45);\\n    const seismicInfo = getSeismicInfo(seismic, trajectory);\\n    generateSeismicSliceImage(seismic, trajectory, seismicColorMap).then((seismicImage: ImageBitmap) => {\\n      seismicLayer.data = {\\n        image: seismicImage,\\n        options: getSeismicOptions(seismicInfo)\\n      };\\n    });\\n    const zoomHandler = new ZoomPanHandler(container, (event: OnRescaleEvent) => {\\n      seismicLayer.onRescale(event);\\n    });\\n    zoomHandler.setBounds([0, width], [0, height]);\\n    zoomHandler.adjustToSize(width, height);\\n    zoomHandler.setViewport(width / 2, height / 2, width / 2);\\n  });\\n  root.appendChild(container);\\n  root.appendChild(createFPSLabel());\\n  return root;\\n}\",\n    ...SeismicUsingLowLevelInterface.parameters?.storySource\n  }\n};"],"names":["stepSize","extensionLength","thresholdRelativeDist","thresholdDirectionDist","pathSteps","generateProjectedTrajectory","poslog","defaultIntersectionAngle","points","p","interpolator","CurveInterpolator","displacement","nPoints","path","simplify","first","last","relativeDist","Vector2","v","radCurtainDirection","getDirectionVector","extensionLengthStart","offset","trajectory","firstPoints","initial","seqI","t","endPoints","projectCurtain","threshold","res","len","temp","i","index","inputArr","maxOffset","maxDistance","o0","o1","arr","d","a0","a1","sim","t0","t1","b0","b1","proximity","dir","origin","p0","l","p1","dx","dy","width","height","SeismicUsingLowLevelInterface","root","createRootContainer","container","createLayerContainer","getPositionLog","getSeismic","values","seismic","seismicLayer","SeismicCanvasLayer","ev","seismicInfo","getSeismicInfo","generateSeismicSliceImage","seismicColorMap","seismicImage","getSeismicOptions","zoomHandler","ZoomPanHandler","event","createFPSLabel","seismic_stories","_a"],"mappings":"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"}