var Pe=Object.defineProperty;var Te=(a,n,e)=>n in a?Pe(a,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):a[n]=e;var x=(a,n,e)=>(Te(a,typeof n!="symbol"?n+"":n,e),e);import{M as Z,q as j,t as X,W as G,u as be,v as ke,P as A,w as ve,T,x as Fe,V as ye,y as D,z as W,A as oe,o as Ae,G as q,B as R,E as Le,m as V,F as Re,I as De}from"./elements.b2968f38.js";import{a as Ie}from"./PixiLayer.23a66b84.js";function ne(a,n){let e;if(n===void 0)for(const t of a)t!=null&&(e<t||e===void 0&&t>=t)&&(e=t);else{let t=-1;for(let s of a)(s=n(s,++t,a))!=null&&(e<s||e===void 0&&s>=s)&&(e=s)}return e}function Q(a,n){let e=0;if(n===void 0)for(let t of a)(t=+t)&&(e+=t);else{let t=-1;for(let s of a)(s=+n(s,++t,a))&&(e+=s)}return e}class He extends Z{constructor(n=200,e,t=0){super(new Float32Array(e.length*4),new Float32Array(e.length*4),new Uint16Array((e.length-1)*6)),this.points=e,this._width=n,this.textureScale=t,this.build()}get width(){return this._width}build(){const n=this.points;if(!n)return;const e=this.getBuffer("aVertexPosition"),t=this.getBuffer("aTextureCoord"),s=this.getIndex();if(n.length<1)return;e.data.length/4!==n.length&&(e.data=new Float32Array(n.length*4),t.data=new Float32Array(n.length*4),s.data=new Uint16Array((n.length-1)*6));const o=t.data,r=s.data;o[0]=0,o[1]=0,o[2]=0,o[3]=1;let c=0,h=n[0];const i=this._width*this.textureScale,l=n.length;for(let d=0;d<l;d++){const m=d*4;if(this.textureScale>0){const p=h.x-n[d].x,g=h.y-n[d].y,f=Math.sqrt(p*p+g*g);h=n[d],c+=f/i}else c=d/(l-1);o[m]=c,o[m+1]=0,o[m+2]=c,o[m+3]=1}let u=0;for(let d=0;d<l-1;d++){const m=d*2;r[u++]=m,r[u++]=m+1,r[u++]=m+2,r[u++]=m+2,r[u++]=m+1,r[u++]=m+3}t.update(),s.update(),this.updateVertices()}updateVertices(){const n=this.points;if(n.length<1)return;let e=n[0],t,s=0,o=0;const r=this.buffers[0].data,c=n.length;for(let h=0;h<c;h++){const i=n[h],l=h*4;h<n.length-1?t=n[h+1]:t=i,o=-(t.x-e.x),s=t.y-e.y;const u=Math.sqrt(s*s+o*o),d=this.textureScale>0?this.textureScale*this._width/2:this._width/2;s/=u,o/=u,s*=d,o*=d,r[l]=i.x+s,r[l+1]=i.y+o,r[l+2]=i.x-s,r[l+3]=i.y-o,e=i}this.buffers[0].update()}update(){this.textureScale>0?this.build():this.updateVertices()}}class fe extends j{constructor(n,e,t=0){const s=new He(n.height,e,t),o=new X(n);t>0&&(n.baseTexture.wrapMode=G.REPEAT),super(s,o),this.autoUpdate=!0}_render(n){const e=this.geometry;(this.autoUpdate||e._width!==this.shader.texture.height)&&(e._width=this.shader.texture.height,e.update()),super._render(n)}}function ae(a){throw new Error(`Unexpected object: ${JSON.stringify(a)}`)}const Oe=a=>a.kind==="pAndASymbol",Ee=a=>a.kind==="cementSqueeze",Me=a=>a.kind==="cementPlug",ze=(a,n,e)=>t=>{switch(t.kind){case"screen":return a(t);case"tubing":return n(t);case"completionSymbol":return e(t);default:return ae(t)}},O=(a,n)=>{switch(n){case"Perforation":return a.Perforation(n);case"Open hole gravel pack":return a.OpenHoleGravelPack(n);case"Open hole frac pack":return a.OpenHoleFracPack(n);case"Cased hole fracturation":return a.CasedHoleFracturation(n);case"Cased hole frac pack":return a.CasedHoleFracPack(n);case"Cased hole gravel pack":return a.CasedHoleGravelPack(n);default:return ae(n)}},Be=a=>O({Perforation:()=>!1,OpenHoleGravelPack:()=>!0,OpenHoleFracPack:()=>!0,CasedHoleFracturation:()=>!1,CasedHoleGravelPack:()=>!0,CasedHoleFracPack:()=>!0},a.subKind);function We(a){return O({Perforation:()=>!1,OpenHoleGravelPack:()=>!1,OpenHoleFracPack:()=>!0,CasedHoleFracturation:()=>!0,CasedHoleGravelPack:()=>!1,CasedHoleFracPack:()=>!0},a.subKind)}function Ge(a){return O({Perforation:()=>!0,OpenHoleGravelPack:()=>!1,OpenHoleFracPack:()=>!1,CasedHoleFracturation:()=>!1,CasedHoleGravelPack:()=>!1,CasedHoleFracPack:()=>!1},a.subKind)}function qe(a){return O({Perforation:()=>!1,OpenHoleGravelPack:()=>!1,OpenHoleFracPack:()=>!1,CasedHoleFracturation:()=>!1,CasedHoleGravelPack:()=>!0,CasedHoleFracPack:()=>!1},a.subKind)}function Ve(a){return O({Perforation:()=>!1,OpenHoleGravelPack:()=>!1,OpenHoleFracPack:()=>!1,CasedHoleFracturation:()=>!1,CasedHoleGravelPack:()=>!1,CasedHoleFracPack:()=>!0},a.subKind)}const pe=(a,n)=>a.start<n.end&&a.end>n.start,_e=a=>({holeLayerId:`${a}-hole`,casingLayerId:`${a}-casing`,completionLayerId:`${a}-completion`,cementLayerId:`${a}-cement`,pAndALayerId:`${a}-pAndA`,perforationLayerId:`${a}-perforation`}),Ue={firstColor:"#8c541d",secondColor:"#eee3d8",lineColor:"#8b4513"},Ne={solidColor:"#dcdcdc",lineColor:"#575757",shoeSize:{width:be,length:ke},windowOptions:{dashColor:"#dc0000",dashLength:5,spaceLength:3}},Ze={stroke:"rgba(0, 0, 0, 0.25)",yellow:"#FFFC00",grey:"gray",red:"#FF5050",outline:"black",transparent:"rgba(255, 255, 255, 0)",spikeWidth:50,spikeLength:50,packingOpacity:.5,fracLineCurve:10,fracLineLength:25,scalingFactor:25},je={firstColor:"#c7b9ab",secondColor:"#5b5b5b",scalingFactor:4},Xe={firstColor:"#8b6713",secondColor:"#000000",scalingFactor:4},$e={scalingFactor:4,lineColor:"#63666a"},Ye={scalingFactor:1,innerColor:"#eeeeff",outerColor:"#777788"},Ke={firstColor:"#c7b9ab",secondColor:"#000000",scalingFactor:4},Je={dash:[10,5],width:1,color:16777215,alpha:1,scale:1,useTexture:!1,alignment:.5},L=class{constructor(n,e={}){x(this,"graphics");x(this,"lineLength");x(this,"cursor",new A);x(this,"scale",1);x(this,"activeTexture");x(this,"start");x(this,"dashSize");x(this,"dash");x(this,"useTexture");x(this,"options");this.graphics=n,e={...Je,...e},this.dash=e.dash,this.dashSize=this.dash.reduce((t,s)=>t+s),this.useTexture=e.useTexture,this.options=e,this.setLineStyle()}setLineStyle(){const n=this.options;if(this.useTexture){const e=L.getTexture(n,this.dashSize);this.graphics.lineTextureStyle({width:n.width*n.scale,color:n.color,alpha:n.alpha,texture:e,alignment:n.alignment}),this.activeTexture=e}else this.graphics.lineStyle({width:n.width*n.scale,color:n.color,alpha:n.alpha,cap:n.cap,join:n.join,alignment:n.alignment});this.scale=n.scale}static distance(n,e,t,s){return Math.sqrt(Math.pow(t-n,2)+Math.pow(s-e,2))}moveTo(n,e){return this.lineLength=0,this.cursor.set(n,e),this.start=new A(n,e),this.graphics.moveTo(this.cursor.x,this.cursor.y),this}lineTo(n,e,t){typeof this.lineLength===void 0&&this.moveTo(0,0);const s=L.distance(this.cursor.x,this.cursor.y,n,e),o=Math.atan2(e-this.cursor.y,n-this.cursor.x),r=t&&n===this.start.x&&e===this.start.y;if(this.useTexture)if(this.graphics.moveTo(this.cursor.x,this.cursor.y),this.adjustLineStyle(o),r&&this.dash.length%2===0){const c=Math.min(this.dash[this.dash.length-1],s);this.graphics.lineTo(n-Math.cos(o)*c,e-Math.sin(o)*c),this.graphics.closePath()}else this.graphics.lineTo(n,e);else{const c=Math.cos(o),h=Math.sin(o);let i=this.cursor.x,l=this.cursor.y;const u=this.lineLength%(this.dashSize*this.scale);let d=0,m=0,p=0;for(let f=0;f<this.dash.length;f++){const y=this.dash[f]*this.scale;if(u<p+y){d=f,m=u-p;break}else p+=y}let g=s;for(;g>0;){const f=this.dash[d]*this.scale-m,y=g>f?f:g;if(r&&L.distance(i+c*y,l+h*y,this.start.x,this.start.y)<=y){if(d%2===0){const k=L.distance(i,l,this.start.x,this.start.y)-this.dash[this.dash.length-1]*this.scale;i+=c*k,l+=h*k,this.graphics.lineTo(i,l)}break}i+=c*y,l+=h*y,d%2?this.graphics.moveTo(i,l):this.graphics.lineTo(i,l),g-=y,d++,d=d===this.dash.length?0:d,m=0}}return this.lineLength+=s,this.cursor.set(n,e),this}closePath(){this.lineTo(this.start.x,this.start.y,!0)}drawCircle(n,e,t,s=80,o){const r=Math.PI*2/s;let c=0,h;o?(h=new A(n+Math.cos(c)*t,e+Math.sin(c)*t),o.apply(h,h),this.moveTo(h[0],h[1])):(h=new A(n+Math.cos(c)*t,e+Math.sin(c)*t),this.moveTo(h.x,h.y)),c+=r;for(let i=1;i<s+1;i++){const l=i===s?h:[n+Math.cos(c)*t,e+Math.sin(c)*t];this.lineTo(l[0],l[1]),c+=r}return this}drawEllipse(n,e,t,s,o=80,r){const c=Math.PI*2/o;let h;const i=new A;for(let l=0;l<Math.PI*2;l+=c){let u=n-t*Math.sin(l),d=e-s*Math.cos(l);r&&(i.set(u,d),r.apply(i,i),u=i.x,d=i.y),l===0?(this.moveTo(u,d),h={x:u,y:d}):this.lineTo(u,d)}return this.lineTo(h.x,h.y,!0),this}drawPolygon(n,e){const t=new A;if(typeof n[0]=="number")if(e){t.set(n[0],n[1]),e.apply(t,t),this.moveTo(t.x,t.y);for(let s=2;s<n.length;s+=2)t.set(n[s],n[s+1]),e.apply(t,t),this.lineTo(t.x,t.y,s===n.length-2)}else{this.moveTo(n[0],n[1]);for(let s=2;s<n.length;s+=2)this.lineTo(n[s],n[s+1],s===n.length-2)}else if(e){const s=n[0];t.copyFrom(s),e.apply(t,t),this.moveTo(t.x,t.y);for(let o=1;o<n.length;o++){const r=n[o];t.copyFrom(r),e.apply(t,t),this.lineTo(t.x,t.y,o===n.length-1)}}else{const s=n[0];this.moveTo(s.x,s.y);for(let o=1;o<n.length;o++){const r=n[o];this.lineTo(r.x,r.y,o===n.length-1)}}return this}drawRect(n,e,t,s,o){if(o){const r=new A;r.set(n,e),o.apply(r,r),this.moveTo(r.x,r.y),r.set(n+t,e),o.apply(r,r),this.lineTo(r.x,r.y),r.set(n+t,e+s),o.apply(r,r),this.lineTo(r.x,r.y),r.set(n,e+s),o.apply(r,r),this.lineTo(r.x,r.y),r.set(n,e),o.apply(r,r),this.lineTo(r.x,r.y,!0)}else this.moveTo(n,e).lineTo(n+t,e).lineTo(n+t,e+s).lineTo(n,e+s).lineTo(n,e,!0);return this}adjustLineStyle(n){const e=this.graphics.line;e.matrix=new ve,n&&e.matrix.rotate(n),this.scale!==1&&e.matrix.scale(this.scale,this.scale);const t=-this.lineLength;e.matrix.translate(this.cursor.x+t*Math.cos(n),this.cursor.y+t*Math.sin(n)),this.graphics.lineStyle(e)}static getTexture(n,e){const t=n.dash.toString();if(L.dashTextureCache[t])return L.dashTextureCache[t];const s=document.createElement("canvas");s.width=e,s.height=Math.ceil(n.width);const o=s.getContext("2d");if(!o){console.warn("Did not get context from canvas");return}o.strokeStyle="white",o.globalAlpha=n.alpha,o.lineWidth=n.width;let r=0;const c=n.width/2;o.moveTo(r,c);for(let i=0;i<n.dash.length;i+=2)r+=n.dash[i],o.lineTo(r,c),n.dash.length!==i+1&&(r+=n.dash[i+1],o.moveTo(r,c));o.stroke();const h=L.dashTextureCache[t]=T.from(s);return h.baseTexture.scaleMode=Fe.NEAREST,h}};let _=L;x(_,"dashTextureCache",{});const se=a=>new ye(a.x,a.y),Qe=a=>new A(a[0],a[1]),xe=a=>{if(a.length<2)return[new ye(0)];let n;return a.map((e,t,s)=>{if(t<s.length-1){const o=se(s[t]);return n=se(s[t+1]).sub(o).rotate90().normalized(),n}return n})},Ce=(a,n,e)=>{const t=se(a);return Qe(t.add(n.scale(e)))},re=(a,n,e)=>{if(a.length!==n.length)throw new Error("Number of vectors does not match number of points");return a.map((t,s)=>{const o=n[s];return Ce(t,o,e)})},U=(a,n)=>[...n,...a.map(e=>e.clone()).reverse()],me=(a,n,e,t)=>a<=t&&e<=n,et=(a,n,e,t)=>a<t&&e<n,tt=a=>Array.from(new Set(a)),$=(a,n,e,t)=>{const s=t.filter(r=>me(a,n,r.start,r.end)),o=e.filter(r=>me(a,n,r.start,r.end));return{overlappingHoles:s,overlappingOuterStrings:o}},Y=([a,n],e)=>{const o=e.flatMap(c=>[c.start-1e-4,c.start,c.end,c.end+1e-4]).filter(c=>c>=a&&c<=n);return o.push(a),o.push(n),tt(o).sort((c,h)=>c-h)},v=a=>a.kind==="casing"?a.innerDiameter:a.diameter,we=(a,n,e,t)=>{const o=a.find(i=>i.start<=t&&i.end>=t),r=o?o.diameter:0,c=n.filter(i=>v(i)>r).sort((i,l)=>v(i)-v(l)).find(i=>i.start<=t&&i.end>=t),h=e.find(i=>i.start<=t&&i.end>=t&&i.diameter>r);return c?v(c):h?h.diameter:100},nt=(a,n,e,t)=>{const o=a.sort((c,h)=>h.diameter-c.diameter).find(c=>c.start<=e&&c.end>=e),r=n.find(c=>c.start<=e&&c.end>=e);return o&&t!=="Open hole frac pack"&&t!=="Open hole gravel pack"?v(o):r?r.diameter:100},st=(a,n,e,t)=>{const o=a.sort((i,l)=>v(i)-v(l)).find(i=>i.start<=t&&i.end>=t);if(o)return v(o);const r=a.length?Math.min(...a.map(i=>v(i))):0,c=n.sort((i,l)=>v(i)-v(l)).find(i=>i.start<=t&&i.end>=t&&r<=v(i));if(c)return v(c);const h=e.find(i=>i.start<=t&&i.end>=t&&i.diameter);return h?h.diameter:100},rt=(a,n,e,t,s,o)=>{const{attachedStrings:r,nonAttachedStrings:c}=ie(a.referenceIds,n,e);if(r.length===0)throw new Error(`Invalid cement data, can't find referenced casing/completion string for cement with id '${a.id}'`);r.sort((g,f)=>g.end-f.end);const h=r[r.length-1].end,{overlappingOuterStrings:i,overlappingHoles:l}=$(a.toc,h,c,t),u=[...i,...l].map(g=>({start:g.start,end:g.end}));return Y([a.toc,h],u).flatMap((g,f,y)=>{if(f===y.length-1)return[];const w=y[f+1],k=we(r,i,l,g);return[{top:g,bottom:w,diameter:k*s}]}).map(g=>({diameter:g.diameter,points:o(g.top,g.bottom)}))},ie=(a,n,e)=>[...n,...e].reduce((t,s)=>a.includes(s.id)?{...t,attachedStrings:[...t.attachedStrings,s]}:{...t,nonAttachedStrings:[...t.nonAttachedStrings,s]},{attachedStrings:[],nonAttachedStrings:[]}),ot=(a,n,e,t,s,o)=>{const{attachedStrings:r,nonAttachedStrings:c}=ie(a.referenceIds,n,e);if(r.length===0)throw new Error(`Invalid cement squeeze data, can't find referenced casing/completion for squeeze with id '${a.id}'`);const{overlappingOuterStrings:h,overlappingHoles:i}=$(a.start,a.end,c,t),l=[...h,...i].map(p=>({start:p.start,end:p.end}));return Y([a.start,a.end],l).flatMap((p,g,f)=>{if(g===f.length-1)return[];const y=f[g+1],w=we(r,h,i,p);return[{top:p,bottom:y,diameter:w*s}]}).map(p=>({diameter:p.diameter,points:o(p.top,p.bottom)}))},at=(a,n,e,t,s,o)=>{const{attachedStrings:r,nonAttachedStrings:c}=ie(a.referenceIds,n,e),{overlappingHoles:h,overlappingOuterStrings:i}=$(a.start,a.end,c,t),l=[...r,...h,...i].map(p=>({start:p.start,end:p.end}));return Y([a.start,a.end],l).flatMap((p,g,f)=>{if(g===f.length-1)return[];const y=f[g+1],w=st(r,i,h,p);return[{top:p,bottom:y,diameter:w*s}]}).map(p=>({diameter:p.diameter,points:o(p.top,p.bottom)}))},it=(a,n,e,t,s)=>{const r=n.createLinearGradient(0,0,0,a.height);return r.addColorStop(0,e),r.addColorStop(.5-s,t),r.addColorStop(.5+s,t),r.addColorStop(1,e),r},ct=({firstColor:a,secondColor:n},e,t)=>{const s=document.createElement("canvas");s.width=e,s.height=t;const o=s.getContext("2d");return o.fillStyle=it(s,o,a,n,0),o.fillRect(0,0,s.width,s.height),T.from(s)},ht=({scalingFactor:a})=>{const n=document.createElement("canvas"),e=D*a;n.width=e,n.height=e;const t=n.getContext("2d");t.fillStyle="white",t.fillRect(0,0,n.width,n.height);const s=e/10;t.strokeStyle="#AAAAAA",t.lineWidth=s,t.beginPath();const o=e/3;for(let r=-n.width;r<n.width;r++)t.moveTo(-n.width+o*r,-n.height),t.lineTo(n.width+o*r,n.height*2);return t.stroke(),T.from(n)},lt=({innerColor:a,outerColor:n,scalingFactor:e})=>{const t=D*e,s=document.createElement("canvas");s.width=t,s.height=t;const o=s.getContext("2d"),r=o.createLinearGradient(0,0,0,t),c=.3,h=.7;return r.addColorStop(0,n),r.addColorStop(c,a),r.addColorStop(h,a),r.addColorStop(1,n),o.fillStyle=r,o.fillRect(0,0,s.width,s.height),T.from(s)},dt=({firstColor:a,secondColor:n,scalingFactor:e})=>{const t=document.createElement("canvas"),s=D*e,o=e;t.width=s,t.height=s;const r=t.getContext("2d");r.fillStyle=a,r.fillRect(0,0,t.width,t.height),r.lineWidth=o,r.fillStyle=n,r.beginPath();const c=s/12;for(let h=-t.width;h<t.width;h++)r.moveTo(-t.width+c*h,-t.height),r.lineTo(t.width+c*h,t.height);return r.stroke(),T.from(t)},ut=({firstColor:a,secondColor:n,scalingFactor:e})=>{const t=document.createElement("canvas"),s=D*e;t.width=s,t.height=s;const o=t.getContext("2d");o.fillStyle=a,o.fillRect(0,0,t.width,t.height),o.lineWidth=e,o.strokeStyle=n,o.beginPath(),o.setLineDash([20,10]);const r=s/12;for(let c=-t.width;c<t.width;c++)o.moveTo(-t.width+r*c,-t.height),o.lineTo(t.width+r*c,t.height*2);return o.stroke(),T.from(t)},gt=({firstColor:a,secondColor:n,scalingFactor:e})=>{const t=document.createElement("canvas"),s=D*e,o=e;t.width=s,t.height=s;const r=t.getContext("2d");r.lineWidth=o,r.fillStyle=a,r.strokeStyle=n,r.fillRect(0,0,t.width,t.height),r.beginPath(),r.setLineDash([20,10]);const c=s/12;for(let h=-t.width;h<t.width;h++)r.moveTo(-t.width+c*h,-t.height),r.lineTo(t.width+c*h,t.height*2);return r.stroke(),T.from(t)},B=(a,n)=>{const e=xe(n),t=re(n,e,a);return{leftPath:re(n,e,-a),rightPath:t}},ee=(a,n)=>({kind:"casing",start:a,end:n}),ft=(a,n)=>({kind:"casing-window",start:a,end:n}),pt=a=>{const n=(a.windows||[]).filter(e=>et(a.start,a.end,e.start,e.end)).reduce(({intervals:e,lastBottom:t},s,o,r)=>{const c=t<s.start?ee(t,s.start):null,h=c?c.end:t,i=Math.max(h,s.start),l=Math.min(a.end,s.end),u=ft(i,l),d=l,p=o===r.length-1&&d<a.end?ee(d,a.end):null,g=[c,u,p].filter(f=>f);return{intervals:[...e,...g],lastBottom:d}},{intervals:[],lastBottom:a.start});return n.intervals.length?n.intervals:[ee(a.start,a.end)]},mt=(a,n,e)=>{const t=n.diameter*a,s=t/2,r=n.innerDiameter*a/2,c=s-r,h=pt(n).map(i=>{const l=e(i.start,i.end),{leftPath:u,rightPath:d}=B(s,l);return{kind:i.kind,leftPath:u,rightPath:d,pathPoints:l,polygon:U(u,d)}});return{kind:"casing",id:n.id,referenceDiameter:t,referenceRadius:s,sections:h,casingWallWidth:c,hasShoe:n.hasShoe,bottom:n.end}},yt=(a,n,e,t,s)=>{const{overlappingOuterStrings:o,overlappingHoles:r}=$(a.start,a.end,n,e),c=[...o,...r].map(u=>({start:u.start,end:u.end}));return Y([a.start,a.end],c).flatMap((u,d,m)=>{if(d===m.length-1)return[];const p=m[d+1],g=nt(o,r,u,a.subKind);return[{top:u,bottom:p,diameter:g*t}]}).map(u=>{const d=s(u.top,u.bottom);return{diameter:u.diameter,points:d}})},K=(a,n,e)=>{const{packingOpacity:t,yellow:s}=e;n.fillStyle=s,n.strokeStyle=s;const o=[0,0],r=[a.width,a.height];n.save(),n.globalAlpha=t,n.fillRect(...o,...r),n.restore()},ce=(a,n,e,t,s)=>{const{fracLineCurve:o}=t,r=10,c=a.width/r,h=e/3*t.scalingFactor,i=h/4,l=h/2,u=0,d=s==="diameter"?0:l,m=()=>{for(let p=-1;p<r;p++){const g=[p*c+u+c/2,a.height/2-i-d-i];n.beginPath();const f=[...g],y=[g[0]-o*2,g[1]-i/4],w=[g[0],g[1]-i/2],k=[g[0]+o*2,g[1]-i/2-i/4],S=[g[0],g[1]-i];n.bezierCurveTo(...f,...y,...w),n.bezierCurveTo(...w,...k,...S),n.stroke()}for(let p=-1;p<r;p++){const g=[p*c+c+u+c/2,a.height/2+h/2+d];n.beginPath();const f=[...g],y=[g[0]-o*2,g[1]+i/4],w=[g[0],g[1]+i/2],k=[g[0]+o*2,g[1]+i/2+i/4],S=[g[0],g[1]+i];n.bezierCurveTo(...f,...y,...w),n.bezierCurveTo(...w,...k,...S),n.stroke()}};n.strokeStyle=t.yellow,n.lineWidth=6,n.save(),n.globalAlpha=t.packingOpacity,m(),n.restore(),n.lineWidth=1,n.strokeStyle=t.outline,m(),n.closePath()},xt=(a,n,e,t)=>{const o=a.width/10;n.strokeStyle=t.outline;const r=e/3*t.scalingFactor;n.lineWidth=1;const c=r/2,h=0;for(let i=0;i<=10;i++){const l=[i*o+h,a.height/2-r/2],u=[l[0]-o/2,l[1]-c],d=[l[0]-o,l[1]];n.beginPath(),n.moveTo(...l),n.lineTo(...u),n.lineTo(...d),n.fill(),n.lineWidth=1,n.stroke()}for(let i=0;i<=10;i++){const l=[i*o+h,a.height/2+r/2],u=[l[0]-o/2,l[1]+c],d=[l[0]-o,l[1]];n.beginPath(),n.moveTo(...l),n.lineTo(...u),n.lineTo(...d),n.fill(),n.lineWidth=1,n.stroke()}n.closePath()},F=(a="Error!",n)=>{console.error(`${a}`);const e=(n==null?void 0:n.canvas)||document.createElement("canvas"),t=D;e.width=t/2,e.height=t;const s=(n==null?void 0:n.canvasCtx)||e.getContext("2d"),o=[0,0],r=[e.width,e.height];return s.fillStyle="#ff00ff",s.fillRect(...o,...r),new T(T.from(e,{wrapMode:G.CLAMP}).baseTexture,null,new W(0,0,e.width,e.height),null,oe.MIRROR_HORIZONTAL)},I=(a,n)=>{const e=document.createElement("canvas"),s=a.diameter*n.scalingFactor;e.width=s/2,e.height=s;const o=e.getContext("2d");return{canvas:e,ctx:o}},H=a=>new T(T.from(a,{wrapMode:G.CLAMP}).baseTexture,null,new W(0,0,a.width,a.height),null,oe.MIRROR_HORIZONTAL),he={packing:()=>F(),fracLines:()=>F(),spikes:(a,n,e,t)=>{const{canvas:s,ctx:o}=I(n,t),r=e.some(i=>qe(i)&&pe(a,i)),c=e.some(i=>Ve(i)&&pe(a,i));return r||c?a.isOpen?(o.fillStyle=t.yellow,o.strokeStyle=t.yellow):(o.fillStyle=t.grey,o.strokeStyle=t.grey):a.isOpen?(o.fillStyle=t.red,o.strokeStyle=t.red):(o.fillStyle=t.grey,o.strokeStyle=t.grey),xt(s,o,n.diameter,t),c&&ce(s,o,n.diameter,t,"spike"),H(s)}},Se={packing:()=>F(),fracLines:(a,n)=>{const{canvas:e,ctx:t}=I(a,n);return ce(e,t,a.diameter,n,"diameter"),H(e)},spikes:()=>F()},N={packing:(a,n)=>{const{canvas:e,ctx:t}=I(a,n);return K(e,t,n),H(e)},fracLines:(a,n)=>{const{canvas:e}=I(a,n);return H(e)},spikes:()=>F()},le={packing:(a,n)=>{const{canvas:e,ctx:t}=I(a,n);return K(e,t,n),H(e)},fracLines:()=>F(),spikes:()=>F()},de={packing:(a,n)=>{const{canvas:e,ctx:t}=I(a,n);return K(e,t,n),H(e)},fracLines:()=>F(),spikes:()=>F()},ue={packing:(a,n,e)=>{const{canvas:t,ctx:s}=I(n,e);return K(t,s,e),H(t)},fracLines:(a,n)=>{const{canvas:e,ctx:t}=I(a,n);return ce(e,t,a.diameter,n,"diameter"),H(e)},spikes:()=>F()},Ct=(a,n,e)=>O({Perforation:()=>he.packing(),CasedHoleFracturation:()=>N.packing(n,e),CasedHoleFracPack:()=>N.packing(n,e),OpenHoleGravelPack:()=>de.packing(n,e),OpenHoleFracPack:()=>ue.packing(a,n,e),CasedHoleGravelPack:()=>le.packing(n,e)},a.subKind),wt=(a,n,e)=>O({Perforation:()=>he.fracLines(),OpenHoleGravelPack:()=>de.fracLines(),OpenHoleFracPack:()=>ue.fracLines(n,e),CasedHoleFracturation:()=>Se.fracLines(n,e),CasedHoleGravelPack:()=>le.fracLines(),CasedHoleFracPack:()=>N.fracLines(n,e)},a.subKind),St=(a,n,e,t)=>O({Perforation:()=>he.spikes(a,e,n,t),OpenHoleGravelPack:()=>de.spikes(),OpenHoleFracPack:()=>ue.spikes(),CasedHoleFracturation:()=>Se.spikes(),CasedHoleGravelPack:()=>le.spikes(),CasedHoleFracPack:()=>N.spikes()},a.subKind);class Pt extends Z{constructor(e,t=0){const s=Q(e,o=>o.points.length);super(new Float32Array(s*4),new Float32Array(s*4),new Uint16Array((s-1)*6));x(this,"segments");x(this,"textureScale");this.segments=e,this.textureScale=t,this.build()}get width(){return ne(this.segments,e=>e.diameter)}build(){const e=this.segments;if(!e)return;const t=this.getBuffer("aVertexPosition"),s=this.getBuffer("aTextureCoord"),o=this.getIndex(),r=Q(e,g=>g.points.length);if(r<1)return;t.data.length/4!==r&&(t.data=new Float32Array(r*4),s.data=new Float32Array(r*4),o.data=new Uint16Array((r-1)*6));const c=s.data,h=o.data;c[0]=0,c[1]=0,c[2]=0,c[3]=1;const i=e.length,l=ne(e,g=>g.diameter);let u=0,d=0,m=0,p=0;for(let g=0;g<i;g++){let f=e[g].points[0];const y=l,w=e[g].diameter/l/2,k=e[g].points.length;for(let S=0;S<k;S++){const M=f.x-e[g].points[S].x,E=f.y-e[g].points[S].y,b=Math.sqrt(M*M+E*E);f=e[g].points[S],u+=b/y,c[d]=u,c[d+1]=.5-w,c[d+2]=u,c[d+3]=.5+w,d+=4}for(let S=0;S<k-1;S++)h[p++]=m,h[p++]=m+1,h[p++]=m+2,h[p++]=m+2,h[p++]=m+1,h[p++]=m+3,m+=2;m+=2}s.update(),o.update(),this.updateVertices()}updateVertices(){const e=this.segments;if(Q(e,r=>r.points.length)<1)return;const s=e.length;let o=0;for(let r=0;r<s;r++){let c=e[r].points[0],h,i=0,l=0;const u=this.buffers[0].data,d=e[r].points.length;let m=0;for(let p=0;p<d;p++){const g=e[r].points[p];m=o+p*4,p<e[r].points.length-1?h=e[r].points[p+1]:h=g,l=-(h.x-c.x),i=h.y-c.y;const f=Math.sqrt(i*i+l*l),y=e[r].diameter/2;i/=f,l/=f,i*=y,l*=y,u[m]=g.x+i,u[m+1]=g.y+l,u[m+2]=g.x-i,u[m+3]=g.y-l,c=g}o=m+4}this.buffers[0].update()}update(){this.build()}}class Tt extends j{constructor(e,t,s=0){const o=new Pt(t,s),r=new X(e);e.baseTexture.wrapMode=G.REPEAT;super(o,r);x(this,"autoUpdate");this.autoUpdate=!0}_render(e){const t=this.geometry;this.autoUpdate&&t.update(),super._render(e)}}class bt extends Z{constructor(e,t=200){super(new Float32Array(e.length*4),new Float32Array(e.length*4),new Uint16Array((e.length-1)*6));x(this,"points");x(this,"_width");this.points=e,this._width=t,this.build()}get width(){return this._width}build(){const e=this.points;if(!e)return;const t=this.getBuffer("aVertexPosition"),s=this.getBuffer("aTextureCoord"),o=this.getIndex();if(e.length<1)return;t.data.length/4!==e.length&&(t.data=new Float32Array(e.length*4),s.data=new Float32Array(e.length*4),o.data=new Uint16Array((e.length-1)*6));const r=s.data,c=o.data;r[0]=0,r[1]=0,r[2]=0,r[3]=1;let h=0,i=e[0];const l=e.length;for(let d=0;d<l;d++){const m=d*4,p=i.x-e[d].x,g=i.y-e[d].y,f=Math.sqrt(p*p+g*g);i=e[d],h+=f/this._width,r[m]=h,r[m+1]=0,r[m+2]=h,r[m+3]=1}let u=0;for(let d=0;d<l-1;d++){const m=d*2;c[u++]=m,c[u++]=m+1,c[u++]=m+2,c[u++]=m+2,c[u++]=m+1,c[u++]=m+3}s.update(),o.update(),this.updateVertices()}updateVertices(){const e=this.points;if(e.length<1)return;let t=e[0],s,o=0,r=0;const c=this.buffers[0].data,h=e.length;for(let i=0;i<h;i++){const l=e[i],u=i*4;i<e.length-1?s=e[i+1]:s=l,r=-(s.x-t.x),o=s.y-t.y;const d=Math.sqrt(o*o+r*r),m=this._width/2;o/=d,r/=d,o*=m,r*=m,c[u]=l.x+o,c[u+1]=l.y+r,c[u+2]=l.x-o,c[u+3]=l.y-r,t=l}this.buffers[0].update()}update(){this.build()}}class kt extends j{constructor(e,t,s){const o=new bt(t,s),r=new X(e);e.baseTexture.wrapMode=G.REPEAT;super(o,r);x(this,"autoUpdate");this.autoUpdate=!0}_render(e){const t=this.geometry;this.autoUpdate&&t.update(),super._render(e)}}class vt extends Z{constructor(e,t=200){super(new Float32Array(e.length*4),new Float32Array(e.length*4),new Uint16Array((e.length-1)*6));x(this,"points");x(this,"_width");this.points=e,this._width=t,this.build()}build(){const e=this.points;if(!e)return;const t=this.getBuffer("aVertexPosition"),s=this.getBuffer("aTextureCoord"),o=this.getIndex();if(e.length<1)return;t.data.length/4!==e.length&&(t.data=new Float32Array(e.length*4),s.data=new Float32Array(e.length*4),o.data=new Uint16Array((e.length-1)*6));const r=e.length;let c=0,h=e[0];for(let p=0;p<r;p++){const g=h.x-e[p].x,f=h.y-e[p].y,y=Math.sqrt(g*g+f*f);h=e[p],c+=y}const i=s.data,l=o.data;i[0]=0,i[1]=0,i[2]=0,i[3]=1;let u=0,d=e[0];for(let p=0;p<r;p++){const g=p*4,f=d.x-e[p].x,y=d.y-e[p].y,w=Math.sqrt(f*f+y*y);d=e[p],u+=w/c,i[g]=u,i[g+1]=0,i[g+2]=u,i[g+3]=1}let m=0;for(let p=0;p<r-1;p++){const g=p*2;l[m++]=g,l[m++]=g+1,l[m++]=g+2,l[m++]=g+2,l[m++]=g+1,l[m++]=g+3}s.update(),o.update(),this.updateVertices()}updateVertices(){const e=this.points;if(e.length<1)return;let t=e[0],s,o=0,r=0;const c=this.buffers[0].data,h=e.length;for(let i=0;i<h;i++){const l=e[i],u=i*4;i<e.length-1?s=e[i+1]:s=l,r=-(s.x-t.x),o=s.y-t.y;const d=Math.sqrt(o*o+r*r),m=this._width/2;o/=d,r/=d,o*=m,r*=m,c[u]=l.x+o,c[u+1]=l.y+r,c[u+2]=l.x-o,c[u+3]=l.y-r,t=l}this.buffers[0].update()}update(){this.updateVertices()}}class Ft extends j{constructor(e,t){const s=new vt(t,e.height),o=new X(e);super(s,o);x(this,"autoUpdate");this.autoUpdate=!0}_render(e){const t=this.geometry;(this.autoUpdate||t._width!==this.shader.texture.height)&&(t._width=this.shader.texture.height,t.update()),super._render(e)}}const At=(a,n,e)=>t=>{switch(t.kind){case"casing":return a(t);case"cement":return n(t);case"cementSqueeze":return e(t);default:return ae(t)}},Lt=a=>({exaggerationFactor:2,internalLayerOptions:_e(a),holeOptions:Ue,casingOptions:Ne,cementOptions:je,cementSqueezeOptions:Xe,screenOptions:$e,tubingOptions:Ye,cementPlugOptions:Ke,perforationOptions:Ze}),ge=class extends Ie{constructor(e,t,s){super(e,t,s);x(this,"internalLayerVisibility",{holeLayerId:!0,casingLayerId:!0,completionLayerId:!0,cementLayerId:!0,pAndALayerId:!0,perforationLayerId:!0});x(this,"cementTextureCache");x(this,"cementSqueezeTextureCache");x(this,"cementPlugTextureCache");x(this,"holeTextureCache");x(this,"screenTextureCache");x(this,"tubingTextureCache");x(this,"textureSymbolCacheArray");x(this,"scalingFactors",{height:600,zFactor:1,yScale:Ae()});x(this,"getZFactorScaledPathForPoints",(e,t)=>{const s=r=>r*this.scalingFactors.zFactor;return this.referenceSystem.getCurtainPath(e,t,!0).map(r=>new A(r.point[0],s(r.point[1])))});x(this,"drawBigPolygon",(e,t=0)=>{const s=new q;s.beginFill(t),s.drawPolygon(e),s.endFill(),this.addChild(s)});x(this,"drawBigTexturedPolygon",(e,t)=>{const s=new q().beginTextureFill({texture:t}).drawPolygon(e).endFill();return this.addChild(s),s});x(this,"perforationRopeAndTextureReferences",[]);x(this,"prepareSymbolRenderObject",e=>{const{exaggerationFactor:t}=this.options,s=e.diameter*t;return{pathPoints:this.getZFactorScaledPathForPoints(e.start,e.end),referenceDiameter:s,symbolKey:e.symbolKey}});x(this,"drawSymbolComponent",({pathPoints:e,referenceDiameter:t,symbolKey:s})=>{const o=this.getSymbolTexture(s,t);this.drawSVGRope(e,o)});x(this,"drawHoleSize",(e,t)=>{if(t==null)return;const s=this.getZFactorScaledPathForPoints(t.start,t.end);if(s.length===0)return;const{exaggerationFactor:o,holeOptions:r}=this.options,c=t.diameter*o,{rightPath:h,leftPath:i}=B(c/2,s);if(this.renderType()===V.CANVAS){const l=U(i,h);this.drawBigPolygon(l,R(r.firstColor))}else{const l=this.getHoleTexture(r,c,e);this.drawHoleRope(s,l,e)}this.drawOutline(i,h,R(r.lineColor),Re*o,"TopAndBottom",0)});x(this,"drawCasing",e=>{const{casingOptions:t}=this.options,s=R(t.solidColor),o=R(t.lineColor);e.sections.forEach((r,c,h)=>{const i=ge.getOutlineClosureType(c,h.length-1);if(this.renderType()===V.CANVAS)this.drawBigPolygon(r.polygon,s);else{const l=this.createCasingTexture(e.referenceDiameter);this.drawRope(r.pathPoints,l,s)}r.kind==="casing-window"?this.drawCasingWindowOutline(r.leftPath,r.rightPath,t,e.casingWallWidth):this.drawOutline(r.leftPath,r.rightPath,o,e.casingWallWidth,i)})});x(this,"generateShoe",(e,t,s,o)=>{const r=e-s,c=e,h=this.getZFactorScaledPathForPoints(r,c),i=xe(h),l=re(h,i,t*(o<0?-1:1)),u=h[h.length-1],d=i[i.length-1],m=Ce(u,d,o+t*(o<0?-1:1));return[...l,m]});x(this,"createCementSqueezeShape",(e,t,s,o)=>{const{exaggerationFactor:r}=this.options;return ot(e,t,s,o,r,this.getZFactorScaledPathForPoints)});x(this,"createPerforationShape",(e,t,s)=>{const{exaggerationFactor:o}=this.options;return yt(e,t,s,o,this.getZFactorScaledPathForPoints)});this.options={...this.options,...Lt(this.id),...s}}onUnmount(e){super.onUnmount(e),this.scalingFactors=null,this.cementTextureCache=null,this.cementSqueezeTextureCache=null,this.holeTextureCache=null,this.screenTextureCache=null,this.tubingTextureCache=null,this.textureSymbolCacheArray=null,this.internalLayerVisibility=null}onUpdate(e){super.onUpdate(e),this.clearLayer(),this.preRender(),this.render()}onRescale(e){const t=this.scalingFactors.zFactor!==e.zFactor;this.scalingFactors={height:e.height,zFactor:e.zFactor,yScale:e.yScale},super.optionsRescale(e);const s=this.yRatio(),o=e.xBounds[0]>e.xBounds[1],r=e.yBounds[0]>e.yBounds[1];this.setContainerPosition(e.xScale(0),e.yScale(0)),this.setContainerScale(e.xRatio*(o?-1:1),s*(r?-1:1)),t&&(this.clearLayer(),this.preRender()),this.render()}setVisibility(e,t){if(t===this.id){super.setVisibility(e,t);return}const{internalLayerOptions:s}=this.options,[o]=Object.entries(s).find(([r,c])=>c===t);o&&(this.internalLayerVisibility[o]=e,this.clearLayer(),this.preRender(),this.render())}getInternalLayerIds(){const{internalLayerOptions:e}=this.options;return Object.values(e)}yRatio(){const e=this.scalingFactors.yScale.domain(),s=(e[1]-e[0])*this.scalingFactors.zFactor,o=[e[0],e[0]+s];return Math.abs(this.scalingFactors.height/(o[1]-o[0]))}drawRope(e,t,s){if(e.length===0)return null;const o=new fe(t,e,1);o.tint=s||o.tint,this.addChild(o)}drawOutline(e,t,s,o=1,r="None",c=1){const h=e.map(d=>d.clone()).reverse(),i=t[0],l=h[0],u=new q;u.lineStyle(o,s,void 0,c),u.moveTo(i.x,i.y),t.forEach(d=>u.lineTo(d.x,d.y)),(r==="None"||r==="Top")&&u.moveTo(l.x,l.y),h.forEach(d=>u.lineTo(d.x,d.y)),(r==="TopAndBottom"||r==="Top")&&u.lineTo(i.x,i.y),this.addChild(u)}drawCasingWindowOutline(e,t,{lineColor:s,windowOptions:o},r=1){var f,y;const c=!!((y=(f=this.referenceSystem)==null?void 0:f.options)!=null&&y.calculateDisplacementFromBottom),[h,i]=c?[e,t]:[t,e],[l,u]=c?[1,0]:[0,1],d=new q;d.lineStyle(r,R(s),void 0,u);const m=h[0];d.moveTo(m.x,m.y),h.forEach(w=>d.lineTo(w.x,w.y));const p=new _(d,{dash:[o.dashLength,o.spaceLength],color:R(o.dashColor),width:r,alignment:l}),g=i[0];p.moveTo(g.x,g.y),i.forEach(w=>{p.lineTo(w.x,w.y)}),this.addChild(d)}preRender(){if(!this.data||!this.referenceSystem)return;const{exaggerationFactor:e}=this.options,{holeSizes:t,casings:s,cements:o,completion:r,symbols:c,pAndA:h,perforations:i}=this.data;this.updateSymbolCache(c),t.sort((f,y)=>y.diameter-f.diameter);const l=t.length>0?ne(t,f=>f.diameter)*e:Le*e;this.internalLayerVisibility.holeLayerId&&t.forEach(f=>this.drawHoleSize(l,f)),s.sort((f,y)=>y.diameter-f.diameter);const u=s.map(f=>this.createCasingRenderObject(f)),d=o.map(f=>({kind:"cement",segments:rt(f,s,r,t,e,this.getZFactorScaledPathForPoints),casingIds:(f.referenceIds||[]).filter(y=>y)})),[m,p]=h.reduce(([f,y],w)=>Ee(w)?[[w,...f],y]:[f,[w,...y]],[[],[]]),g=m.map(f=>({kind:"cementSqueeze",segments:this.createCementSqueezeShape(f,s,r,t),casingIds:f.referenceIds}));if(this.sortCementAndCasingRenderObjects(u,d,g).forEach(At(f=>{this.internalLayerVisibility.casingLayerId&&(this.drawCasing(f),f.hasShoe&&this.drawShoe(f.bottom,f.referenceRadius))},f=>{this.internalLayerVisibility.cementLayerId&&this.drawComplexRope(f.segments,this.getCementTexture())},f=>{this.internalLayerVisibility.pAndALayerId&&this.drawComplexRope(f.segments,this.getCementSqueezeTexture())})),this.perforationRopeAndTextureReferences.forEach(({rope:f,texture:y})=>{f.destroy({children:!0,texture:!0,baseTexture:!0}),y.destroy(!0)}),this.perforationRopeAndTextureReferences=[],this.internalLayerVisibility.perforationLayerId){const{perforationOptions:f}=this.options,y=i.filter(Be),w=i.filter(We),k=i.filter(Ge);y.forEach(S=>{const E=this.createPerforationShape(S,s,t).reduce((b,C)=>(b[C.diameter]||(b[C.diameter]=[]),b[C.diameter]=[...b[C.diameter],C],b),{});Object.values(E).forEach(b=>{const C=Ct(S,b[0],f),P=this.drawComplexRope(b,C);this.perforationRopeAndTextureReferences.push({rope:P,texture:C})})}),w.forEach(S=>{const b=this.createPerforationShape(S,s,t).map(C=>({...C,diameter:C.diameter*3})).reduce((C,P)=>(C[P.diameter]||(C[P.diameter]=[]),C[P.diameter]=[...C[P.diameter],P],C),{});Object.values(b).forEach(C=>{C.forEach(P=>{const z=wt(S,P,f),J=this.drawComplexRope([P],z);this.perforationRopeAndTextureReferences.push({rope:J,texture:z})})})}),k.forEach(S=>{const b=this.createPerforationShape(S,s,t).map(C=>({...C,diameter:C.diameter*3})).reduce((C,P)=>(C[P.diameter]||(C[P.diameter]=[]),C[P.diameter]=[...C[P.diameter],P],C),{});Object.values(b).forEach(C=>{C.forEach(P=>{const z=St(S,i,P,f),J=this.drawComplexRope([P],z);this.perforationRopeAndTextureReferences.push({rope:J,texture:z})})})})}this.internalLayerVisibility.completionLayerId&&r.forEach(ze(f=>this.drawScreen(f),f=>this.drawTubing(f),f=>{const y=this.prepareSymbolRenderObject(f);this.drawSymbolComponent(y)})),this.internalLayerVisibility.pAndALayerId&&p.forEach(f=>{if(Oe(f)){const y=this.prepareSymbolRenderObject(f);this.drawSymbolComponent(y)}Me(f)&&this.drawCementPlug(f,s,r,t)})}updateSymbolCache(e){if(this.textureSymbolCacheArray||(this.textureSymbolCacheArray={}),!e)return;const t=Object.keys(this.textureSymbolCacheArray);Object.entries(e).forEach(([s,o])=>{t.includes(s)||(this.textureSymbolCacheArray[s]=T.from(o))})}drawCementPlug(e,t,s,o){const{exaggerationFactor:r,cementPlugOptions:c}=this.options,h=at(e,t,s,o,r,this.getZFactorScaledPathForPoints);this.drawComplexRope(h,this.getCementPlugTexture(c));const{rightPath:i,leftPath:l}=h.reduce((u,d)=>{const{leftPath:m,rightPath:p}=B(d.diameter/2,d.points);return{rightPath:[...u.rightPath,...p],leftPath:[...u.leftPath,...m]}},{rightPath:[],leftPath:[]});this.drawOutline(l,i,R("black"),.25,"TopAndBottom")}createCasingRenderObject(e){const{exaggerationFactor:t}=this.options;return mt(t,e,this.getZFactorScaledPathForPoints)}getCementPlugTexture(e){return this.cementPlugTextureCache||(this.cementPlugTextureCache=ut(e)),this.cementPlugTextureCache}drawSVGRope(e,t){if(e.length===0)return null;const s=new Ft(t,e);this.addChild(s)}getSymbolTexture(e,t){return new T(this.textureSymbolCacheArray[e].baseTexture,null,new W(0,0,0,t),null,oe.MAIN_DIAGONAL)}drawHoleRope(e,t,s){if(e.length===0)return null;const o=new fe(t,e,s/D);this.addChild(o)}getHoleTexture(e,t,s){const o=D,r=o,c=o,h=t/s*o;this.holeTextureCache||(this.holeTextureCache=ct(e,c,r));const i=this.holeTextureCache.baseTexture,l=(r-h)/2,u=new W(0,l,c,h);return new T(i,u)}sortCementAndCasingRenderObjects(e,t,s){let o=0;const{result:r}=e.reduce((c,h)=>{const i=c.remainingCement.find(u=>u.casingIds.includes(h.id)),l=c.remainingCementSqueezes.filter(u=>u.casingIds.includes(h.id));return i&&(i.zIndex=o++),l.forEach(u=>u.zIndex=o++),h.zIndex=o++,{result:[...c.result,i,h,...l],remainingCement:c.remainingCement.filter(u=>u!==i),remainingCementSqueezes:c.remainingCementSqueezes.filter(u=>!l.includes(u))}},{result:[],remainingCement:t,remainingCementSqueezes:s});return r.filter(c=>c!==void 0).sort((c,h)=>c.zIndex-h.zIndex)}drawComplexRope(e,t){if(e.length===0)return null;const{exaggerationFactor:s}=this.options,o=new Tt(t,e,s);return this.addChild(o),o}createCasingTexture(e){return new T(T.WHITE.baseTexture,null,new W(0,0,16,e))}drawShoe(e,t){const{exaggerationFactor:s,casingOptions:o}=this.options,r=o.shoeSize.width*s,c=o.shoeSize.length*s,h=this.generateShoe(e,t,c,r),i=this.generateShoe(e,t,c,-r);this.drawBigPolygon(i),this.drawBigPolygon(h)}getCementTexture(){if(!this.cementTextureCache){const{cementOptions:e}=this.options;this.cementTextureCache=dt(e)}return this.cementTextureCache}getCementSqueezeTexture(){if(!this.cementSqueezeTextureCache){const{cementSqueezeOptions:e}=this.options;this.cementSqueezeTextureCache=gt(e)}return this.cementSqueezeTextureCache}drawScreen({start:e,end:t,diameter:s}){const{exaggerationFactor:o,screenOptions:r}=this.options,c=o*s,h=this.getZFactorScaledPathForPoints(e,t),{leftPath:i,rightPath:l}=B(c/2,h),u=U(i,l),d=this.getScreenTexture();this.renderType()===V.CANVAS?this.drawBigTexturedPolygon(u,d):this.drawCompletionRope(h,d,c),this.drawOutline(i,l,R(r.lineColor),De*o,"TopAndBottom")}drawTubing({diameter:e,start:t,end:s}){const{exaggerationFactor:o,tubingOptions:r}=this.options,c=o*e,h=this.getZFactorScaledPathForPoints(t,s),{leftPath:i,rightPath:l}=B(c/2,h),u=U(i,l),d=this.getTubingTexture(r);this.renderType()===V.CANVAS?this.drawBigTexturedPolygon(u,d):this.drawCompletionRope(h,d,c)}getTubingTexture(e){return this.tubingTextureCache||(this.tubingTextureCache=lt(e)),this.tubingTextureCache}getScreenTexture(){if(!this.screenTextureCache){const{screenOptions:e}=this.options;this.screenTextureCache=ht(e)}return this.screenTextureCache}drawCompletionRope(e,t,s){if(e.length===0)return;const o=new kt(t,e,s);this.addChild(o)}};let te=ge;x(te,"getOutlineClosureType",(e,t)=>e===0?e===t?"TopAndBottom":"Top":e===t?"Bottom":"None");export{te as S,ae as a};
//# sourceMappingURL=SchematicLayer.c4e748ce.js.map
