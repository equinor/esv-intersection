{"version":3,"file":"seismic.stories-a33a6845.js","sources":["../../../../src/datautils/trajectory.ts"],"sourcesContent":["import Vector2 from '@equinor/videx-vector2';\nimport { seqI } from '@equinor/videx-math';\nimport { CurveInterpolator } from 'curve-interpolator';\nimport { SurveySample } from './interfaces';\n\nconst stepSize = 0.1;\nconst extensionLength = 1000;\nconst thresholdRelativeDist = 150;\nconst thresholdDirectionDist = 30;\n\nconst pathSteps = 10;\n\n/**\n * Generate projected wellbore path for drawing using wellbore path layer\n * Code originally developed for REP\n * @param {[]} poslog Position log from SMDA\n */\nexport function generateProjectedWellborePath(poslog: SurveySample[]): number[][] {\n  if (!poslog || poslog.length === 0) {\n    return [];\n  }\n\n  const points: number[][] = poslog ? poslog.map((p: SurveySample) => [p.easting, p.northing, p.tvd, p.md]) : [];\n\n  const projection: number[][] = simplify(projectCurtain(points));\n  const offset: number = projection[projection.length - 1][0];\n\n  projection.forEach((p, i) => {\n    projection[i][0] = offset - p[0];\n  });\n\n  return projection;\n}\n\n/**\n * Generate Trajectory\n * Code originally developed for REP\n * @param {[]} poslog Position log from SMDA\n * @param {number} defaultIntersectionAngle Default intersection angle for the field\n */\nexport function generateProjectedTrajectory(poslog: SurveySample[], defaultIntersectionAngle: number): number[][] {\n  if (!poslog || poslog.length === 0) {\n    return [];\n  }\n\n  const points: number[][] = poslog ? poslog.map((p) => [p.easting, p.northing, p.tvd, p.md]) : [];\n\n  const interpolator: CurveInterpolator = new CurveInterpolator(points, { tension: 0.75, arcDivisions: 5000 });\n  const displacement: number = interpolator.length;\n\n  const nPoints: number = Math.round(displacement * pathSteps);\n  let path: number[][] = null;\n  if (nPoints > 0) {\n    const maxOffset = 0.0005;\n    const maxDistance = 10;\n    path = simplify(interpolator.getPoints(nPoints), maxOffset, maxDistance);\n  } else {\n    path = [[points[0][0], points[0][1]]];\n  }\n\n  const first: number[] = path[0];\n  const last: number[] = path[path.length - 1];\n  const relativeDist: number = Vector2.distance(first, last);\n  let v: Vector2 = null;\n\n  if (relativeDist < thresholdRelativeDist) {\n    const oneEighty = 180;\n    const radCurtainDirection = (defaultIntersectionAngle / oneEighty) * Math.PI;\n    v = new Vector2(Math.cos(radCurtainDirection), Math.sin(radCurtainDirection)).mutable;\n  } else {\n    v = getDirectionVector(path, thresholdDirectionDist);\n  }\n  const extensionLengthStart: number = Math.max(0, extensionLength - displacement);\n  const offset: number = extensionLengthStart + displacement;\n  const trajectory: number[][] = [];\n\n  let firstPoints: number[][] = [];\n\n  // Reference to initial vector\n  const initial: number[] = v.toArray();\n\n  if (extensionLengthStart > 0) {\n    // extend from start\n    firstPoints = seqI(Math.ceil(extensionLengthStart * stepSize)).map((t) =>\n      v\n        .set(initial)\n        .scale(extensionLengthStart * (1 - t))\n        .subFrom(first)\n        .toArray(),\n    );\n    firstPoints.pop();\n    trajectory.push(...firstPoints);\n  }\n  trajectory.push(...path);\n\n  const endPoints: number[][] = seqI(Math.ceil(extensionLength * stepSize))\n    .map((t) =>\n      v\n        .set(initial)\n        .scale(extensionLength * t)\n        .add(last)\n        .toArray(),\n    )\n    .splice(1);\n\n  trajectory.push(...endPoints);\n\n  const projectedTrajectory: number[][] = projectCurtain(trajectory, null, offset);\n\n  return projectedTrajectory;\n}\n\n/**\n * Get direction vector\n * Code originally developed for REP\n * @param {[]} path\n * @param {number} threshold\n * @returns {Vector2}\n */\nfunction getDirectionVector(path: number[][], threshold: number): Vector2 {\n  const res: Vector2 = Vector2.zero.mutable;\n  let len = 0;\n  const temp: Vector2 = Vector2.zero.mutable;\n\n  for (let i = 0; i < path.length - 1; i++) {\n    const index = path.length - 1 - i;\n    temp.set(path[index]).sub(path[index - 1]);\n    res.add(temp);\n\n    len = res.magnitude;\n    if (len > threshold) {\n      break;\n    }\n  }\n\n  if (len === 0) {\n    return new Vector2([0, 0]);\n  }\n  return res.scale(1 / len);\n}\n\n/**\n * Simplify array\n *\n * Simplifies an array using given parameters.\n * Code originally developed for REP\n * @access public\n *\n * @param {Number[]}      inputArr           Array to simplify\n * @param {Number}        [maxOffset=0.001]  Max offset (Default = 0.001)\n * @param {Number}        [maxDistance=10]   Max distance (Default = 10)\n *\n * @return {Number[]}    Simplified array\n */\nfunction simplify(inputArr: number[][], maxOffset = 0.001, maxDistance = 10): number[][] {\n  if (inputArr.length <= 4) {\n    return inputArr;\n  }\n  const [o0, o1] = inputArr[0];\n  const arr = inputArr.map((d) => [d[0] - o0, d[1] - o1]);\n  let [a0, a1] = arr[0];\n  const sim: number[][] = [inputArr[0]];\n\n  for (let i = 1; i + 1 < arr.length; i++) {\n    const [t0, t1] = arr[i];\n    const [b0, b1] = arr[i + 1];\n\n    // If t->b vector is NOT [0, 0]\n    if (b0 - t0 !== 0 || b1 - t1 !== 0) {\n      // Proximity check\n      const proximity: number = Math.abs(a0 * b1 - a1 * b0 + b0 * t1 - b1 * t0 + a1 * t0 - a0 * t1) / Math.sqrt((b0 - a0) ** 2 + (b1 - a1) ** 2);\n\n      const dir: number[] = [a0 - t0, a1 - t1];\n      const len: number = Math.sqrt(dir[0] ** 2 + dir[1] ** 2);\n\n      if (proximity > maxOffset || len >= maxDistance) {\n        sim.push([t0 + o0, t1 + o1]);\n        [a0, a1] = [t0, t1];\n      }\n    }\n  }\n  const last: number[] = arr[arr.length - 1];\n  sim.push([last[0] + o0, last[1] + o1]);\n\n  return sim;\n}\n\n/**\n * Perform a curtain projection on a set of points in 3D\n * @param points\n * @param origin\n * @param offset\n * @returns {array}\n */\nfunction projectCurtain(points: number[][], origin: number[] = null, offset = 0): number[][] {\n  let p0: number[] = origin || points[0];\n  let l = 0;\n  const projected = points.map((p1: number[]) => {\n    const dx = p1[0] - p0[0];\n    const dy = p1[1] - p0[1];\n    l += Math.sqrt(dx ** 2 + dy ** 2);\n    p0 = p1;\n    return [offset > 0 ? offset - l : l, p1[2] || 0];\n  });\n  return projected;\n}\n"],"names":["stepSize","extensionLength","thresholdRelativeDist","thresholdDirectionDist","pathSteps","generateProjectedTrajectory","poslog","defaultIntersectionAngle","points","p","interpolator","CurveInterpolator","displacement","nPoints","path","simplify","first","last","relativeDist","Vector2","v","radCurtainDirection","getDirectionVector","extensionLengthStart","offset","trajectory","firstPoints","initial","seqI","t","endPoints","projectCurtain","threshold","res","len","temp","i","index","inputArr","maxOffset","maxDistance","o0","o1","arr","d","a0","a1","sim","t0","t1","b0","b1","proximity","dir","origin","p0","l","p1","dx","dy"],"mappings":"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"}