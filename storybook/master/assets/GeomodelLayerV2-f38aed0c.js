import{C as K,j as E,k as $,h as Q,l as tt,G as k}from"./elements-9b1e449a.js";import{f as y}from"./findsample-f4fa7ca8.js";const et=18,st=8,nt=13,it="black",ot="Arial",at=70;class ct extends K{constructor(t,e){super(t,e),this.defaultMargins=et,this.defaultMinFontSize=st,this.defaultMaxFontSize=nt,this.defaultTextColor=it,this.defaultFont=ot,this.isLabelsOnLeftSide=!0,this.maxFontSizeInWorldCoordinates=at,this.isXFlipped=!1,this.areasWithAvgTopDepth=null,this.drawAreaLabel=(n,s,o,a)=>{const{data:i}=n,{ctx:r,maxFontSizeInWorldCoordinates:d,isXFlipped:l}=this,{xScale:c,yScale:h,xRatio:x,yRatio:u,zFactor:p}=this.rescaleEvent;let g=this.checkDrawLabelsOnLeftSide();const F=(this.options.margins||this.defaultMargins)*(l?-1:1)/x,v=this.options.minFontSize||this.defaultMinFontSize;let f=(this.options.maxFontSize||this.defaultMaxFontSize)/u;f>d&&(f=d,f*u<v&&(f=v/u));const D=c.invert(c.range()[0])+F,m=c.invert(c.range()[1])-F,[S,A]=this.getSurfacesAreaEdges();r.save(),r.font=`${f*u}px ${this.options.font||this.defaultFont}`;let L=r.measureText(n.label),M=L.width/x;if(g){const b=D+(l?-M:M);(!l&&b>A||l&&b<A)&&(g=!1)}else{const b=m+(l?M:-M);(!l&&b<S||l&&b>S)&&(g=!0)}let I;const R=.07;g?I=l?Math.min(S,D):Math.max(S,D):I=l?Math.max(A,m):Math.min(A,m);const O=h.invert(h.range()[0]),P=h.invert(h.range()[1]),_=5,z=3,Y=R*(M/z)*(g?1:-1)*(l?-1:1),G=M/_*(g?1:-1)*(l?-1:1),U=i.map(b=>[b[0],b[1]]),W=this.calcPos(U,I,z,Y,O,P);if(!W)return;const N=i.map(b=>[b[0],b[2]]);let w=this.calcPos(N,I,z,Y,O,P,s?s.data.map(b=>[b[0],b[1]]):null,o,a);w||(w=new E(W.x,P));const X=w.y-W.y;if(X<f){if(X*u<v)return;f=X,r.font=`${f*u}px ${this.options.font||this.defaultFont}`,L=r.measureText(n.label),M=L.width/x}const Z=g!==l?E.right:E.left,j=this.calcAreaDir(U,N,I,_,G,Z,O,P,0,Math.PI/4,4,s?s.data.map(b=>[b[0],b[1]]):null,o,a),V=Math.atan(Math.tan(j)*p),q=I,H=(W.y+w.y)/2,J=l?-V:V;r.textAlign=g?"left":"right",r.translate(c(q),h(H)),r.rotate(J),r.fillStyle=this.options.textColor||this.defaultTextColor,r.font=`${f*u}px ${this.options.font||this.defaultFont}`,r.textBaseline="middle",r.fillText(n.label,0,0),r.restore()},this.drawLineLabel=n=>{const{ctx:s,isXFlipped:o}=this,{xScale:a,yScale:i,xRatio:r,yRatio:d,zFactor:l}=this.rescaleEvent,c=this.checkDrawLabelsOnLeftSide(),h=this.getMarginsInWorldCoordinates(),u=(this.options.maxFontSize||this.defaultMaxFontSize)/d;s.save(),s.font=`${u*d}px ${this.options.font||this.defaultFont}`;const g=s.measureText(n.label).width/r,C=a.invert(a.range()[0])+h,F=a.invert(a.range()[1])-h,[v,T]=this.getSurfacesAreaEdges();let f;const D=5;c?f=o?Math.max(T,F):Math.min(T,F):f=o?Math.min(v,C):Math.max(v,C);const m=g/D*(c?-1:1),{data:S}=n,A=this.calcPos(S,f,D,m),L=this.calcLineDir(S,f,D,m,l,c?E.left:E.right);if(!A||!L)return;const M=f,I=A.y-$-u/2,R=E.angleRight(L)-(c?Math.PI:0);s.textAlign=c?"right":"left",s.translate(a(M),i(I)),s.rotate(R),s.fillStyle=this.colorToCSSColor(n.color),s.textBaseline="middle",s.fillText(n.label,0,0),s.restore()},this.render=this.render.bind(this),this.getMarginsInWorldCoordinates=this.getMarginsInWorldCoordinates.bind(this),this.getSurfacesAreaEdges=this.getSurfacesAreaEdges.bind(this),this.updateXFlipped=this.updateXFlipped.bind(this),this.generateSurfacesWithAvgDepth=this.generateSurfacesWithAvgDepth.bind(this)}get options(){return this._options}setData(t){super.setData(t),this.areasWithAvgTopDepth=null}generateSurfacesWithAvgDepth(){const{areas:t}=this.data;this.areasWithAvgTopDepth=t.reduce((e,n)=>{if(!n.label)return e;const s=n.data.reduce((a,i)=>(i[1]!=null&&(a.sum+=i[1],a.count++),a),{sum:0,count:0});if(s.count===0)return e;const o=s.sum/s.count;return e.push({...n,avgTopDepth:o}),e},[])}onMount(t){super.onMount(t)}onUpdate(t){super.onUpdate(t),this.render()}onRescale(t){this.rescaleEvent=t,this.updateXFlipped(),this.resetTransform(),this.render()}render(){this.rescaleEvent&&requestAnimationFrame(()=>{this.clearCanvas(),this.data&&(this.areasWithAvgTopDepth||this.generateSurfacesWithAvgDepth(),this.drawAreaLabels(),this.drawLineLabels())})}drawAreaLabels(){this.areasWithAvgTopDepth.forEach((t,e,n)=>{const s=n.reduce((o,a,i)=>(i>e&&(o==null||a.avgTopDepth<o.avgTopDepth)&&(o=a),o),null);this.drawAreaLabel(t,s,n,e)})}drawLineLabels(){this.data.lines.filter(t=>t.label).forEach(t=>this.drawLineLabel(t))}colorToCSSColor(t){if(typeof t=="string")return t;let e=t.toString(16);return e="000000".substr(0,6-e.length)+e,`#${e}`}calcPos(t,e,n,s,o=null,a=null,i=null,r=null,d=null){const l=E.zero.mutable;let c=0;for(let h=0;h<n;h++){const x=e+h*s,u=y(t,x,o,a);if(u){const p=this.getAlternativeYValueIfAvailable(x,o,a,i,r,d),g=p?Math.min(u,p):u;l.add(x,g),c++}}return c===0?null:E.divide(l,c)}getAlternativeYValueIfAvailable(t,e,n,s,o,a){if(!s)return null;let i=y(s,t,e,n);if(i==null&&o&&a!=null){let r=a+1;for(;i==null&&r<o.length;){const d=o[r++];i=y(d.data.map(l=>[l[0],l[1]]),t,e,n)}}return i}calcLineDir(t,e,n,s,o,a=E.left,i=null,r=null){const d=a.mutable,l=y(t,e,i,r);if(l===null)return d;const c=new E(e,l*o),h=E.zero.mutable;for(let x=1;x<=n;x++){const u=e+x*s,p=y(t,e,i,r);p!==null&&(h.set(u,p*o),h.sub(c),d.add(h))}return d}calcAreaDir(t,e,n,s,o,a=E.left,i=null,r=null,d=0,l=Math.PI/4,c=4,h=null,x=null,u=null){const p=[],g=E.zero.mutable;let C;for(let m=0;m<=s;m++){const S=n+m*o,A=y(t,S,i,r),L=y(e,S,i,r)||r,M=this.getAlternativeYValueIfAvailable(S,i,r,h,x,u),I=M?Math.min(L,M):L;if(m===0){if(A===null)return E.angleRight(a);const R=(A+I)/2;C=new E(n,R)}else A!==null?(g.set(S,(A+I)/2),g.sub(C),p.push(E.angleRight(g))):p.push(E.angleRight(a))}const F=p[0],v=p.map(m=>m-F);let T=0;return v.reduce((m,S)=>{const A=(Math.abs(S)-d)/l,L=Math.pow(1-Q(A,0,1),c);return T+=L,m+S*L},0)/T+F}updateXFlipped(){const{xBounds:t}=this.rescaleEvent;this.isXFlipped=t[0]>t[1]}getMarginsInWorldCoordinates(){const{xRatio:t}=this.rescaleEvent;return(this.options.margins||this.defaultMargins)*(this.isXFlipped?-1:1)/t}getSurfacesAreaEdges(){const t=this.data.areas.reduce((r,d)=>{const{data:l}=d,c=l.find(h=>h[1]!=null);c&&r.push(c[0]);for(let h=l.length-1;h>=0;h--)if(l[h][1]!=null){r.push(l[h][0]);break}return r},[]);t.push(...this.data.lines.reduce((r,d)=>{const{data:l}=d,c=l.find(h=>h[1]!=null);c&&r.push(c[0]);for(let h=l.length-1;h>=0;h--)if(l[h][1]!=null){r.push(l[h][0]);break}return r},[]));const e=Math.min(...t),n=Math.max(...t),s=this.getMarginsInWorldCoordinates(),{isXFlipped:o}=this,a=o?n+s:e+s,i=o?e-s:n-s;return[a,i]}checkDrawLabelsOnLeftSide(){const{referenceSystem:t,isXFlipped:e}=this;if(!t)return!0;const{xScale:n,yScale:s,xRatio:o}=this.rescaleEvent,a=200,[i,r]=n.domain(),[d,l]=s.domain();let c=t.interpolators.curtain.getIntersects(d,1,0);c.length===0&&(c=[t.interpolators.curtain.getPointAt(0)]);let h=t.interpolators.curtain.getIntersects(l,1,0);h.length===0&&(h=[t.interpolators.curtain.getPointAt(1)]);const x=Math.max(c[0][0],h[0][0]),u=Math.min(c[0][0],h[0][0]),p={left:e?x:u,right:e?u:x},g=this.getMarginsInWorldCoordinates(),C=i+g,F=r-g,[v,T]=this.getSurfacesAreaEdges(),f=e?Math.min(C,v):Math.max(C,v),D=e?Math.max(F,T):Math.min(F,T),m=Math.max(e?f-p.left:p.left-f,0),S=Math.max(e?p.right-D:D-p.right,0),A=m*o,L=S*o;return m>S||A>a||A<a&&L<a&&e||h[0][1]<d}}const rt=1e4;class dt extends tt{constructor(){super(...arguments),this.isPreRendered=!1,this.createPolygons=t=>{const e=[];let n=null;for(let s=0;s<t.length;s++){const o=!!t[s][1];o&&(n===null&&(n=[]),n.push(t[s][0],t[s][1]));const a=s===t.length-1;if((!o||a)&&n){for(let i=o?s:s-1;i>=0&&t[i][1];i--)n.push(t[i][0],t[i][2]||rt);e.push(n),n=null}}return e},this.generateAreaPolygon=t=>{const e=new k;e.lineStyle(1,t.color,1),e.beginFill(t.color),this.createPolygons(t.data).forEach(s=>e.drawPolygon(s)),e.endFill(),this.addChild(e)},this.generateSurfaceLine=t=>{const e=new k,{data:n}=t,s=.5;e.lineStyle($,t.color,1,s,!0);let o=!1;for(let a=0;a<n.length;a++){const i=n[a];i&&i[1]&&i[0]?o?e.lineTo(i[0],i[1]):(e.moveTo(i[0],i[1]),o=!0):o=!1}this.addChild(e)}}onRescale(t){super.onRescale(t),this.isPreRendered||(this.clearLayer(),this.preRender()),this.render()}onUpdate(t){super.onUpdate(t),this.isPreRendered=!1,this.clearLayer(),this.preRender(),this.render()}preRender(){const{data:t}=this;t&&(t.areas.forEach(e=>this.generateAreaPolygon(e)),t.lines.forEach(e=>this.generateSurfaceLine(e)),this.isPreRendered=!0)}}export{dt as G,ct as a};
//# sourceMappingURL=GeomodelLayerV2-f38aed0c.js.map
