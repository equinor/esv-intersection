{"version":3,"file":"SchematicLayer.c4e748ce.js","sources":["../../../../node_modules/d3-array/src/max.js","../../../../node_modules/d3-array/src/sum.js","../../../../node_modules/@pixi/mesh-extras/lib/geometry/RopeGeometry.mjs","../../../../node_modules/@pixi/mesh-extras/lib/SimpleRope.mjs","../../../../src/layers/schematicInterfaces.ts","../../../../src/vendor/pixi-dashed-line/index.ts","../../../../src/utils/vectorUtils.ts","../../../../src/datautils/schematicShapeGenerator.ts","../../../../src/layers/CustomDisplayObjects/ComplexRopeGeometry.ts","../../../../src/layers/CustomDisplayObjects/ComplexRope.ts","../../../../src/layers/CustomDisplayObjects/FixedWidthSimpleRopeGeometry.ts","../../../../src/layers/CustomDisplayObjects/FixedWidthSimpleRope.ts","../../../../src/layers/CustomDisplayObjects/UniformTextureStretchRopeGeometry.ts","../../../../src/layers/CustomDisplayObjects/UniformTextureStretchRope.ts","../../../../src/layers/SchematicLayer.ts"],"sourcesContent":["export default function max(values, valueof) {\n  let max;\n  if (valueof === undefined) {\n    for (const value of values) {\n      if (value != null\n          && (max < value || (max === undefined && value >= value))) {\n        max = value;\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if ((value = valueof(value, ++index, values)) != null\n          && (max < value || (max === undefined && value >= value))) {\n        max = value;\n      }\n    }\n  }\n  return max;\n}\n","export default function sum(values, valueof) {\n  let sum = 0;\n  if (valueof === undefined) {\n    for (let value of values) {\n      if (value = +value) {\n        sum += value;\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if (value = +valueof(value, ++index, values)) {\n        sum += value;\n      }\n    }\n  }\n  return sum;\n}\n","import { MeshGeometry } from '@pixi/mesh';\n\nclass RopeGeometry extends MeshGeometry {\n  constructor(width = 200, points, textureScale = 0) {\n    super(new Float32Array(points.length * 4), new Float32Array(points.length * 4), new Uint16Array((points.length - 1) * 6));\n    this.points = points;\n    this._width = width;\n    this.textureScale = textureScale;\n    this.build();\n  }\n  get width() {\n    return this._width;\n  }\n  build() {\n    const points = this.points;\n    if (!points)\n      return;\n    const vertexBuffer = this.getBuffer(\"aVertexPosition\");\n    const uvBuffer = this.getBuffer(\"aTextureCoord\");\n    const indexBuffer = this.getIndex();\n    if (points.length < 1) {\n      return;\n    }\n    if (vertexBuffer.data.length / 4 !== points.length) {\n      vertexBuffer.data = new Float32Array(points.length * 4);\n      uvBuffer.data = new Float32Array(points.length * 4);\n      indexBuffer.data = new Uint16Array((points.length - 1) * 6);\n    }\n    const uvs = uvBuffer.data;\n    const indices = indexBuffer.data;\n    uvs[0] = 0;\n    uvs[1] = 0;\n    uvs[2] = 0;\n    uvs[3] = 1;\n    let amount = 0;\n    let prev = points[0];\n    const textureWidth = this._width * this.textureScale;\n    const total = points.length;\n    for (let i = 0; i < total; i++) {\n      const index = i * 4;\n      if (this.textureScale > 0) {\n        const dx = prev.x - points[i].x;\n        const dy = prev.y - points[i].y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n        prev = points[i];\n        amount += distance / textureWidth;\n      } else {\n        amount = i / (total - 1);\n      }\n      uvs[index] = amount;\n      uvs[index + 1] = 0;\n      uvs[index + 2] = amount;\n      uvs[index + 3] = 1;\n    }\n    let indexCount = 0;\n    for (let i = 0; i < total - 1; i++) {\n      const index = i * 2;\n      indices[indexCount++] = index;\n      indices[indexCount++] = index + 1;\n      indices[indexCount++] = index + 2;\n      indices[indexCount++] = index + 2;\n      indices[indexCount++] = index + 1;\n      indices[indexCount++] = index + 3;\n    }\n    uvBuffer.update();\n    indexBuffer.update();\n    this.updateVertices();\n  }\n  updateVertices() {\n    const points = this.points;\n    if (points.length < 1) {\n      return;\n    }\n    let lastPoint = points[0];\n    let nextPoint;\n    let perpX = 0;\n    let perpY = 0;\n    const vertices = this.buffers[0].data;\n    const total = points.length;\n    for (let i = 0; i < total; i++) {\n      const point = points[i];\n      const index = i * 4;\n      if (i < points.length - 1) {\n        nextPoint = points[i + 1];\n      } else {\n        nextPoint = point;\n      }\n      perpY = -(nextPoint.x - lastPoint.x);\n      perpX = nextPoint.y - lastPoint.y;\n      let ratio = (1 - i / (total - 1)) * 10;\n      if (ratio > 1) {\n        ratio = 1;\n      }\n      const perpLength = Math.sqrt(perpX * perpX + perpY * perpY);\n      const num = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;\n      perpX /= perpLength;\n      perpY /= perpLength;\n      perpX *= num;\n      perpY *= num;\n      vertices[index] = point.x + perpX;\n      vertices[index + 1] = point.y + perpY;\n      vertices[index + 2] = point.x - perpX;\n      vertices[index + 3] = point.y - perpY;\n      lastPoint = point;\n    }\n    this.buffers[0].update();\n  }\n  update() {\n    if (this.textureScale > 0) {\n      this.build();\n    } else {\n      this.updateVertices();\n    }\n  }\n}\n\nexport { RopeGeometry };\n//# sourceMappingURL=RopeGeometry.mjs.map\n","import { Mesh, MeshMaterial } from '@pixi/mesh';\nimport { WRAP_MODES } from '@pixi/core';\nimport { RopeGeometry } from './geometry/RopeGeometry.mjs';\n\nclass SimpleRope extends Mesh {\n  constructor(texture, points, textureScale = 0) {\n    const ropeGeometry = new RopeGeometry(texture.height, points, textureScale);\n    const meshMaterial = new MeshMaterial(texture);\n    if (textureScale > 0) {\n      texture.baseTexture.wrapMode = WRAP_MODES.REPEAT;\n    }\n    super(ropeGeometry, meshMaterial);\n    this.autoUpdate = true;\n  }\n  _render(renderer) {\n    const geometry = this.geometry;\n    if (this.autoUpdate || geometry._width !== this.shader.texture.height) {\n      geometry._width = this.shader.texture.height;\n      geometry.update();\n    }\n    super._render(renderer);\n  }\n}\n\nexport { SimpleRope };\n//# sourceMappingURL=SimpleRope.mjs.map\n","import { SHOE_LENGTH, SHOE_WIDTH } from '../constants';\n\nexport function assertNever(x: never): never {\n  throw new Error(`Unexpected object: ${JSON.stringify(x)}`);\n}\n\n/**\n * The closure type of the outline\n */\nexport type OutlineClosure = 'None' | 'TopAndBottom' | 'Top' | 'Bottom';\n\nexport interface HoleSize {\n  kind: 'hole';\n  id: string;\n  diameter: number;\n  start: number;\n  end: number;\n}\n\nexport interface CasingWindow {\n  id: string;\n  start: number;\n  end: number;\n}\n\nexport interface Casing {\n  kind: 'casing';\n  id: string;\n  diameter: number;\n  start: number;\n  end: number;\n  hasShoe: boolean;\n  innerDiameter: number;\n  windows?: CasingWindow[];\n}\n\ninterface SymbolComponent {\n  id: string;\n  diameter: number;\n  start: number;\n  end: number;\n  symbolKey: string;\n}\n\nexport interface PAndASymbol extends SymbolComponent {\n  kind: 'pAndASymbol';\n}\n\nexport const isPAndASymbol = (item: PAndA): item is PAndASymbol => item.kind === 'pAndASymbol';\n\nexport interface CementSqueeze {\n  kind: 'cementSqueeze';\n  id: string;\n  start: number;\n  end: number;\n  /**\n   * Referenced Casing and Completion ids\n   */\n  referenceIds: string[];\n}\n\nexport const isCementSqueeze = (item: PAndA): item is CementSqueeze => item.kind === 'cementSqueeze';\n\nexport interface CementPlug {\n  kind: 'cementPlug';\n  id: string;\n  start: number;\n  end: number;\n  /**\n   * Referenced Casing, Completion ids\n   */\n  referenceIds: string[];\n}\n\nexport const isCementPlug = (item: PAndA): item is CementSqueeze => item.kind === 'cementPlug';\n\nexport type PAndA = PAndASymbol | CementSqueeze | CementPlug;\n\ninterface BaseCompletion {\n  id: string;\n  diameter: number;\n  start: number;\n  end: number;\n}\n\nexport interface Screen extends BaseCompletion {\n  kind: 'screen';\n}\nexport interface Tubing extends BaseCompletion {\n  kind: 'tubing';\n}\n\nexport interface CompletionSymbol extends BaseCompletion {\n  kind: 'completionSymbol';\n  symbolKey: string;\n}\n\nexport type Completion = Tubing | Screen | CompletionSymbol;\n\nexport const foldCompletion =\n  <T>(fScreen: (obj: Screen) => T, fTubing: (obj: Tubing) => T, fSymbol: (obj: CompletionSymbol) => T) =>\n  (completion: Completion): T => {\n    switch (completion.kind) {\n      case 'screen':\n        return fScreen(completion);\n      case 'tubing':\n        return fTubing(completion);\n      case 'completionSymbol':\n        return fSymbol(completion);\n      default:\n        return assertNever(completion);\n    }\n  };\n\nexport interface Cement {\n  kind: 'cement';\n  id: string;\n  /**\n   *  Referenced Casing and Completion ids\n   */\n  referenceIds: string[];\n  toc: number;\n}\n\n/**\n * 'Open hole' and 'Open hole screen' are not included as they are not visualized and also not included in the ruleset\n */\nexport type PerforationSubKind =\n  | 'Perforation'\n  | 'Open hole gravel pack'\n  | 'Open hole frac pack'\n  | 'Cased hole frac pack'\n  | 'Cased hole gravel pack'\n  | 'Cased hole fracturation';\n\nexport interface Perforation {\n  kind: 'perforation';\n  subKind: PerforationSubKind;\n  id: string;\n  start: number;\n  end: number;\n  /**\n   * is the perforation open or sealed?\n   */\n  isOpen: boolean;\n}\n\nexport const foldPerforationSubKind = <T>(\n  options: {\n    Perforation: (kind: 'Perforation') => T;\n    OpenHoleGravelPack: (kind: 'Open hole gravel pack') => T;\n    OpenHoleFracPack: (kind: 'Open hole frac pack') => T;\n    CasedHoleGravelPack: (kind: 'Cased hole gravel pack') => T;\n    CasedHoleFracPack: (kind: 'Cased hole frac pack') => T;\n    CasedHoleFracturation: (kind: 'Cased hole fracturation') => T;\n  },\n  subKind: PerforationSubKind,\n) => {\n  switch (subKind) {\n    case 'Perforation':\n      return options.Perforation(subKind);\n\n    case 'Open hole gravel pack':\n      return options.OpenHoleGravelPack(subKind);\n\n    case 'Open hole frac pack':\n      return options.OpenHoleFracPack(subKind);\n\n    case 'Cased hole fracturation':\n      return options.CasedHoleFracturation(subKind);\n\n    case 'Cased hole frac pack':\n      return options.CasedHoleFracPack(subKind);\n\n    case 'Cased hole gravel pack':\n      return options.CasedHoleGravelPack(subKind);\n\n    default:\n      return assertNever(subKind);\n  }\n};\n\nexport const shouldPerforationStartAtHoleDiameter = (perf: Perforation) =>\n  foldPerforationSubKind(\n    {\n      Perforation: () => true,\n      OpenHoleGravelPack: () => true,\n      OpenHoleFracPack: () => false,\n      CasedHoleFracturation: () => false,\n      CasedHoleGravelPack: () => false,\n      CasedHoleFracPack: () => false,\n    },\n    perf.subKind,\n  );\n\nexport const shouldPerforationStartAtCasingDiameter = (perf: Perforation) =>\n  foldPerforationSubKind(\n    {\n      Perforation: () => false,\n      OpenHoleGravelPack: () => false,\n      OpenHoleFracPack: () => true,\n      CasedHoleFracturation: () => true,\n      CasedHoleGravelPack: () => true,\n      CasedHoleFracPack: () => true,\n    },\n    perf.subKind,\n  );\n\nexport const hasPacking = (perf: Perforation): boolean =>\n  foldPerforationSubKind(\n    {\n      Perforation: () => false,\n      OpenHoleGravelPack: () => true,\n      OpenHoleFracPack: () => true,\n      CasedHoleFracturation: () => false,\n      CasedHoleGravelPack: () => true,\n      CasedHoleFracPack: () => true,\n    },\n    perf.subKind,\n  );\n\nexport function hasFracLines(perf: Perforation): boolean {\n  return foldPerforationSubKind(\n    {\n      Perforation: () => false,\n      OpenHoleGravelPack: () => false,\n      OpenHoleFracPack: () => true,\n      CasedHoleFracturation: () => true,\n      CasedHoleGravelPack: () => false,\n      CasedHoleFracPack: () => true,\n    },\n    perf.subKind,\n  );\n}\n\nexport function hasSpikes(perf: Perforation): boolean {\n  return foldPerforationSubKind(\n    {\n      Perforation: () => true,\n      OpenHoleGravelPack: () => false,\n      OpenHoleFracPack: () => false,\n      CasedHoleFracturation: () => false,\n      CasedHoleGravelPack: () => false,\n      CasedHoleFracPack: () => false,\n    },\n    perf.subKind,\n  );\n}\n\nexport function isSubkindCasedHoleGravelPack(perf: Perforation): boolean {\n  return foldPerforationSubKind(\n    {\n      Perforation: () => false,\n      OpenHoleGravelPack: () => false,\n      OpenHoleFracPack: () => false,\n      CasedHoleFracturation: () => false,\n      CasedHoleGravelPack: () => true,\n      CasedHoleFracPack: () => false,\n    },\n    perf.subKind,\n  );\n}\n\nexport function isSubKindPerforation(perf: Perforation): boolean {\n  return foldPerforationSubKind(\n    {\n      Perforation: () => true,\n      OpenHoleGravelPack: () => false,\n      OpenHoleFracPack: () => false,\n      CasedHoleFracturation: () => false,\n      CasedHoleGravelPack: () => false,\n      CasedHoleFracPack: () => false,\n    },\n    perf.subKind,\n  );\n}\n\nexport function isSubKindCasedHoleFracPack(perf: Perforation): boolean {\n  return foldPerforationSubKind(\n    {\n      Perforation: () => false,\n      OpenHoleGravelPack: () => false,\n      OpenHoleFracPack: () => false,\n      CasedHoleFracturation: () => false,\n      CasedHoleGravelPack: () => false,\n      CasedHoleFracPack: () => true,\n    },\n    perf.subKind,\n  );\n}\n\nexport function isOpenHoleFracPack(perf: Perforation) {\n  return foldPerforationSubKind(\n    {\n      Perforation: () => false,\n      OpenHoleGravelPack: () => false,\n      OpenHoleFracPack: () => true,\n      CasedHoleFracturation: () => false,\n      CasedHoleGravelPack: () => false,\n      CasedHoleFracPack: () => false,\n    },\n    perf.subKind,\n  );\n}\n\nexport const intersect = (a: Perforation, b: Perforation): boolean => {\n  return a.start < b.end && a.end > b.start;\n};\n\nexport interface SchematicData {\n  holeSizes: HoleSize[];\n  casings: Casing[];\n  cements: Cement[];\n  completion: Completion[];\n  pAndA: PAndA[];\n  symbols: {\n    [key: string]: string;\n  };\n  perforations: Perforation[];\n}\n\nexport interface InternalLayerOptions {\n  holeLayerId: string;\n  casingLayerId: string;\n  completionLayerId: string;\n  cementLayerId: string;\n  pAndALayerId: string;\n  perforationLayerId: string;\n}\n\nexport const defaultInternalLayerOptions = (layerId: string): InternalLayerOptions => ({\n  holeLayerId: `${layerId}-hole`,\n  casingLayerId: `${layerId}-casing`,\n  completionLayerId: `${layerId}-completion`,\n  cementLayerId: `${layerId}-cement`,\n  pAndALayerId: `${layerId}-pAndA`,\n  perforationLayerId: `${layerId}-perforation`,\n});\n\nexport interface HoleOptions {\n  firstColor: string;\n  secondColor: string;\n  lineColor: string;\n}\n\nexport const defaultHoleOptions: HoleOptions = {\n  firstColor: '#8c541d',\n  secondColor: '#eee3d8',\n  lineColor: '#8b4513',\n};\n\nexport interface CasingShoeSize {\n  width: number;\n  length: number;\n}\n\nexport interface WindowOptions {\n  dashColor: string;\n  dashLength: number;\n  spaceLength: number;\n}\n\nexport interface CasingOptions {\n  solidColor: string;\n  lineColor: string;\n  shoeSize: CasingShoeSize;\n  windowOptions: WindowOptions;\n}\n\nexport const defaultCasingOptions: CasingOptions = {\n  solidColor: '#dcdcdc',\n  lineColor: '#575757',\n  shoeSize: {\n    width: SHOE_WIDTH,\n    length: SHOE_LENGTH,\n  },\n  windowOptions: {\n    dashColor: '#dc0000',\n    dashLength: 5,\n    spaceLength: 3,\n  },\n};\n\nexport interface PerforationOptions {\n  stroke: string;\n  yellow: string;\n  grey: string;\n  red: string;\n  outline: string;\n  transparent: string;\n  spikeWidth: number;\n  spikeLength: number;\n  packingOpacity: number;\n  fracLineLength: number;\n  fracLineCurve: number;\n  scalingFactor: number;\n}\n\nexport const defaultPerforationOptions: PerforationOptions = {\n  stroke: 'rgba(0, 0, 0, 0.25)',\n  yellow: '#FFFC00',\n  grey: 'gray',\n  red: '#FF5050',\n  outline: 'black',\n  transparent: 'rgba(255, 255, 255, 0)',\n  spikeWidth: 50,\n  spikeLength: 50,\n  packingOpacity: 0.5,\n  fracLineCurve: 10,\n  fracLineLength: 25,\n  scalingFactor: 25,\n};\n\nexport interface CementOptions {\n  firstColor: string;\n  secondColor: string;\n  scalingFactor: number;\n}\n\nexport const defaultCementOptions: CementOptions = {\n  firstColor: '#c7b9ab',\n  secondColor: '#5b5b5b',\n  scalingFactor: 4,\n};\n\nexport interface CementSqueezeOptions {\n  firstColor: string;\n  secondColor: string;\n  scalingFactor: number;\n}\n\nexport const defaultCementSqueezeOptions: CementSqueezeOptions = {\n  firstColor: '#8b6713',\n  secondColor: '#000000',\n  scalingFactor: 4,\n};\n\nexport interface ScreenOptions {\n  scalingFactor: number;\n  lineColor: string;\n}\n\nexport const defaultScreenOptions: ScreenOptions = {\n  scalingFactor: 4,\n  lineColor: '#63666a',\n};\n\nexport interface TubingOptions {\n  innerColor: string;\n  outerColor: string;\n  scalingFactor: number;\n}\n\nexport const defaultTubingOptions: TubingOptions = {\n  scalingFactor: 1,\n  innerColor: '#eeeeff',\n  outerColor: '#777788',\n};\n\nexport interface CementPlugOptions {\n  firstColor: string;\n  secondColor: string;\n  scalingFactor: number;\n}\n\nexport const defaultCementPlugOptions: CementPlugOptions = {\n  firstColor: '#c7b9ab',\n  secondColor: '#000000',\n  scalingFactor: 4,\n};\n","// https://github.com/davidfig/pixi-dashed-line\n//\n// Copyright 2021 David Figatner\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n// and associated documentation files (the \"Software\"), to deal in the Software without restriction,\n// including without limitation the rights to use, copy, modify, merge, publish, distribute,\n// sublicense, and/or sell copies of the Software, and to permit persons to whom the Software\n// is furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all copies or\n// substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING\n// BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nimport * as PIXI from 'pixi.js';\n\n/** Define the dash: [dash length, gap size, dash size, gap size, ...] */\nexport type Dashes = number[];\n\nexport interface DashLineOptions {\n  dash?: Dashes;\n  width?: number;\n  color?: number;\n  alpha?: number;\n  scale?: number;\n  useTexture?: boolean;\n  useDots?: boolean;\n  cap?: PIXI.LINE_CAP;\n  join?: PIXI.LINE_JOIN;\n  alignment?: number;\n}\n\nconst dashLineOptionsDefault: Partial<DashLineOptions> = {\n  dash: [10, 5], // eslint-disable-line no-magic-numbers\n  width: 1,\n  color: 0xffffff,\n  alpha: 1,\n  scale: 1,\n  useTexture: false,\n  alignment: 0.5,\n};\n\nexport class DashLine {\n  graphics: PIXI.Graphics;\n\n  /** current length of the line */\n  lineLength: number;\n\n  /** cursor location */\n  cursor = new PIXI.Point();\n\n  /** desired scale of line */\n  scale = 1;\n\n  // sanity check to ensure the lineStyle is still in use\n  private activeTexture: PIXI.Texture;\n\n  private start: PIXI.Point;\n\n  private dashSize: number;\n  private dash: number[];\n\n  private useTexture: boolean;\n  private options: DashLineOptions;\n\n  // cache of PIXI.Textures for dashed lines\n  static dashTextureCache: Record<string, PIXI.Texture> = {};\n\n  /**\n   * Create a DashLine\n   * @param graphics\n   * @param [options]\n   * @param [options.useTexture=false] - use the texture based render (useful for very large or very small dashed lines)\n   * @param [options.dashes=[10,5] - an array holding the dash and gap (eg, [10, 5, 20, 5, ...])\n   * @param [options.width=1] - width of the dashed line\n   * @param [options.alpha=1] - alpha of the dashed line\n   * @param [options.color=0xffffff] - color of the dashed line\n   * @param [options.cap] - add a PIXI.LINE_CAP style to dashed lines (only works for useTexture: false)\n   * @param [options.join] - add a PIXI.LINE_JOIN style to the dashed lines (only works for useTexture: false)\n   * @param [options.alignment] - The alignment of any lines drawn (0.5 = middle, 1 = outer, 0 = inner)\n   */\n  constructor(graphics: PIXI.Graphics, options: DashLineOptions = {}) {\n    this.graphics = graphics;\n    options = { ...dashLineOptionsDefault, ...options };\n    this.dash = options.dash;\n    this.dashSize = this.dash.reduce((a, b) => a + b);\n    this.useTexture = options.useTexture;\n    this.options = options;\n    this.setLineStyle();\n  }\n\n  /** resets line style to enable dashed line (useful if lineStyle was changed on graphics element) */\n  setLineStyle() {\n    const options = this.options;\n    if (this.useTexture) {\n      const texture = DashLine.getTexture(options, this.dashSize);\n      this.graphics.lineTextureStyle({\n        width: options.width * options.scale,\n        color: options.color,\n        alpha: options.alpha,\n        texture,\n        alignment: options.alignment,\n      });\n      this.activeTexture = texture;\n    } else {\n      this.graphics.lineStyle({\n        width: options.width * options.scale,\n        color: options.color,\n        alpha: options.alpha,\n        cap: options.cap,\n        join: options.join,\n        alignment: options.alignment,\n      });\n    }\n    this.scale = options.scale;\n  }\n\n  private static distance(x1: number, y1: number, x2: number, y2: number): number {\n    return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n  }\n\n  moveTo(x: number, y: number): this {\n    this.lineLength = 0;\n    this.cursor.set(x, y);\n    this.start = new PIXI.Point(x, y);\n    this.graphics.moveTo(this.cursor.x, this.cursor.y);\n    return this;\n  }\n\n  lineTo(x: number, y: number, closePath?: boolean): this {\n    if (typeof this.lineLength === undefined) {\n      this.moveTo(0, 0);\n    }\n    const length = DashLine.distance(this.cursor.x, this.cursor.y, x, y);\n    const angle = Math.atan2(y - this.cursor.y, x - this.cursor.x);\n    const closed = closePath && x === this.start.x && y === this.start.y;\n    if (this.useTexture) {\n      this.graphics.moveTo(this.cursor.x, this.cursor.y);\n      this.adjustLineStyle(angle);\n      if (closed && this.dash.length % 2 === 0) {\n        const gap = Math.min(this.dash[this.dash.length - 1], length);\n        this.graphics.lineTo(x - Math.cos(angle) * gap, y - Math.sin(angle) * gap);\n        this.graphics.closePath();\n      } else {\n        this.graphics.lineTo(x, y);\n      }\n    } else {\n      const cos = Math.cos(angle);\n      const sin = Math.sin(angle);\n      let x0 = this.cursor.x;\n      let y0 = this.cursor.y;\n\n      // find the first part of the dash for this line\n      const place = this.lineLength % (this.dashSize * this.scale);\n      let dashIndex: number = 0,\n        dashStart: number = 0;\n      let dashX = 0;\n      for (let i = 0; i < this.dash.length; i++) {\n        const dashSize = this.dash[i] * this.scale;\n        if (place < dashX + dashSize) {\n          dashIndex = i;\n          dashStart = place - dashX;\n          break;\n        } else {\n          dashX += dashSize;\n        }\n      }\n\n      let remaining = length;\n      // let count = 0\n      while (remaining > 0) {\n        // && count++ < 1000) {\n        const dashSize = this.dash[dashIndex] * this.scale - dashStart;\n        const dist = remaining > dashSize ? dashSize : remaining;\n        if (closed) {\n          const remainingDistance = DashLine.distance(x0 + cos * dist, y0 + sin * dist, this.start.x, this.start.y);\n          if (remainingDistance <= dist) {\n            if (dashIndex % 2 === 0) {\n              const lastDash = DashLine.distance(x0, y0, this.start.x, this.start.y) - this.dash[this.dash.length - 1] * this.scale;\n              x0 += cos * lastDash;\n              y0 += sin * lastDash;\n              this.graphics.lineTo(x0, y0);\n            }\n            break;\n          }\n        }\n\n        x0 += cos * dist;\n        y0 += sin * dist;\n        if (dashIndex % 2) {\n          this.graphics.moveTo(x0, y0);\n        } else {\n          this.graphics.lineTo(x0, y0);\n        }\n        remaining -= dist;\n\n        dashIndex++;\n        dashIndex = dashIndex === this.dash.length ? 0 : dashIndex;\n        dashStart = 0;\n      }\n      // if (count >= 1000) console.log('failure', this.scale)\n    }\n    this.lineLength += length;\n    this.cursor.set(x, y);\n    return this;\n  }\n\n  closePath() {\n    this.lineTo(this.start.x, this.start.y, true);\n  }\n\n  drawCircle(x: number, y: number, radius: number, points = 80, matrix?: PIXI.Matrix): this {\n    const interval = (Math.PI * 2) / points;\n    let angle = 0,\n      first: PIXI.Point;\n    if (matrix) {\n      first = new PIXI.Point(x + Math.cos(angle) * radius, y + Math.sin(angle) * radius);\n      matrix.apply(first, first);\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      this.moveTo(first[0], first[1]);\n    } else {\n      first = new PIXI.Point(x + Math.cos(angle) * radius, y + Math.sin(angle) * radius);\n      this.moveTo(first.x, first.y);\n    }\n    angle += interval;\n    for (let i = 1; i < points + 1; i++) {\n      const next = i === points ? first : [x + Math.cos(angle) * radius, y + Math.sin(angle) * radius];\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      this.lineTo(next[0], next[1]);\n      angle += interval;\n    }\n    return this;\n  }\n\n  drawEllipse(x: number, y: number, radiusX: number, radiusY: number, points = 80, matrix?: PIXI.Matrix): this {\n    const interval = (Math.PI * 2) / points;\n    let first: { x: number; y: number };\n    const point = new PIXI.Point();\n    for (let i = 0; i < Math.PI * 2; i += interval) {\n      let x0 = x - radiusX * Math.sin(i);\n      let y0 = y - radiusY * Math.cos(i);\n      if (matrix) {\n        point.set(x0, y0);\n        matrix.apply(point, point);\n        x0 = point.x;\n        y0 = point.y;\n      }\n      if (i === 0) {\n        this.moveTo(x0, y0);\n        first = { x: x0, y: y0 };\n      } else {\n        this.lineTo(x0, y0);\n      }\n    }\n    this.lineTo(first.x, first.y, true);\n    return this;\n  }\n\n  drawPolygon(points: PIXI.Point[] | number[], matrix?: PIXI.Matrix): this {\n    const p = new PIXI.Point();\n    if (typeof points[0] === 'number') {\n      if (matrix) {\n        p.set(points[0] as number, points[1] as number);\n        matrix.apply(p, p);\n        this.moveTo(p.x, p.y);\n        for (let i = 2; i < points.length; i += 2) {\n          p.set(points[i] as number, points[i + 1] as number);\n          matrix.apply(p, p);\n          this.lineTo(p.x, p.y, i === points.length - 2);\n        }\n      } else {\n        this.moveTo(points[0] as number, points[1] as number);\n        for (let i = 2; i < points.length; i += 2) {\n          this.lineTo(points[i] as number, points[i + 1] as number, i === points.length - 2);\n        }\n      }\n    } else {\n      if (matrix) {\n        const point = points[0] as PIXI.Point;\n        p.copyFrom(point);\n        matrix.apply(p, p);\n        this.moveTo(p.x, p.y);\n        for (let i = 1; i < points.length; i++) {\n          const point = points[i] as PIXI.Point;\n          p.copyFrom(point);\n          matrix.apply(p, p);\n          this.lineTo(p.x, p.y, i === points.length - 1);\n        }\n      } else {\n        const point = points[0] as PIXI.Point;\n        this.moveTo(point.x, point.y);\n        for (let i = 1; i < points.length; i++) {\n          const point = points[i] as PIXI.Point;\n          this.lineTo(point.x, point.y, i === points.length - 1);\n        }\n      }\n    }\n    return this;\n  }\n\n  drawRect(x: number, y: number, width: number, height: number, matrix?: PIXI.Matrix): this {\n    if (matrix) {\n      const p = new PIXI.Point();\n\n      // moveTo(x, y)\n      p.set(x, y);\n      matrix.apply(p, p);\n      this.moveTo(p.x, p.y);\n\n      // lineTo(x + width, y)\n      p.set(x + width, y);\n      matrix.apply(p, p);\n      this.lineTo(p.x, p.y);\n\n      // lineTo(x + width, y + height)\n      p.set(x + width, y + height);\n      matrix.apply(p, p);\n      this.lineTo(p.x, p.y);\n\n      // lineto(x, y + height)\n      p.set(x, y + height);\n      matrix.apply(p, p);\n      this.lineTo(p.x, p.y);\n\n      // lineTo(x, y, true)\n      p.set(x, y);\n      matrix.apply(p, p);\n      this.lineTo(p.x, p.y, true);\n    } else {\n      this.moveTo(x, y)\n        .lineTo(x + width, y)\n        .lineTo(x + width, y + height)\n        .lineTo(x, y + height)\n        .lineTo(x, y, true);\n    }\n    return this;\n  }\n\n  // adjust the matrix for the dashed texture\n  private adjustLineStyle(angle: number) {\n    const lineStyle = this.graphics.line;\n    lineStyle.matrix = new PIXI.Matrix();\n    if (angle) {\n      lineStyle.matrix.rotate(angle);\n    }\n    if (this.scale !== 1) {\n      lineStyle.matrix.scale(this.scale, this.scale);\n    }\n    const textureStart = -this.lineLength;\n    lineStyle.matrix.translate(this.cursor.x + textureStart * Math.cos(angle), this.cursor.y + textureStart * Math.sin(angle));\n    this.graphics.lineStyle(lineStyle);\n  }\n\n  // creates or uses cached texture\n  private static getTexture(options: DashLineOptions, dashSize: number): PIXI.Texture {\n    const key = options.dash.toString();\n    if (DashLine.dashTextureCache[key]) {\n      return DashLine.dashTextureCache[key];\n    }\n    const canvas = document.createElement('canvas');\n    canvas.width = dashSize;\n    canvas.height = Math.ceil(options.width);\n    const context = canvas.getContext('2d');\n    if (!context) {\n      console.warn('Did not get context from canvas');\n      return;\n    }\n    context.strokeStyle = 'white';\n    context.globalAlpha = options.alpha;\n    context.lineWidth = options.width;\n    let x = 0;\n    const y = options.width / 2;\n    context.moveTo(x, y);\n    for (let i = 0; i < options.dash.length; i += 2) {\n      x += options.dash[i];\n      context.lineTo(x, y);\n      if (options.dash.length !== i + 1) {\n        x += options.dash[i + 1];\n        context.moveTo(x, y);\n      }\n    }\n    context.stroke();\n    const texture = (DashLine.dashTextureCache[key] = PIXI.Texture.from(canvas));\n    texture.baseTexture.scaleMode = PIXI.SCALE_MODES.NEAREST;\n    return texture;\n  }\n}\n","import { IPoint, Point } from 'pixi.js';\nimport Vector2 from '@equinor/videx-vector2';\n\nexport const pointToVector = (p: IPoint): Vector2 => new Vector2(p.x, p.y);\nexport const pointToArray = (p: IPoint): [number, number] => [p.x, p.y];\nexport const vectorToPoint = (v: Vector2): Point => new Point(v[0], v[1]);\nexport const vectorToArray = (v: Vector2): [number, number] => [v[0], v[1]];\nexport const arrayToPoint = (a: number[]): Point => new Point(a[0], a[1]);\nexport const arrayToVector = (a: number[]): Vector2 => new Vector2(a[0], a[1]);\n\nexport const calcDist = (prev: [number, number], point: [number, number]): number => {\n  return arrayToVector(point).sub(prev).magnitude;\n};\n\nexport const calcDistPoint = (prev: Point, point: Point): number => {\n  return pointToVector(point).sub(prev.x, prev.y).magnitude;\n};\n\nexport const calcNormal = (p1: Point, p2: Point): Point => {\n  const d = pointToVector(p2).sub(p1.x, p1.y);\n  d.x = d.y === 0 ? 1 : d.x;\n  d.y = d.x === 0 ? 1 : d.y;\n  return vectorToPoint(d.rotate90()); //TODO: normalize\n};\n\nexport const convertToUnitVector = (p: Point): Point => {\n  return vectorToPoint(pointToVector(p).normalize());\n};\n\nexport const createNormals = (points: IPoint[]): Vector2[] => {\n  if (points.length < 2) {\n    return [new Vector2(0)];\n  }\n\n  let n: Vector2;\n\n  return points.map((_coord, i, list) => {\n    if (i < list.length - 1) {\n      const p = pointToVector(list[i]);\n      const q = pointToVector(list[i + 1]);\n      const np = q.sub(p);\n      const rotate = np.rotate90();\n      n = rotate.normalized();\n      return n;\n    }\n\n    // reuse previous normal for last coord\n    return n;\n  });\n};\n\n// TODO check if this can be simplified and return Vector/number[]\nexport const offsetPoint = (point: IPoint, vector: Vector2, offset: number): Point => {\n  const p = pointToVector(point);\n  return vectorToPoint(p.add(vector.scale(offset)));\n};\n\nexport const offsetPoints = (points: IPoint[], vectors: Vector2[], offset: number): Point[] => {\n  if (points.length !== vectors.length) {\n    throw new Error('Number of vectors does not match number of points');\n  }\n\n  return points.map((point, index) => {\n    const vector = vectors[index];\n    return offsetPoint(point, vector, offset);\n  });\n};\n","import { groupD8, IPoint, Point, Rectangle, Texture, WRAP_MODES } from 'pixi.js';\nimport { DEFAULT_TEXTURE_SIZE } from '../constants';\nimport {\n  Casing,\n  CasingWindow,\n  Cement,\n  CementOptions,\n  CementPlug,\n  CementPlugOptions,\n  CementSqueeze,\n  CementSqueezeOptions,\n  Completion,\n  HoleOptions,\n  HoleSize,\n  ScreenOptions,\n  TubingOptions,\n  Perforation,\n  PerforationOptions,\n  foldPerforationSubKind,\n  intersect,\n  isSubKindCasedHoleFracPack,\n  isSubkindCasedHoleGravelPack,\n  PerforationSubKind,\n} from '../layers/schematicInterfaces';\nimport { ComplexRopeSegment } from '../layers/CustomDisplayObjects/ComplexRope';\nimport { createNormals, offsetPoints } from '../utils/vectorUtils';\n\nexport type PerforationShape = ComplexRopeSegment;\n\nexport interface TubularRenderingObject {\n  leftPath: Point[];\n  rightPath: Point[];\n}\n\nexport interface CasingRenderObject {\n  id: string;\n  kind: 'casing';\n  referenceDiameter: number;\n  referenceRadius: number;\n  casingWallWidth: number;\n  hasShoe: boolean;\n  bottom: number;\n  zIndex?: number;\n  sections: {\n    kind: 'casing' | 'casing-window';\n    leftPath: Point[];\n    rightPath: Point[];\n    pathPoints: Point[];\n    polygon: IPoint[];\n  }[];\n}\n\nexport const getEndLines = (\n  rightPath: IPoint[],\n  leftPath: IPoint[],\n): {\n  top: IPoint[];\n  bottom: IPoint[];\n} => {\n  return {\n    top: [rightPath[0], leftPath[0]],\n    bottom: [rightPath[rightPath.length - 1], leftPath[leftPath.length - 1]],\n  };\n};\n\nexport const makeTubularPolygon = (rightPath: Point[], leftPath: Point[]): Point[] => {\n  return [...leftPath, ...rightPath.map<Point>((d) => d.clone()).reverse()];\n};\n\nexport const overlaps = (top1: number, bottom1: number, top2: number, bottom2: number): boolean => top1 <= bottom2 && top2 <= bottom1;\n\nexport const strictlyOverlaps = (top1: number, bottom1: number, top2: number, bottom2: number): boolean => top1 < bottom2 && top2 < bottom1;\n\nexport const uniq = <T>(arr: T[]): T[] => Array.from<T>(new Set(arr));\n\nconst findIntersectingItems = (\n  start: number,\n  end: number,\n  otherStrings: (Casing | Completion)[],\n  holes: HoleSize[],\n): { overlappingHoles: HoleSize[]; overlappingOuterStrings: (Casing | Completion)[] } => {\n  const overlappingHoles = holes.filter((hole: HoleSize) => overlaps(start, end, hole.start, hole.end));\n\n  const overlappingOuterStrings = otherStrings.filter((casing: Casing | Completion) => overlaps(start, end, casing.start, casing.end));\n\n  return {\n    overlappingHoles,\n    overlappingOuterStrings,\n  };\n};\n\nexport const getUniqueDiameterChangeDepths = (\n  [intervalStart, intervalEnd]: [number, number],\n  diameterIntervals: { start: number; end: number }[],\n): number[] => {\n  const epsilon = 0.0001;\n  const diameterChangeDepths = diameterIntervals.flatMap(\n    (\n      d, // to find diameter right before/after object\n    ) => [d.start - epsilon, d.start, d.end, d.end + epsilon],\n  );\n  const trimmedChangedDepths = diameterChangeDepths.filter((d) => d >= intervalStart && d <= intervalEnd); // trim\n\n  trimmedChangedDepths.push(intervalStart);\n  trimmedChangedDepths.push(intervalEnd);\n\n  const uniqDepths = uniq(trimmedChangedDepths);\n  return uniqDepths.sort((a: number, b: number) => a - b);\n};\n\nconst getInnerStringDiameter = (stringType: Casing | Completion): number =>\n  stringType.kind === 'casing' ? stringType.innerDiameter : stringType.diameter;\n\nexport const findCementOuterDiameterAtDepth = (\n  attachedStrings: (Casing | Completion)[],\n  nonAttachedStrings: (Casing | Completion)[],\n  holes: HoleSize[],\n  depth: number,\n): number => {\n  const defaultCementWidth = 100; // Default to flow cement outside to show error in data\n\n  const attachedStringAtDepth = attachedStrings.find(\n    (casingOrCompletion: Casing | Completion) => casingOrCompletion.start <= depth && casingOrCompletion.end >= depth,\n  );\n  const attachedOuterDiameter = attachedStringAtDepth ? attachedStringAtDepth.diameter : 0;\n\n  const outerCasingAtDepth = nonAttachedStrings\n    .filter((casingOrCompletion: Casing | Completion) => getInnerStringDiameter(casingOrCompletion) > attachedOuterDiameter)\n    .sort((a: Casing | Completion, b: Casing | Completion) => getInnerStringDiameter(a) - getInnerStringDiameter(b)) // ascending\n    .find((casing) => casing.start <= depth && casing.end >= depth);\n\n  const holeAtDepth = holes.find((hole: HoleSize) => hole.start <= depth && hole.end >= depth && hole.diameter > attachedOuterDiameter);\n\n  if (outerCasingAtDepth) {\n    return getInnerStringDiameter(outerCasingAtDepth);\n  }\n\n  if (holeAtDepth) {\n    return holeAtDepth.diameter;\n  }\n\n  return defaultCementWidth;\n};\n\nexport const findPerforationOuterDiameterAtDepth = (\n  nonAttachedStrings: (Casing | Completion)[],\n  holes: HoleSize[],\n  depth: number,\n  perforationSubKind: PerforationSubKind,\n): number => {\n  const defaultPerforationWidth = 100; // Default to flow perforation outside to show error in data\n\n  const outerCasingAtDepth = nonAttachedStrings\n    .sort((a: Casing | Completion, b: Casing | Completion) => b.diameter - a.diameter) // descending\n    .find((casing) => casing.start <= depth && casing.end >= depth);\n\n  const holeAtDepth = holes.find((hole: HoleSize) => hole.start <= depth && hole.end >= depth);\n\n  if (outerCasingAtDepth && perforationSubKind !== 'Open hole frac pack' && perforationSubKind !== 'Open hole gravel pack') {\n    return getInnerStringDiameter(outerCasingAtDepth);\n  }\n\n  if (holeAtDepth) {\n    return holeAtDepth.diameter;\n  }\n\n  return defaultPerforationWidth;\n};\n\nexport const findCementPlugInnerDiameterAtDepth = (\n  attachedStrings: (Casing | Completion)[],\n  nonAttachedStrings: (Casing | Completion)[],\n  holes: HoleSize[],\n  depth: number,\n): number => {\n  // Default to flow cement outside to show error in data\n  const defaultCementWidth = 100;\n  const attachedStringAtDepth = attachedStrings\n    .sort((a: Casing | Completion, b: Casing | Completion) => getInnerStringDiameter(a) - getInnerStringDiameter(b)) // ascending\n    .find((casingOrCompletion) => casingOrCompletion.start <= depth && casingOrCompletion.end >= depth);\n\n  if (attachedStringAtDepth) {\n    return getInnerStringDiameter(attachedStringAtDepth);\n  }\n\n  // Start from an attached diameter\n  const minimumDiameter = attachedStrings.length ? Math.min(...attachedStrings.map((c) => getInnerStringDiameter(c))) : 0;\n  const nonAttachedStringAtDepth = nonAttachedStrings\n    .sort((a: Casing | Completion, b: Casing | Completion) => getInnerStringDiameter(a) - getInnerStringDiameter(b)) // ascending\n    .find(\n      (casingOrCompletion: Casing | Completion) =>\n        casingOrCompletion.start <= depth && casingOrCompletion.end >= depth && minimumDiameter <= getInnerStringDiameter(casingOrCompletion),\n    );\n\n  if (nonAttachedStringAtDepth) {\n    return getInnerStringDiameter(nonAttachedStringAtDepth);\n  }\n\n  const holeAtDepth = holes.find((hole) => hole.start <= depth && hole.end >= depth && hole.diameter);\n\n  if (holeAtDepth) {\n    return holeAtDepth.diameter;\n  }\n\n  return defaultCementWidth;\n};\n\nexport const createComplexRopeSegmentsForCement = (\n  cement: Cement,\n  casings: Casing[],\n  completion: Completion[],\n  holes: HoleSize[],\n  exaggerationFactor: number,\n  getPoints: (start: number, end: number) => Point[],\n): ComplexRopeSegment[] => {\n  const { attachedStrings, nonAttachedStrings } = splitByReferencedStrings(cement.referenceIds, casings, completion);\n\n  if (attachedStrings.length === 0) {\n    throw new Error(`Invalid cement data, can't find referenced casing/completion string for cement with id '${cement.id}'`);\n  }\n\n  attachedStrings.sort((a: Casing, b: Casing) => a.end - b.end); // ascending\n  const bottomOfCement = attachedStrings[attachedStrings.length - 1].end;\n\n  const { overlappingOuterStrings, overlappingHoles } = findIntersectingItems(cement.toc, bottomOfCement, nonAttachedStrings, holes);\n\n  const outerDiameterIntervals = [...overlappingOuterStrings, ...overlappingHoles].map((d) => ({\n    start: d.start,\n    end: d.end,\n  }));\n\n  const changeDepths = getUniqueDiameterChangeDepths([cement.toc, bottomOfCement], outerDiameterIntervals);\n\n  const diameterIntervals = changeDepths.flatMap((depth: number, index: number, list: number[]) => {\n    if (index === list.length - 1) {\n      return [];\n    }\n\n    const nextDepth = list[index + 1];\n    const diameterAtChangeDepth = findCementOuterDiameterAtDepth(attachedStrings, overlappingOuterStrings, overlappingHoles, depth);\n\n    return [{ top: depth, bottom: nextDepth, diameter: diameterAtChangeDepth * exaggerationFactor }];\n  });\n\n  const ropeSegments = diameterIntervals.map((interval) => ({\n    diameter: interval.diameter,\n    points: getPoints(interval.top, interval.bottom),\n  }));\n\n  return ropeSegments;\n};\n\nconst splitByReferencedStrings = (\n  referenceIds: string[],\n  casings: Casing[],\n  completion: Completion[],\n): { attachedStrings: (Casing | Completion)[]; nonAttachedStrings: (Casing | Completion)[] } =>\n  [...casings, ...completion].reduce(\n    (acc, current) => {\n      if (referenceIds.includes(current.id)) {\n        return { ...acc, attachedStrings: [...acc.attachedStrings, current] };\n      }\n      return { ...acc, nonAttachedStrings: [...acc.nonAttachedStrings, current] };\n    },\n    { attachedStrings: [], nonAttachedStrings: [] },\n  );\n\nexport const createComplexRopeSegmentsForCementSqueeze = (\n  squeeze: CementSqueeze,\n  casings: Casing[],\n  completion: Completion[],\n  holes: HoleSize[],\n  exaggerationFactor: number,\n  getPoints: (start: number, end: number) => Point[],\n): ComplexRopeSegment[] => {\n  const { attachedStrings, nonAttachedStrings } = splitByReferencedStrings(squeeze.referenceIds, casings, completion);\n\n  if (attachedStrings.length === 0) {\n    throw new Error(`Invalid cement squeeze data, can't find referenced casing/completion for squeeze with id '${squeeze.id}'`);\n  }\n\n  const { overlappingOuterStrings, overlappingHoles } = findIntersectingItems(squeeze.start, squeeze.end, nonAttachedStrings, holes);\n\n  const outerDiameterIntervals = [...overlappingOuterStrings, ...overlappingHoles].map((d) => ({\n    start: d.start,\n    end: d.end,\n  }));\n\n  const changeDepths = getUniqueDiameterChangeDepths([squeeze.start, squeeze.end], outerDiameterIntervals);\n\n  const diameterIntervals = changeDepths.flatMap((depth, index, list) => {\n    if (index === list.length - 1) {\n      return [];\n    }\n\n    const nextDepth = list[index + 1];\n\n    const diameterAtDepth = findCementOuterDiameterAtDepth(attachedStrings, overlappingOuterStrings, overlappingHoles, depth);\n\n    return [{ top: depth, bottom: nextDepth, diameter: diameterAtDepth * exaggerationFactor }];\n  });\n\n  const ropeSegments = diameterIntervals.map((interval) => ({\n    diameter: interval.diameter,\n    points: getPoints(interval.top, interval.bottom),\n  }));\n\n  return ropeSegments;\n};\n\nexport const createComplexRopeSegmentsForCementPlug = (\n  plug: CementPlug,\n  casings: Casing[],\n  completion: Completion[],\n  holes: HoleSize[],\n  exaggerationFactor: number,\n  getPoints: (start: number, end: number) => Point[],\n): ComplexRopeSegment[] => {\n  const { attachedStrings, nonAttachedStrings } = splitByReferencedStrings(plug.referenceIds, casings, completion);\n\n  const { overlappingHoles, overlappingOuterStrings } = findIntersectingItems(plug.start, plug.end, nonAttachedStrings, holes);\n  const innerDiameterIntervals = [...attachedStrings, ...overlappingHoles, ...overlappingOuterStrings].map((d) => ({\n    start: d.start,\n    end: d.end,\n  }));\n\n  const changeDepths = getUniqueDiameterChangeDepths([plug.start, plug.end], innerDiameterIntervals);\n\n  const diameterIntervals = changeDepths.flatMap((depth, index, list) => {\n    if (index === list.length - 1) {\n      return [];\n    }\n\n    const nextDepth = list[index + 1];\n    const diameterAtDepth = findCementPlugInnerDiameterAtDepth(attachedStrings, overlappingOuterStrings, overlappingHoles, depth);\n\n    return [{ top: depth, bottom: nextDepth, diameter: diameterAtDepth * exaggerationFactor }];\n  });\n\n  const ropeSegments = diameterIntervals.map((interval) => ({\n    diameter: interval.diameter,\n    points: getPoints(interval.top, interval.bottom),\n  }));\n\n  return ropeSegments;\n};\n\nconst createGradientFill = (\n  canvas: HTMLCanvasElement,\n  canvasCtx: CanvasRenderingContext2D,\n  firstColor: string,\n  secondColor: string,\n  startPctOffset: number,\n): CanvasGradient => {\n  const halfWayPct = 0.5;\n  const gradient = canvasCtx.createLinearGradient(0, 0, 0, canvas.height);\n  gradient.addColorStop(0, firstColor);\n  gradient.addColorStop(halfWayPct - startPctOffset, secondColor);\n  gradient.addColorStop(halfWayPct + startPctOffset, secondColor);\n  gradient.addColorStop(1, firstColor);\n\n  return gradient;\n};\n\nexport const createHoleBaseTexture = ({ firstColor, secondColor }: HoleOptions, width: number, height: number): Texture => {\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  const canvasCtx = canvas.getContext('2d');\n\n  canvasCtx.fillStyle = createGradientFill(canvas, canvasCtx, firstColor, secondColor, 0);\n  canvasCtx.fillRect(0, 0, canvas.width, canvas.height);\n\n  return Texture.from(canvas);\n};\n\nexport const createScreenTexture = ({ scalingFactor }: ScreenOptions): Texture => {\n  const canvas = document.createElement('canvas');\n  const size = DEFAULT_TEXTURE_SIZE * scalingFactor;\n  canvas.width = size;\n  canvas.height = size;\n  const canvasCtx = canvas.getContext('2d');\n\n  canvasCtx.fillStyle = 'white';\n  canvasCtx.fillRect(0, 0, canvas.width, canvas.height);\n\n  const baseLineWidth = size / 10; // eslint-disable-line no-magic-numbers\n  canvasCtx.strokeStyle = '#AAAAAA';\n  canvasCtx.lineWidth = baseLineWidth;\n  canvasCtx.beginPath();\n\n  const distanceBetweenLines = size / 3;\n  for (let i = -canvas.width; i < canvas.width; i++) {\n    canvasCtx.moveTo(-canvas.width + distanceBetweenLines * i, -canvas.height);\n    canvasCtx.lineTo(canvas.width + distanceBetweenLines * i, canvas.height * 2);\n  }\n  canvasCtx.stroke();\n  return Texture.from(canvas);\n};\n\nexport const createTubingTexture = ({ innerColor, outerColor, scalingFactor }: TubingOptions): Texture => {\n  const size = DEFAULT_TEXTURE_SIZE * scalingFactor;\n\n  const canvas = document.createElement('canvas');\n  canvas.width = size;\n  canvas.height = size;\n  const canvasCtx = canvas.getContext('2d');\n  const gradient = canvasCtx.createLinearGradient(0, 0, 0, size);\n\n  const innerColorStart = 0.3;\n  const innerColorEnd = 0.7;\n  gradient.addColorStop(0, outerColor);\n  gradient.addColorStop(innerColorStart, innerColor);\n  gradient.addColorStop(innerColorEnd, innerColor);\n  gradient.addColorStop(1, outerColor);\n\n  canvasCtx.fillStyle = gradient;\n  canvasCtx.fillRect(0, 0, canvas.width, canvas.height);\n\n  return Texture.from(canvas);\n};\n\nexport const createCementTexture = ({ firstColor, secondColor, scalingFactor }: CementOptions): Texture => {\n  const canvas = document.createElement('canvas');\n\n  const size = DEFAULT_TEXTURE_SIZE * scalingFactor;\n  const lineWidth = scalingFactor;\n  canvas.width = size;\n  canvas.height = size;\n  const canvasCtx = canvas.getContext('2d');\n\n  canvasCtx.fillStyle = firstColor;\n  canvasCtx.fillRect(0, 0, canvas.width, canvas.height);\n  canvasCtx.lineWidth = lineWidth;\n  canvasCtx.fillStyle = secondColor;\n  canvasCtx.beginPath();\n\n  const distanceBetweenLines = size / 12; // eslint-disable-line no-magic-numbers\n  for (let i = -canvas.width; i < canvas.width; i++) {\n    canvasCtx.moveTo(-canvas.width + distanceBetweenLines * i, -canvas.height);\n    canvasCtx.lineTo(canvas.width + distanceBetweenLines * i, canvas.height);\n  }\n  canvasCtx.stroke();\n\n  return Texture.from(canvas);\n};\n\nexport const createCementPlugTexture = ({ firstColor, secondColor, scalingFactor }: CementPlugOptions): Texture => {\n  const canvas = document.createElement('canvas');\n\n  const size = DEFAULT_TEXTURE_SIZE * scalingFactor;\n  canvas.width = size;\n  canvas.height = size;\n  const canvasCtx = canvas.getContext('2d');\n\n  canvasCtx.fillStyle = firstColor;\n  canvasCtx.fillRect(0, 0, canvas.width, canvas.height);\n  canvasCtx.lineWidth = scalingFactor;\n  canvasCtx.strokeStyle = secondColor;\n  canvasCtx.beginPath();\n\n  canvasCtx.setLineDash([20, 10]); // eslint-disable-line no-magic-numbers\n  const distanceBetweenLines = size / 12; // eslint-disable-line no-magic-numbers\n  for (let i = -canvas.width; i < canvas.width; i++) {\n    canvasCtx.moveTo(-canvas.width + distanceBetweenLines * i, -canvas.height);\n    canvasCtx.lineTo(canvas.width + distanceBetweenLines * i, canvas.height * 2);\n  }\n  canvasCtx.stroke();\n\n  return Texture.from(canvas);\n};\n\nexport const createCementSqueezeTexture = ({ firstColor, secondColor, scalingFactor }: CementSqueezeOptions): Texture => {\n  const canvas = document.createElement('canvas');\n\n  const size = DEFAULT_TEXTURE_SIZE * scalingFactor;\n  const lineWidth = scalingFactor;\n  canvas.width = size;\n  canvas.height = size;\n\n  const canvasCtx = canvas.getContext('2d');\n  canvasCtx.lineWidth = lineWidth;\n  canvasCtx.fillStyle = firstColor;\n  canvasCtx.strokeStyle = secondColor;\n\n  canvasCtx.fillRect(0, 0, canvas.width, canvas.height);\n  canvasCtx.beginPath();\n\n  canvasCtx.setLineDash([20, 10]); // eslint-disable-line no-magic-numbers\n  const distanceBetweenLines = size / 12; // eslint-disable-line no-magic-numbers\n  for (let i = -canvas.width; i < canvas.width; i++) {\n    canvasCtx.moveTo(-canvas.width + distanceBetweenLines * i, -canvas.height);\n    canvasCtx.lineTo(canvas.width + distanceBetweenLines * i, canvas.height * 2);\n  }\n  canvasCtx.stroke();\n\n  return Texture.from(canvas);\n};\n\nexport const createTubularRenderingObject = (radius: number, pathPoints: IPoint[]): TubularRenderingObject => {\n  const normals = createNormals(pathPoints);\n  const rightPath = offsetPoints(pathPoints, normals, radius);\n  const leftPath = offsetPoints(pathPoints, normals, -radius);\n\n  return { leftPath, rightPath };\n};\n\nexport type CasingInterval = {\n  kind: 'casing' | 'casing-window';\n  start: number;\n  end: number;\n};\n\nconst createCasingInterval = (start: number, end: number): CasingInterval => ({ kind: 'casing', start, end });\nconst createCasingWindowInterval = (start: number, end: number): CasingInterval => ({ kind: 'casing-window', start, end });\n\nexport const getCasingIntervalsWithWindows = (casing: Casing): CasingInterval[] => {\n  const result = (casing.windows || [])\n    .filter((cw: CasingWindow) => strictlyOverlaps(casing.start, casing.end, cw.start, cw.end))\n    .reduce<{ intervals: CasingInterval[]; lastBottom: number }>(\n      ({ intervals, lastBottom }, currentWindow: CasingWindow, index: number, list: CasingWindow[]) => {\n        const startCasingInterval: CasingInterval | null =\n          // last bottom before current start?\n          lastBottom < currentWindow.start ? createCasingInterval(lastBottom, currentWindow.start) : null;\n\n        const updatedLastBottom = startCasingInterval ? startCasingInterval.end : lastBottom;\n\n        const windowStart = Math.max(updatedLastBottom, currentWindow.start);\n        const windowEnd = Math.min(casing.end, currentWindow.end);\n        const windowInterval: CasingInterval = createCasingWindowInterval(windowStart, windowEnd);\n\n        const nextLastBottom = windowEnd;\n\n        const isLastWindow = index === list.length - 1;\n        const endCasingInterval: CasingInterval | null =\n          isLastWindow &&\n          // still room for a casing interval?\n          nextLastBottom < casing.end\n            ? createCasingInterval(nextLastBottom, casing.end)\n            : null;\n\n        const newIntervals: CasingInterval[] = [startCasingInterval, windowInterval, endCasingInterval].filter((i) => i);\n\n        return { intervals: [...intervals, ...newIntervals], lastBottom: nextLastBottom };\n      },\n      { intervals: [], lastBottom: casing.start },\n    );\n\n  if (!result.intervals.length) {\n    return [createCasingInterval(casing.start, casing.end)];\n  }\n\n  return result.intervals;\n};\n\nexport const prepareCasingRenderObject = (\n  exaggerationFactor: number,\n  casing: Casing,\n  getPathPoints: (start: number, end: number) => Point[],\n): CasingRenderObject => {\n  const exaggeratedDiameter = casing.diameter * exaggerationFactor;\n  const exaggeratedRadius = exaggeratedDiameter / 2;\n  const exaggeratedInnerDiameter = casing.innerDiameter * exaggerationFactor;\n  const exaggeratedInnerRadius = exaggeratedInnerDiameter / 2;\n  const casingWallWidth = exaggeratedRadius - exaggeratedInnerRadius;\n\n  const sections = getCasingIntervalsWithWindows(casing).map((casingInterval: CasingInterval) => {\n    const pathPoints = getPathPoints(casingInterval.start, casingInterval.end);\n    const { leftPath, rightPath } = createTubularRenderingObject(exaggeratedRadius, pathPoints);\n    return { kind: casingInterval.kind, leftPath, rightPath, pathPoints, polygon: makeTubularPolygon(leftPath, rightPath) };\n  });\n\n  return {\n    kind: 'casing',\n    id: casing.id,\n    referenceDiameter: exaggeratedDiameter,\n    referenceRadius: exaggeratedRadius,\n    sections,\n    casingWallWidth,\n    hasShoe: casing.hasShoe,\n    bottom: casing.end,\n  };\n};\n\nexport const createComplexRopeSegmentsForPerforation = (\n  perforation: Perforation,\n  casings: Casing[],\n  holes: HoleSize[],\n  exaggerationFactor: number,\n  getPoints: (start: number, end: number) => Point[],\n): ComplexRopeSegment[] => {\n  const { overlappingOuterStrings, overlappingHoles } = findIntersectingItems(perforation.start, perforation.end, casings, holes);\n\n  const outerDiameterIntervals = [...overlappingOuterStrings, ...overlappingHoles].map((d) => ({\n    start: d.start,\n    end: d.end,\n  }));\n\n  const changeDepths = getUniqueDiameterChangeDepths([perforation.start, perforation.end], outerDiameterIntervals);\n\n  const diameterIntervals = changeDepths.flatMap((depth, index, list) => {\n    if (index === list.length - 1) {\n      return [];\n    }\n\n    const nextDepth = list[index + 1];\n\n    const diameterAtDepth = findPerforationOuterDiameterAtDepth(overlappingOuterStrings, overlappingHoles, depth, perforation.subKind);\n\n    return [{ top: depth, bottom: nextDepth, diameter: diameterAtDepth * exaggerationFactor }];\n  });\n\n  const ropeSegments = diameterIntervals.map((interval) => {\n    const points = getPoints(interval.top, interval.bottom);\n\n    const diameter = interval.diameter;\n\n    return {\n      diameter,\n      points,\n    };\n  });\n\n  return ropeSegments;\n};\n\nconst drawPacking = (canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D, perforationOptions: PerforationOptions) => {\n  const { packingOpacity, yellow } = perforationOptions;\n\n  ctx.fillStyle = yellow;\n  ctx.strokeStyle = yellow;\n\n  const xy: [number, number] = [0, 0];\n  const wh: [number, number] = [canvas.width, canvas.height];\n  ctx.save();\n  ctx.globalAlpha = packingOpacity;\n  ctx.fillRect(...xy, ...wh);\n  ctx.restore();\n};\n\nconst drawFracLines = (\n  canvas: HTMLCanvasElement,\n  ctx: CanvasRenderingContext2D,\n  extendedPerfShapeDiameter: number,\n  perforationOptions: PerforationOptions,\n  startAt: 'diameter' | 'spike',\n) => {\n  const { fracLineCurve } = perforationOptions;\n\n  const amountOfSpikes = 10;\n  const spikeWidth = canvas.width / amountOfSpikes;\n\n  const diameter = (extendedPerfShapeDiameter / 3) * perforationOptions.scalingFactor;\n\n  const fracLineLength = diameter / 4;\n  const spikeLength = diameter / 2;\n  const offsetX = 0;\n  const offsetY = startAt === 'diameter' ? 0 : spikeLength;\n\n  const fracLines = () => {\n    for (let i = -1; i < amountOfSpikes; i++) {\n      const bottom: [number, number] = [i * spikeWidth + offsetX + spikeWidth / 2, canvas.height / 2 - fracLineLength - offsetY - fracLineLength];\n\n      ctx.beginPath();\n\n      const start: [number, number] = [...bottom];\n      const controlPoint1: [number, number] = [bottom[0] - fracLineCurve * 2, bottom[1] - fracLineLength / 4];\n      const middle: [number, number] = [bottom[0], bottom[1] - fracLineLength / 2];\n\n      const controlPoint2: [number, number] = [bottom[0] + fracLineCurve * 2, bottom[1] - fracLineLength / 2 - fracLineLength / 4];\n      const end: [number, number] = [bottom[0], bottom[1] - fracLineLength];\n\n      ctx.bezierCurveTo(...start, ...controlPoint1, ...middle);\n      ctx.bezierCurveTo(...middle, ...controlPoint2, ...end);\n\n      ctx.stroke();\n    }\n\n    for (let i = -1; i < amountOfSpikes; i++) {\n      const bottom: [number, number] = [i * spikeWidth + spikeWidth + offsetX + spikeWidth / 2, canvas.height / 2 + diameter / 2 + offsetY];\n\n      ctx.beginPath();\n\n      const start: [number, number] = [...bottom];\n      const controlPoint1: [number, number] = [bottom[0] - fracLineCurve * 2, bottom[1] + fracLineLength / 4];\n      const middle: [number, number] = [bottom[0], bottom[1] + fracLineLength / 2];\n\n      const controlPoint2: [number, number] = [bottom[0] + fracLineCurve * 2, bottom[1] + fracLineLength / 2 + fracLineLength / 4];\n      const end: [number, number] = [bottom[0], bottom[1] + fracLineLength];\n\n      ctx.bezierCurveTo(...start, ...controlPoint1, ...middle);\n      ctx.bezierCurveTo(...middle, ...controlPoint2, ...end);\n\n      ctx.stroke();\n    }\n  };\n\n  ctx.strokeStyle = perforationOptions.yellow;\n  ctx.lineWidth = 6;\n  ctx.save();\n  ctx.globalAlpha = perforationOptions.packingOpacity;\n  fracLines();\n  ctx.restore();\n  ctx.lineWidth = 1;\n  ctx.strokeStyle = perforationOptions.outline;\n  fracLines();\n\n  ctx.closePath();\n};\n\nconst drawSpikes = (\n  canvas: HTMLCanvasElement,\n  ctx: CanvasRenderingContext2D,\n  extendedPerfShapeDiameter: number,\n  perforationOptions: PerforationOptions,\n) => {\n  const amountOfSpikes = 10;\n  const spikeWidth = canvas.width / amountOfSpikes;\n  ctx.strokeStyle = perforationOptions.outline;\n\n  const diameter = (extendedPerfShapeDiameter / 3) * perforationOptions.scalingFactor;\n\n  ctx.lineWidth = 1;\n  const spikeLength = diameter / 2;\n  const offsetX = 0;\n\n  // left spikes\n  for (let i = 0; i <= amountOfSpikes; i++) {\n    const left: [number, number] = [i * spikeWidth + offsetX, canvas.height / 2 - diameter / 2];\n    const bottom: [number, number] = [left[0] - spikeWidth / 2, left[1] - spikeLength];\n    const right: [number, number] = [left[0] - spikeWidth, left[1]];\n\n    ctx.beginPath();\n    ctx.moveTo(...left);\n    ctx.lineTo(...bottom);\n    ctx.lineTo(...right);\n    ctx.fill();\n\n    ctx.lineWidth = 1;\n    ctx.stroke();\n  }\n\n  // right spikes\n  for (let i = 0; i <= amountOfSpikes; i++) {\n    const left: [number, number] = [i * spikeWidth + offsetX, canvas.height / 2 + diameter / 2];\n    const bottom: [number, number] = [left[0] - spikeWidth / 2, left[1] + spikeLength];\n    const right: [number, number] = [left[0] - spikeWidth, left[1]];\n\n    ctx.beginPath();\n    ctx.moveTo(...left);\n    ctx.lineTo(...bottom);\n    ctx.lineTo(...right);\n    ctx.fill();\n\n    ctx.lineWidth = 1;\n    ctx.stroke();\n  }\n\n  ctx.closePath();\n};\n\n// for visual debugging\n// if this shoes up, something is wrong\nconst errorTexture = (errorMessage = 'Error!', existingContext?: { canvas: HTMLCanvasElement; canvasCtx: CanvasRenderingContext2D }) => {\n  console.error(`${errorMessage}`);\n  const canvas = existingContext?.canvas || document.createElement('canvas');\n\n  const size = DEFAULT_TEXTURE_SIZE;\n  canvas.width = size / 2;\n  canvas.height = size;\n  const canvasCtx = existingContext?.canvasCtx || canvas.getContext('2d');\n\n  const xy: [number, number] = [0, 0];\n  const wh: [number, number] = [canvas.width, canvas.height];\n\n  canvasCtx.fillStyle = '#ff00ff';\n  canvasCtx.fillRect(...xy, ...wh);\n\n  const texture = new Texture(\n    Texture.from(canvas, { wrapMode: WRAP_MODES.CLAMP }).baseTexture,\n    null,\n    new Rectangle(0, 0, canvas.width, canvas.height),\n    null,\n    groupD8.MIRROR_HORIZONTAL,\n  );\n  return texture;\n};\n\nconst createPerforationCanvas = (\n  perfShape: ComplexRopeSegment,\n  options: PerforationOptions,\n): { canvas: HTMLCanvasElement; ctx: CanvasRenderingContext2D } => {\n  const canvas = document.createElement('canvas');\n  const perfShapeDiameter = perfShape.diameter;\n  const size = perfShapeDiameter * options.scalingFactor;\n  canvas.width = size / 2;\n  canvas.height = size;\n  const ctx = canvas.getContext('2d');\n\n  return { canvas, ctx };\n};\n\nconst createPerforationTexture = (canvas: HTMLCanvasElement) => {\n  const texture = new Texture(\n    Texture.from(canvas, { wrapMode: WRAP_MODES.CLAMP }).baseTexture,\n    null,\n    new Rectangle(0, 0, canvas.width, canvas.height),\n    null,\n    groupD8.MIRROR_HORIZONTAL,\n  );\n  return texture;\n};\n\n/**\n * @Perforation\n * If a perforation does not overlap with another perforations of type with gravel,\n * the perforation spikes are either red when open or grey when closed.\n * Open and closed refers to two fields on a perforation item referencing runs.\n *\n * If a perforation overlaps with another perforation of type with gravel and the perforation is open,\n * the perforation spikes should be yellow. If closed the perforation remains grey.\n *\n * Cased Hole Frac Pack:\n * Makes perforations of type \"Perforation\" yellow if overlapping and perforation are open.\n * If a perforation of type \"perforation\" is overlapping, the fracturation lines extends from the tip of the perforation spikes into formation.\n *\n * Cased Hole Gravel Pack:\n * Yellow gravel. Makes perforations of type \"Perforation\" yellow if overlapping and perforation are open.\n */\nconst createSubkindPerforationTexture = {\n  packing: () => errorTexture(),\n  fracLines: () => errorTexture(),\n  spikes: (\n    perforation: Perforation,\n    perfShape: ComplexRopeSegment,\n    otherPerforations: Perforation[],\n    perforationOptions: PerforationOptions,\n  ): Texture => {\n    const { canvas, ctx } = createPerforationCanvas(perfShape, perforationOptions);\n\n    const intersectionsWithCasedHoleGravel: boolean = otherPerforations.some(\n      (perf) => isSubkindCasedHoleGravelPack(perf) && intersect(perforation, perf),\n    );\n\n    const intersectionsWithCasedHoleFracPack: boolean = otherPerforations.some(\n      (perf) => isSubKindCasedHoleFracPack(perf) && intersect(perforation, perf),\n    );\n\n    const shouldDrawFracLines = intersectionsWithCasedHoleGravel || intersectionsWithCasedHoleFracPack;\n\n    if (shouldDrawFracLines) {\n      if (perforation.isOpen) {\n        ctx.fillStyle = perforationOptions.yellow;\n        ctx.strokeStyle = perforationOptions.yellow;\n      } else {\n        ctx.fillStyle = perforationOptions.grey;\n        ctx.strokeStyle = perforationOptions.grey;\n      }\n    } else {\n      if (perforation.isOpen) {\n        ctx.fillStyle = perforationOptions.red;\n        ctx.strokeStyle = perforationOptions.red;\n      } else {\n        ctx.fillStyle = perforationOptions.grey;\n        ctx.strokeStyle = perforationOptions.grey;\n      }\n    }\n\n    drawSpikes(canvas, ctx, perfShape.diameter, perforationOptions);\n\n    if (intersectionsWithCasedHoleFracPack) {\n      drawFracLines(canvas, ctx, perfShape.diameter, perforationOptions, 'spike');\n    }\n\n    return createPerforationTexture(canvas);\n  },\n};\n\n/**\n * @Cased_hole_fracturation\n * Yellow fracturation lines from casing OD into formation\n */\nconst createSubkindCasedHoleFracturationTexture = {\n  packing: () => errorTexture(),\n  fracLines: (perfShape: ComplexRopeSegment, perforationOptions: PerforationOptions): Texture => {\n    const { canvas, ctx } = createPerforationCanvas(perfShape, perforationOptions);\n    drawFracLines(canvas, ctx, perfShape.diameter, perforationOptions, 'diameter');\n    return createPerforationTexture(canvas);\n  },\n  spikes: () => errorTexture(),\n};\n\n/**\n * @Cased_hole_frac_pack\n * Yellow gravel and fracturation lines.\n * Makes perforations of type \"Perforation\" yellow if overlapping and perforation are open.\n * If no perforation of type \"perforation\" are overlapping, there are no fracturation lines and no spikes.\n * If a perforation of type \"perforation\" is overlapping, the fracturation lines extends from the tip of the perforation spikes into formation.\n */\nconst createSubkindCasedHoleFracPackTexture = {\n  packing: (perfShape: ComplexRopeSegment, perforationOptions: PerforationOptions): Texture => {\n    const { canvas, ctx } = createPerforationCanvas(perfShape, perforationOptions);\n    drawPacking(canvas, ctx, perforationOptions);\n    return createPerforationTexture(canvas);\n  },\n  fracLines: (perfShape: ComplexRopeSegment, perforationOptions: PerforationOptions) => {\n    const { canvas } = createPerforationCanvas(perfShape, perforationOptions);\n    return createPerforationTexture(canvas);\n  },\n  spikes: () => errorTexture(),\n};\n\n/**\n * @Cased_hole_gravel_pack\n * Yellow gravel. Makes perforations of type \"Perforation\" yellow if overlapping and perforation are open.\n */\nconst createSubkindCasedHoleGravelPackTexture = {\n  packing: (perfShape: ComplexRopeSegment, perforationOptions: PerforationOptions): Texture => {\n    const { canvas, ctx } = createPerforationCanvas(perfShape, perforationOptions);\n    drawPacking(canvas, ctx, perforationOptions);\n    return createPerforationTexture(canvas);\n  },\n  fracLines: () => errorTexture(),\n  spikes: () => errorTexture(),\n};\n\n/**\n * @Open_hole_gravel_pack\n * Yellow gravel\n */\nconst createSubkindOpenHoleGravelPackTexture = {\n  packing: (perfShape: ComplexRopeSegment, perforationOptions: PerforationOptions) => {\n    const { canvas, ctx } = createPerforationCanvas(perfShape, perforationOptions);\n    drawPacking(canvas, ctx, perforationOptions);\n    return createPerforationTexture(canvas);\n  },\n  fracLines: () => errorTexture(),\n  spikes: () => errorTexture(),\n};\n\n/**\n * @Open_hole_frac_pack\n * Yellow gravel. Yellow frac lines from hole OD into formation\n */\nconst createSubkindOpenHoleFracPackTexture = {\n  packing: (_perforation: Perforation, perfShape: ComplexRopeSegment, perforationOptions: PerforationOptions) => {\n    const { canvas, ctx } = createPerforationCanvas(perfShape, perforationOptions);\n    drawPacking(canvas, ctx, perforationOptions);\n    return createPerforationTexture(canvas);\n  },\n  fracLines: (perfShape: ComplexRopeSegment, perforationOptions: PerforationOptions): Texture => {\n    const { canvas, ctx } = createPerforationCanvas(perfShape, perforationOptions);\n    drawFracLines(canvas, ctx, perfShape.diameter, perforationOptions, 'diameter');\n    return createPerforationTexture(canvas);\n  },\n  spikes: () => errorTexture(),\n};\n\nexport const createPerforationPackingTexture = (\n  perforation: Perforation,\n  perfShape: ComplexRopeSegment,\n  perforationOptions: PerforationOptions,\n): Texture => {\n  return foldPerforationSubKind(\n    {\n      Perforation: () => createSubkindPerforationTexture.packing(),\n      CasedHoleFracturation: () => createSubkindCasedHoleFracPackTexture.packing(perfShape, perforationOptions),\n      CasedHoleFracPack: () => createSubkindCasedHoleFracPackTexture.packing(perfShape, perforationOptions),\n      OpenHoleGravelPack: () => createSubkindOpenHoleGravelPackTexture.packing(perfShape, perforationOptions),\n      OpenHoleFracPack: () => createSubkindOpenHoleFracPackTexture.packing(perforation, perfShape, perforationOptions),\n      CasedHoleGravelPack: () => createSubkindCasedHoleGravelPackTexture.packing(perfShape, perforationOptions),\n    },\n    perforation.subKind,\n  );\n};\n\nexport const createPerforationFracLineTexture = (\n  perforation: Perforation,\n  perfShape: ComplexRopeSegment,\n  perforationOptions: PerforationOptions,\n): Texture => {\n  return foldPerforationSubKind(\n    {\n      Perforation: () => createSubkindPerforationTexture.fracLines(),\n      OpenHoleGravelPack: () => createSubkindOpenHoleGravelPackTexture.fracLines(),\n      OpenHoleFracPack: () => createSubkindOpenHoleFracPackTexture.fracLines(perfShape, perforationOptions),\n      CasedHoleFracturation: () => createSubkindCasedHoleFracturationTexture.fracLines(perfShape, perforationOptions),\n      CasedHoleGravelPack: () => createSubkindCasedHoleGravelPackTexture.fracLines(),\n      CasedHoleFracPack: () => createSubkindCasedHoleFracPackTexture.fracLines(perfShape, perforationOptions),\n    },\n    perforation.subKind,\n  );\n};\n\nexport const createPerforationSpikeTexture = (\n  perforation: Perforation,\n  otherPerforations: Perforation[],\n  perfShape: ComplexRopeSegment,\n  perforationOptions: PerforationOptions,\n): Texture => {\n  return foldPerforationSubKind(\n    {\n      Perforation: () => createSubkindPerforationTexture.spikes(perforation, perfShape, otherPerforations, perforationOptions),\n      OpenHoleGravelPack: () => createSubkindOpenHoleGravelPackTexture.spikes(),\n      OpenHoleFracPack: () => createSubkindOpenHoleFracPackTexture.spikes(),\n      CasedHoleFracturation: () => createSubkindCasedHoleFracturationTexture.spikes(),\n      CasedHoleGravelPack: () => createSubkindCasedHoleGravelPackTexture.spikes(),\n      CasedHoleFracPack: () => createSubkindCasedHoleFracPackTexture.spikes(),\n    },\n    perforation.subKind,\n  );\n};\n","import { MeshGeometry } from 'pixi.js';\nimport { sum, max } from 'd3-array';\nimport { ComplexRopeSegment } from './ComplexRope';\n\n/**\n * RopeGeometry allows you to draw a geometry across several several segments of points and then manipulate these points.\n */\nexport class ComplexRopeGeometry extends MeshGeometry {\n  /** An array of segments with points and diameter that determine the rope. */\n  private segments: ComplexRopeSegment[];\n\n  /** Rope texture scale. */\n  private readonly textureScale: number; // TODO unused?\n\n  /**\n   * @param segments - An array of segments with points and diameter to construct this rope.\n   * @param textureScale - scaling factor for repeated texture. To create a tiling rope\n   *     set baseTexture.wrapMode to PIXI.WRAP_MODES.REPEAT and use a power of two texture.\n   */\n  constructor(segments: ComplexRopeSegment[], textureScale = 0) {\n    const pointCount = sum(segments, (segment) => segment.points.length);\n\n    // eslint-disable-next-line no-magic-numbers\n    super(new Float32Array(pointCount * 4), new Float32Array(pointCount * 4), new Uint16Array((pointCount - 1) * 6));\n\n    this.segments = segments;\n    this.textureScale = textureScale;\n\n    this.build();\n  }\n\n  /**\n   * The max width (i.e., thickness) of the rope.\n   * @readonly\n   */\n  get width(): number {\n    return max(this.segments, (segment) => segment.diameter);\n  }\n\n  /** Refreshes Rope indices and uvs */\n  private build(): void {\n    const segments = this.segments;\n\n    if (!segments) {\n      return;\n    }\n\n    const vertexBuffer = this.getBuffer('aVertexPosition');\n    const uvBuffer = this.getBuffer('aTextureCoord');\n    const indexBuffer = this.getIndex();\n\n    const pointCount = sum(segments, (segment) => segment.points.length);\n\n    // if too few points, or texture hasn't got UVs set yet just move on.\n    if (pointCount < 1) {\n      return;\n    }\n\n    // if the number of points has changed we will need to recreate the arraybuffers\n    if (vertexBuffer.data.length / 4 !== pointCount) {\n      vertexBuffer.data = new Float32Array(pointCount * 4);\n      uvBuffer.data = new Float32Array(pointCount * 4);\n      indexBuffer.data = new Uint16Array((pointCount - 1) * 6); // eslint-disable-line no-magic-numbers\n    }\n\n    const uvs = uvBuffer.data;\n    const indices = indexBuffer.data;\n\n    uvs[0] = 0;\n    uvs[1] = 0;\n    uvs[2] = 0;\n    uvs[3] = 1;\n\n    const segmentCount = segments.length;\n    const maxDiameter = max(segments, (segment) => segment.diameter);\n\n    let amount = 0;\n    let uvIndex = 0;\n    let indicesIndex = 0;\n    let indexCount = 0;\n\n    for (let i = 0; i < segmentCount; i++) {\n      let prev = segments[i].points[0];\n      const textureWidth = maxDiameter;\n      const radius = segments[i].diameter / maxDiameter / 2;\n\n      const total = segments[i].points.length; // - 1;\n\n      for (let j = 0; j < total; j++) {\n        // time to do some smart drawing!\n\n        // calculate pixel distance from previous point\n        const dx = prev.x - segments[i].points[j].x;\n        const dy = prev.y - segments[i].points[j].y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n\n        prev = segments[i].points[j];\n        amount += distance / textureWidth;\n\n        uvs[uvIndex] = amount;\n        uvs[uvIndex + 1] = 0.5 - radius;\n\n        uvs[uvIndex + 2] = amount;\n        uvs[uvIndex + 3] = 0.5 + radius;\n        uvIndex += 4;\n      }\n\n      for (let j = 0; j < total - 1; j++) {\n        indices[indexCount++] = indicesIndex;\n        indices[indexCount++] = indicesIndex + 1;\n        indices[indexCount++] = indicesIndex + 2;\n\n        indices[indexCount++] = indicesIndex + 2;\n        indices[indexCount++] = indicesIndex + 1;\n        indices[indexCount++] = indicesIndex + 3;\n        indicesIndex += 2;\n      }\n      indicesIndex += 2;\n    }\n\n    // ensure that the changes are uploaded\n    uvBuffer.update();\n    indexBuffer.update();\n\n    this.updateVertices();\n  }\n\n  /** refreshes vertices of Rope mesh */\n  public updateVertices(): void {\n    const segments = this.segments;\n    const pointCount = sum(segments, (segment) => segment.points.length);\n\n    if (pointCount < 1) {\n      return;\n    }\n\n    const segmentCount = segments.length;\n    let lastIndex = 0;\n    for (let i = 0; i < segmentCount; i++) {\n      let lastPoint = segments[i].points[0];\n      let nextPoint;\n      let perpX = 0;\n      let perpY = 0;\n\n      const vertices = this.buffers[0].data;\n      const total = segments[i].points.length;\n      let index = 0;\n      for (let j = 0; j < total; j++) {\n        const point = segments[i].points[j];\n        index = lastIndex + j * 4;\n\n        if (j < segments[i].points.length - 1) {\n          nextPoint = segments[i].points[j + 1];\n        } else {\n          nextPoint = point;\n        }\n\n        perpY = -(nextPoint.x - lastPoint.x);\n        perpX = nextPoint.y - lastPoint.y;\n\n        const perpLength = Math.sqrt(perpX * perpX + perpY * perpY);\n        const num = segments[i].diameter / 2;\n\n        perpX /= perpLength;\n        perpY /= perpLength;\n\n        perpX *= num;\n        perpY *= num;\n\n        vertices[index] = point.x + perpX;\n        vertices[index + 1] = point.y + perpY;\n        vertices[index + 2] = point.x - perpX;\n        vertices[index + 3] = point.y - perpY;\n        lastPoint = point;\n      }\n      lastIndex = index + 4;\n    }\n\n    this.buffers[0].update();\n  }\n\n  public update(): void {\n    // TODO: Possible optimiztion to be had here\n    // Figure out if/when it is enough to only update verticies with this.updateVertices()\n    // See PIXI.SimpleRope.update() for ideas\n\n    // build() sets indicies and uvs and then calls this.updateVertices()\n    this.build();\n  }\n}\n","import { Mesh, MeshMaterial, IPoint, Renderer, Texture, WRAP_MODES } from 'pixi.js';\nimport { ComplexRopeGeometry } from './ComplexRopeGeometry';\n\nexport type ComplexRopeSegment = {\n  points: IPoint[];\n  diameter: number;\n};\n\n/**\n * The ComplexRope allows you to draw a texture across several segments of points and then manipulate these points\n */\nexport class ComplexRope extends Mesh {\n  /**\n   * re-calculate vertices by rope segment-points each frame\n   * @member {boolean}\n   */\n  public autoUpdate: boolean;\n\n  /**\n   * @param texture - The texture to use on the rope.\n   * @param segments - An array of segments with points and diaeter to construct this rope.\n   * @param {number} textureScale - Optional. Adjust interval of repeated texture\n   */\n  constructor(texture: Texture, segments: ComplexRopeSegment[], textureScale = 0) {\n    const ropeGeometry = new ComplexRopeGeometry(segments, textureScale);\n    const meshMaterial = new MeshMaterial(texture);\n\n    // attempt to set UV wrapping, will fail on non-power of two textures\n    texture.baseTexture.wrapMode = WRAP_MODES.REPEAT;\n\n    super(ropeGeometry, meshMaterial);\n\n    this.autoUpdate = true;\n  }\n\n  _render(renderer: Renderer): void {\n    const geometry: ComplexRopeGeometry = this.geometry as ComplexRopeGeometry;\n\n    if (this.autoUpdate) {\n      geometry.update();\n    }\n\n    super._render(renderer);\n  }\n}\n","import { IPoint, MeshGeometry } from 'pixi.js';\n\nexport class FixedWidthSimpleRopeGeometry extends MeshGeometry {\n  public points: IPoint[];\n  _width: number;\n  /**\n   * @param {number} [width=200] - The width (i.e., thickness) of the rope.\n   * @param {PIXI.Point[]} [points] - An array of PIXI.Point objects to construct this rope.\n   */\n  constructor(points: IPoint[], width = 200) {\n    // eslint-disable-next-line no-magic-numbers\n    super(new Float32Array(points.length * 4), new Float32Array(points.length * 4), new Uint16Array((points.length - 1) * 6));\n    /**\n     * An array of points that determine the rope\n     * @member {PIXI.Point[]}\n     */\n    this.points = points;\n    /**\n     * The width (i.e., thickness) of the rope.\n     * @member {number}\n     * @readOnly\n     */\n    this._width = width;\n    /**\n     * Rope texture scale, if zero then the rope texture is stretched.\n     * @member {number}\n     * @readOnly\n     */\n    this.build();\n  }\n  /**\n   * The width (i.e., thickness) of the rope.\n   * @member {number}\n   * @readOnly\n   */\n  get width(): number {\n    return this._width;\n  }\n  /**\n   * Refreshes Rope indices and uvs\n   * @private\n   */\n  private build(): void {\n    const points = this.points;\n    if (!points) {\n      return;\n    }\n    const vertexBuffer = this.getBuffer('aVertexPosition');\n    const uvBuffer = this.getBuffer('aTextureCoord');\n    const indexBuffer = this.getIndex();\n    // if too little points, or texture hasn't got UVs set yet just move on.\n    if (points.length < 1) {\n      return;\n    }\n    // if the number of points has changed we will need to recreate the arraybuffers\n    if (vertexBuffer.data.length / 4 !== points.length) {\n      vertexBuffer.data = new Float32Array(points.length * 4);\n      uvBuffer.data = new Float32Array(points.length * 4);\n      // eslint-disable-next-line no-magic-numbers\n      indexBuffer.data = new Uint16Array((points.length - 1) * 6);\n    }\n    const uvs = uvBuffer.data;\n    const indices = indexBuffer.data;\n    uvs[0] = 0;\n    uvs[1] = 0;\n    uvs[2] = 0;\n    uvs[3] = 1;\n    let amount = 0;\n    let prev = points[0];\n    const total = points.length; // - 1;\n    for (let i = 0; i < total; i++) {\n      // time to do some smart drawing!\n      const index = i * 4;\n\n      // calculate pixel distance from previous point\n      const dx = prev.x - points[i].x;\n      const dy = prev.y - points[i].y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      prev = points[i];\n      amount += distance / this._width;\n\n      uvs[index] = amount;\n      uvs[index + 1] = 0;\n      uvs[index + 2] = amount;\n      uvs[index + 3] = 1;\n    }\n    let indexCount = 0;\n    for (let i = 0; i < total - 1; i++) {\n      const index = i * 2;\n      indices[indexCount++] = index;\n      indices[indexCount++] = index + 1;\n      indices[indexCount++] = index + 2;\n      indices[indexCount++] = index + 2;\n      indices[indexCount++] = index + 1;\n      indices[indexCount++] = index + 3;\n    }\n    // ensure that the changes are uploaded\n    uvBuffer.update();\n    indexBuffer.update();\n    this.updateVertices();\n  }\n  /**\n   * refreshes vertices of Rope mesh\n   */\n  public updateVertices(): void {\n    const points = this.points;\n    if (points.length < 1) {\n      return;\n    }\n    let lastPoint = points[0];\n    let nextPoint;\n    let perpX = 0;\n    let perpY = 0;\n    const vertices = this.buffers[0].data;\n    const total = points.length;\n    for (let i = 0; i < total; i++) {\n      const point = points[i];\n      const index = i * 4;\n      if (i < points.length - 1) {\n        nextPoint = points[i + 1];\n      } else {\n        nextPoint = point;\n      }\n      perpY = -(nextPoint.x - lastPoint.x);\n      perpX = nextPoint.y - lastPoint.y;\n      // eslint-disable-next-line no-magic-numbers\n      let ratio = (1 - i / (total - 1)) * 10;\n      if (ratio > 1) {\n        ratio = 1;\n      }\n      const perpLength = Math.sqrt(perpX * perpX + perpY * perpY);\n      const num = this._width / 2;\n      perpX /= perpLength;\n      perpY /= perpLength;\n      perpX *= num;\n      perpY *= num;\n      vertices[index] = point.x + perpX;\n      vertices[index + 1] = point.y + perpY;\n      vertices[index + 2] = point.x - perpX;\n      vertices[index + 3] = point.y - perpY;\n      lastPoint = point;\n    }\n    this.buffers[0].update();\n  }\n\n  public update(): void {\n    this.build();\n  }\n}\n","import { IPoint, Mesh, MeshMaterial, Renderer, RopeGeometry, Texture, WRAP_MODES } from 'pixi.js';\nimport { FixedWidthSimpleRopeGeometry } from './FixedWidthSimpleRopeGeometry';\n\n/**\n * The rope allows you to draw a texture across several points and then manipulate these points\n * Width of rope is given in constructor\n */\nexport class FixedWidthSimpleRope extends Mesh {\n  /**\n   * re-calculate vertices by rope points each frame\n   * @member {boolean}\n   */\n  public autoUpdate: boolean;\n\n  /**\n   * Note: The wrap mode of the texture is set to REPEAT if `textureScale` is positive.\n   * @param texture - The texture to use on the rope. (attempt to set UV wrapping, will fail on non-power of two textures)\n   * @param points - An array of {@link PIXI.Point} objects to construct this rope.\n   * @param width - Width of rope\n   */\n  constructor(texture: Texture, points: IPoint[], width: number) {\n    const ropeGeometry = new FixedWidthSimpleRopeGeometry(points, width);\n    const meshMaterial = new MeshMaterial(texture);\n\n    texture.baseTexture.wrapMode = WRAP_MODES.REPEAT;\n\n    super(ropeGeometry, meshMaterial);\n\n    this.autoUpdate = true;\n  }\n\n  _render(renderer: Renderer): void {\n    const geometry: RopeGeometry = this.geometry as RopeGeometry;\n\n    if (this.autoUpdate) {\n      geometry.update();\n    }\n\n    super._render(renderer);\n  }\n}\n","import { MeshGeometry } from 'pixi.js';\nimport type { IPoint } from 'pixi.js';\n\n/**\n * UniformTextureStretchRopeGeometry allows you to draw a geometry across several points and then manipulate these points.\n */\nexport class UniformTextureStretchRopeGeometry extends MeshGeometry {\n  /** An array of points that determine the rope. */\n  public points: IPoint[];\n\n  /**\n   * The width (i.e., thickness) of the rope.\n   * @readonly\n   */\n  _width: number;\n\n  /**\n   * @param width - The width (i.e., thickness) of the rope.\n   * @param points - An array of PIXI.Point objects to construct this rope.\n   */\n  constructor(points: IPoint[], width = 200) {\n    // eslint-disable-next-line no-magic-numbers\n    super(new Float32Array(points.length * 4), new Float32Array(points.length * 4), new Uint16Array((points.length - 1) * 6));\n\n    this.points = points;\n    this._width = width;\n\n    this.build();\n  }\n\n  /** Refreshes Rope indices and uvs */\n  private build(): void {\n    const points = this.points;\n\n    if (!points) {\n      return;\n    }\n\n    const vertexBuffer = this.getBuffer('aVertexPosition');\n    const uvBuffer = this.getBuffer('aTextureCoord');\n    const indexBuffer = this.getIndex();\n\n    // if too few points, or texture hasn't got UVs set yet just move on.\n    if (points.length < 1) {\n      return;\n    }\n\n    // if the number of points has changed we will need to recreate the arraybuffers\n    if (vertexBuffer.data.length / 4 !== points.length) {\n      vertexBuffer.data = new Float32Array(points.length * 4);\n      uvBuffer.data = new Float32Array(points.length * 4);\n      indexBuffer.data = new Uint16Array((points.length - 1) * 6); // eslint-disable-line no-magic-numbers\n    }\n\n    const total = points.length; // - 1;\n\n    let totalLength = 0;\n    let prevPoint = points[0];\n\n    for (let i = 0; i < total; i++) {\n      const dx = prevPoint.x - points[i].x;\n      const dy = prevPoint.y - points[i].y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      prevPoint = points[i];\n      totalLength += distance;\n    }\n\n    const uvs = uvBuffer.data;\n    const indices = indexBuffer.data;\n\n    uvs[0] = 0;\n    uvs[1] = 0;\n    uvs[2] = 0;\n    uvs[3] = 1;\n\n    let amount = 0;\n    let prev = points[0];\n\n    for (let i = 0; i < total; i++) {\n      // time to do some smart drawing!\n      const index = i * 4;\n\n      // calculate pixel distance from previous point\n      const dx = prev.x - points[i].x;\n      const dy = prev.y - points[i].y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      prev = points[i];\n\n      // strech texture on distance/length instead of point/points.length to get a more correct strech\n      amount += distance / totalLength;\n\n      uvs[index] = amount;\n      uvs[index + 1] = 0;\n\n      uvs[index + 2] = amount;\n      uvs[index + 3] = 1;\n    }\n\n    let indexCount = 0;\n\n    for (let i = 0; i < total - 1; i++) {\n      const index = i * 2;\n\n      indices[indexCount++] = index;\n      indices[indexCount++] = index + 1;\n      indices[indexCount++] = index + 2;\n\n      indices[indexCount++] = index + 2;\n      indices[indexCount++] = index + 1;\n      indices[indexCount++] = index + 3;\n    }\n\n    // ensure that the changes are uploaded\n    uvBuffer.update();\n    indexBuffer.update();\n\n    this.updateVertices();\n  }\n\n  /** refreshes vertices of Rope mesh */\n  public updateVertices(): void {\n    const points = this.points;\n\n    if (points.length < 1) {\n      return;\n    }\n\n    let lastPoint = points[0];\n    let nextPoint;\n    let perpX = 0;\n    let perpY = 0;\n\n    const vertices = this.buffers[0].data;\n    const total = points.length;\n\n    for (let i = 0; i < total; i++) {\n      const point = points[i];\n      const index = i * 4;\n\n      if (i < points.length - 1) {\n        nextPoint = points[i + 1];\n      } else {\n        nextPoint = point;\n      }\n\n      perpY = -(nextPoint.x - lastPoint.x);\n      perpX = nextPoint.y - lastPoint.y;\n\n      const perpLength = Math.sqrt(perpX * perpX + perpY * perpY);\n      const num = this._width / 2;\n\n      perpX /= perpLength;\n      perpY /= perpLength;\n\n      perpX *= num;\n      perpY *= num;\n\n      vertices[index] = point.x + perpX;\n      vertices[index + 1] = point.y + perpY;\n      vertices[index + 2] = point.x - perpX;\n      vertices[index + 3] = point.y - perpY;\n\n      lastPoint = point;\n    }\n\n    this.buffers[0].update();\n  }\n\n  public update(): void {\n    this.updateVertices();\n  }\n}\n","import { IPoint, Mesh, MeshMaterial, Renderer, Texture } from 'pixi.js';\nimport { UniformTextureStretchRopeGeometry } from './UniformTextureStretchRopeGeometry';\n\n/**\n * The UniformTextureStretchRope allows you to draw a texture across several points and then manipulate these points\n */\nexport class UniformTextureStretchRope extends Mesh {\n  /**\n   * re-calculate vertices by rope points each frame\n   * @member {boolean}\n   */\n  public autoUpdate: boolean;\n\n  /**\n   * @param texture - The texture to use on the rope.\n   * @param points - An array of {@link PIXI.Point} objects to construct this rope.\n   */\n  constructor(texture: Texture, points: IPoint[]) {\n    const ropeGeometry = new UniformTextureStretchRopeGeometry(points, texture.height);\n    const meshMaterial = new MeshMaterial(texture);\n\n    super(ropeGeometry, meshMaterial);\n\n    this.autoUpdate = true;\n  }\n\n  _render(renderer: Renderer): void {\n    const geometry: UniformTextureStretchRopeGeometry = this.geometry as UniformTextureStretchRopeGeometry;\n\n    // TODO: Possible optimiztion here\n    // Find correct check for when to update geometry\n    if (this.autoUpdate || geometry._width !== this.shader.texture.height) {\n      geometry._width = this.shader.texture.height;\n      geometry.update();\n    }\n\n    super._render(renderer);\n  }\n}\n","import { max } from 'd3-array';\nimport { scaleLinear, ScaleLinear } from 'd3-scale';\nimport { Graphics, groupD8, IPoint, Point, Rectangle, RENDERER_TYPE, SimpleRope, Texture } from 'pixi.js';\nimport { DashLine } from '../vendor/pixi-dashed-line';\nimport { LayerOptions, PixiLayer, PixiRenderApplication } from '.';\nimport { DEFAULT_TEXTURE_SIZE, EXAGGERATED_DIAMETER, HOLE_OUTLINE, SCREEN_OUTLINE } from '../constants';\nimport {\n  assertNever,\n  Casing,\n  CasingOptions,\n  Cement,\n  CementOptions,\n  CementPlugOptions,\n  CementSqueeze,\n  CementSqueezeOptions,\n  foldCompletion,\n  HoleOptions,\n  HoleSize,\n  isCementSqueeze,\n  PAndA,\n  SchematicData,\n  ScreenOptions,\n  TubingOptions,\n  Screen,\n  Tubing,\n  CompletionSymbol,\n  isPAndASymbol,\n  isCementPlug,\n  CementPlug,\n  PAndASymbol,\n  InternalLayerOptions,\n  defaultHoleOptions,\n  defaultCasingOptions,\n  defaultCementOptions,\n  defaultCementSqueezeOptions,\n  defaultCementPlugOptions,\n  defaultScreenOptions,\n  defaultTubingOptions,\n  defaultInternalLayerOptions,\n  Perforation,\n  PerforationOptions,\n  defaultPerforationOptions,\n  Completion,\n  OutlineClosure,\n  hasPacking,\n  hasFracLines,\n  hasSpikes,\n} from './schematicInterfaces';\nimport {\n  CasingRenderObject,\n  createCementTexture,\n  createComplexRopeSegmentsForCement,\n  createComplexRopeSegmentsForCementSqueeze,\n  createComplexRopeSegmentsForCementPlug,\n  createHoleBaseTexture,\n  createScreenTexture,\n  createTubingTexture,\n  createTubularRenderingObject,\n  makeTubularPolygon,\n  prepareCasingRenderObject,\n  createCementPlugTexture,\n  createComplexRopeSegmentsForPerforation,\n  createPerforationPackingTexture,\n  PerforationShape,\n  createCementSqueezeTexture,\n  createPerforationFracLineTexture,\n  createPerforationSpikeTexture,\n} from '../datautils/schematicShapeGenerator';\nimport { OnUpdateEvent, OnRescaleEvent, OnUnmountEvent } from '../interfaces';\nimport { convertColor } from '../utils/color';\nimport { createNormals, offsetPoint, offsetPoints } from '../utils/vectorUtils';\nimport { ComplexRope, ComplexRopeSegment } from './CustomDisplayObjects/ComplexRope';\nimport { FixedWidthSimpleRope } from './CustomDisplayObjects/FixedWidthSimpleRope';\nimport { UniformTextureStretchRope } from './CustomDisplayObjects/UniformTextureStretchRope';\n\ninterface ScalingFactors {\n  height: number;\n  zFactor: number;\n  yScale: ScaleLinear<number, number, never>;\n}\n\ninterface SymbolRenderObject {\n  pathPoints: Point[];\n  referenceDiameter: number;\n  symbolKey: string;\n}\n\ninterface CementRenderObject {\n  kind: 'cement';\n  segments: ComplexRopeSegment[];\n  casingIds: string[];\n  zIndex?: number;\n}\n\ninterface CementSqueezeRenderObject {\n  kind: 'cementSqueeze';\n  segments: ComplexRopeSegment[];\n  casingIds: string[];\n  zIndex?: number;\n}\n\ntype InterlacedRenderObjects = CasingRenderObject | CementRenderObject | CementSqueezeRenderObject;\n\nconst foldInterlacedRenderObjects =\n  <T>(fCasing: (obj: CasingRenderObject) => T, fCement: (obj: CementRenderObject) => T, fCementSqueeze: (obj: CementSqueezeRenderObject) => T) =>\n  (renderObject: InterlacedRenderObjects): T => {\n    switch (renderObject.kind) {\n      case 'casing':\n        return fCasing(renderObject);\n      case 'cement':\n        return fCement(renderObject);\n      case 'cementSqueeze':\n        return fCementSqueeze(renderObject);\n      default:\n        return assertNever(renderObject);\n    }\n  };\n\nexport interface SchematicLayerOptions<T extends SchematicData> extends LayerOptions<T> {\n  exaggerationFactor?: number;\n  internalLayerOptions?: InternalLayerOptions;\n  holeOptions?: HoleOptions;\n  casingOptions?: CasingOptions;\n  cementOptions?: CementOptions;\n  cementSqueezeOptions?: CementSqueezeOptions;\n  screenOptions?: ScreenOptions;\n  tubingOptions?: TubingOptions;\n  cementPlugOptions?: CementPlugOptions;\n  perforationOptions?: PerforationOptions;\n}\n\nconst defaultSchematicLayerOptions = (layerId: string): SchematicLayerOptions<SchematicData> => ({\n  exaggerationFactor: 2,\n  internalLayerOptions: defaultInternalLayerOptions(layerId),\n  holeOptions: defaultHoleOptions,\n  casingOptions: defaultCasingOptions,\n  cementOptions: defaultCementOptions,\n  cementSqueezeOptions: defaultCementSqueezeOptions,\n  screenOptions: defaultScreenOptions,\n  tubingOptions: defaultTubingOptions,\n  cementPlugOptions: defaultCementPlugOptions,\n  perforationOptions: defaultPerforationOptions,\n});\n\ntype InternalLayerVisibility = { [K in keyof InternalLayerOptions]: boolean };\n\nexport class SchematicLayer<T extends SchematicData> extends PixiLayer<T> {\n  private internalLayerVisibility: InternalLayerVisibility = {\n    holeLayerId: true,\n    casingLayerId: true,\n    completionLayerId: true,\n    cementLayerId: true,\n    pAndALayerId: true,\n    perforationLayerId: true,\n  };\n\n  private cementTextureCache: Texture;\n  private cementSqueezeTextureCache: Texture;\n  private cementPlugTextureCache: Texture;\n  private holeTextureCache: Texture;\n  private screenTextureCache: Texture;\n  private tubingTextureCache: Texture;\n  private textureSymbolCacheArray: { [key: string]: Texture };\n\n  protected scalingFactors: ScalingFactors = {\n    height: 600,\n    zFactor: 1,\n    yScale: scaleLinear(),\n  };\n\n  constructor(ctx: PixiRenderApplication, id?: string, options?: SchematicLayerOptions<T>) {\n    super(ctx, id, options);\n    this.options = <SchematicLayerOptions<T>>{\n      ...this.options,\n      ...defaultSchematicLayerOptions(this.id),\n      ...options,\n    };\n  }\n\n  public onUnmount(event?: OnUnmountEvent): void {\n    super.onUnmount(event);\n    this.scalingFactors = null;\n    this.cementTextureCache = null;\n    this.cementSqueezeTextureCache = null;\n    this.holeTextureCache = null;\n    this.screenTextureCache = null;\n    this.tubingTextureCache = null;\n    this.textureSymbolCacheArray = null;\n    this.internalLayerVisibility = null;\n  }\n\n  public onUpdate(event: OnUpdateEvent<T>): void {\n    super.onUpdate(event);\n    this.clearLayer();\n    this.preRender();\n    this.render();\n  }\n\n  public override onRescale(event: OnRescaleEvent): void {\n    const shouldRecalculate = this.scalingFactors.zFactor !== event.zFactor;\n\n    this.scalingFactors = { height: event.height, zFactor: event.zFactor, yScale: event.yScale };\n    super.optionsRescale(event);\n    const yRatio = this.yRatio();\n    const flippedX = event.xBounds[0] > event.xBounds[1];\n    const flippedY = event.yBounds[0] > event.yBounds[1];\n    this.setContainerPosition(event.xScale(0), event.yScale(0));\n    this.setContainerScale(event.xRatio * (flippedX ? -1 : 1), yRatio * (flippedY ? -1 : 1));\n    if (shouldRecalculate) {\n      this.clearLayer();\n      this.preRender();\n    }\n\n    this.render();\n  }\n\n  public override setVisibility(isVisible: boolean, layerId: string) {\n    if (layerId === this.id) {\n      super.setVisibility(isVisible, layerId);\n      return;\n    }\n\n    const { internalLayerOptions } = this.options as SchematicLayerOptions<T>;\n\n    const [keyFound] = Object.entries(internalLayerOptions).find(([_key, id]: [string, string]) => id === layerId);\n    if (keyFound) {\n      this.internalLayerVisibility[keyFound as keyof InternalLayerVisibility] = isVisible;\n      this.clearLayer();\n      this.preRender();\n      this.render();\n    }\n  }\n\n  public override getInternalLayerIds(): string[] {\n    const { internalLayerOptions } = this.options as SchematicLayerOptions<T>;\n    return Object.values(internalLayerOptions);\n  }\n\n  /**\n   * Calculate yRatio without zFactor\n   * TODO consider to move this into ZoomPanHandler\n   */\n  protected yRatio(): number {\n    const domain = this.scalingFactors.yScale.domain();\n    const ySpan = domain[1] - domain[0];\n    const baseYSpan = ySpan * this.scalingFactors.zFactor;\n    const baseDomain = [domain[0], domain[0] + baseYSpan];\n    return Math.abs(this.scalingFactors.height / (baseDomain[1] - baseDomain[0]));\n  }\n\n  protected getZFactorScaledPathForPoints = (start: number, end: number): Point[] => {\n    const y = (y: number): number => y * this.scalingFactors.zFactor;\n\n    const path = this.referenceSystem.getCurtainPath(start, end, true);\n    return path.map((p) => new Point(p.point[0], y(p.point[1])));\n  };\n\n  protected drawBigPolygon = (coords: IPoint[], color = 0x000000) => {\n    const polygon = new Graphics();\n    polygon.beginFill(color);\n    polygon.drawPolygon(coords);\n    polygon.endFill();\n\n    this.addChild(polygon);\n  };\n\n  protected drawBigTexturedPolygon = (coords: Point[], t: Texture): Graphics => {\n    const polygon = new Graphics().beginTextureFill({ texture: t }).drawPolygon(coords).endFill();\n    this.addChild(polygon);\n    return polygon;\n  };\n\n  protected drawRope(path: Point[], texture: Texture, tint?: number): void {\n    if (path.length === 0) {\n      return null;\n    }\n\n    const rope: SimpleRope = new SimpleRope(texture, path, 1);\n\n    rope.tint = tint || rope.tint;\n\n    this.addChild(rope);\n  }\n\n  /**\n   *\n   * @param leftPath Points for line on left side\n   * @param rightPath Points for line on right side\n   * @param lineColor Color of line\n   * @param lineWidth Width of line\n   * @param outlineClosure If line should be drawn at top and/or bottom of the paths\n   * @param lineAlignment alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outer).\n   */\n  protected drawOutline(\n    leftPath: Point[],\n    rightPath: Point[],\n    lineColor: number,\n    lineWidth = 1,\n    outlineClosure: OutlineClosure = 'None',\n    lineAlignment = 1,\n  ): void {\n    const leftPathReverse = leftPath.map<Point>((d) => d.clone()).reverse();\n\n    const startPointRight = rightPath[0];\n    const startPointLeft = leftPathReverse[0];\n\n    const line = new Graphics();\n    line.lineStyle(lineWidth, lineColor, undefined, lineAlignment);\n    line.moveTo(startPointRight.x, startPointRight.y);\n    rightPath.forEach((p: Point) => line.lineTo(p.x, p.y));\n\n    if (outlineClosure === 'None' || outlineClosure === 'Top') {\n      line.moveTo(startPointLeft.x, startPointLeft.y);\n    }\n\n    leftPathReverse.forEach((p: Point) => line.lineTo(p.x, p.y));\n\n    if (outlineClosure === 'TopAndBottom' || outlineClosure === 'Top') {\n      line.lineTo(startPointRight.x, startPointRight.y);\n    }\n\n    this.addChild(line);\n  }\n\n  /**\n   * Uses a dashed outline on one side to represent casing window\n   * The casing window should be visualized at the upper side of the wellbore path\n   * @param leftPath Points for line on left side\n   * @param pointPath Points for line on right side\n   * @param lineColor Color of line\n   * @param lineWidth Width of line\n   * @param lineAlignment alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outer).\n   */\n  protected drawCasingWindowOutline(leftPath: Point[], rightPath: Point[], { lineColor, windowOptions }: CasingOptions, lineWidth = 1): void {\n    // Correct the dashed path. Should always be displayed on the upper side of the wellbore path.\n    const flippedPaths = !!this.referenceSystem?.options?.calculateDisplacementFromBottom;\n    const [linePath, dashedPath] = flippedPaths ? [leftPath, rightPath] : [rightPath, leftPath];\n    const [dashedAlignment, solidAlignment] = flippedPaths ? [1, 0] : [0, 1];\n\n    const graphics = new Graphics();\n    graphics.lineStyle(lineWidth, convertColor(lineColor), undefined, solidAlignment);\n\n    const startPointLinePath = linePath[0];\n    graphics.moveTo(startPointLinePath.x, startPointLinePath.y);\n    linePath.forEach((p: Point) => graphics.lineTo(p.x, p.y));\n\n    const dashedLine = new DashLine(graphics, {\n      dash: [windowOptions.dashLength, windowOptions.spaceLength],\n      color: convertColor(windowOptions.dashColor),\n      width: lineWidth,\n      alignment: dashedAlignment,\n    });\n\n    const startPointDashedPath = dashedPath[0];\n    dashedLine.moveTo(startPointDashedPath.x, startPointDashedPath.y);\n    dashedPath.forEach((currentPoint: Point) => {\n      dashedLine.lineTo(currentPoint.x, currentPoint.y);\n    });\n\n    this.addChild(graphics);\n  }\n\n  private perforationRopeAndTextureReferences: { rope: ComplexRope; texture: Texture }[] = [];\n\n  public preRender(): void {\n    if (!this.data || !this.referenceSystem) {\n      return;\n    }\n\n    const { exaggerationFactor } = this.options as SchematicLayerOptions<T>;\n    const { holeSizes, casings, cements, completion, symbols, pAndA, perforations } = this.data;\n\n    this.updateSymbolCache(symbols);\n\n    holeSizes.sort((a: HoleSize, b: HoleSize) => b.diameter - a.diameter);\n    const maxHoleDiameter = holeSizes.length > 0 ? max(holeSizes, (d) => d.diameter) * exaggerationFactor : EXAGGERATED_DIAMETER * exaggerationFactor;\n    if (this.internalLayerVisibility.holeLayerId) {\n      holeSizes.forEach((hole: HoleSize) => this.drawHoleSize(maxHoleDiameter, hole));\n    }\n\n    casings.sort((a: Casing, b: Casing) => b.diameter - a.diameter);\n    const casingRenderObjects: CasingRenderObject[] = casings.map((casing: Casing) => this.createCasingRenderObject(casing));\n\n    const cementShapes: CementRenderObject[] = cements.map(\n      (cement: Cement): CementRenderObject => ({\n        kind: 'cement',\n        segments: createComplexRopeSegmentsForCement(cement, casings, completion, holeSizes, exaggerationFactor, this.getZFactorScaledPathForPoints),\n        casingIds: (cement.referenceIds || []).filter((id) => id),\n      }),\n    );\n\n    const [cementSqueezes, remainingPAndA] = pAndA.reduce<[CementSqueeze[], Exclude<PAndA, CementSqueeze>[]]>(\n      ([squeezes, remaining], current: PAndA) =>\n        isCementSqueeze(current) ? [[current, ...squeezes], remaining] : [squeezes, [current, ...remaining]],\n      [[], []],\n    );\n\n    const cementSqueezesShape: CementSqueezeRenderObject[] = cementSqueezes.map((squeeze) => ({\n      kind: 'cementSqueeze',\n      segments: this.createCementSqueezeShape(squeeze, casings, completion, holeSizes),\n      casingIds: squeeze.referenceIds,\n    }));\n\n    this.sortCementAndCasingRenderObjects(casingRenderObjects, cementShapes, cementSqueezesShape).forEach(\n      foldInterlacedRenderObjects(\n        (casingRO: CasingRenderObject) => {\n          if (this.internalLayerVisibility.casingLayerId) {\n            this.drawCasing(casingRO);\n\n            if (casingRO.hasShoe) {\n              this.drawShoe(casingRO.bottom, casingRO.referenceRadius);\n            }\n          }\n        },\n        (cementRO: CementRenderObject) => {\n          if (this.internalLayerVisibility.cementLayerId) {\n            this.drawComplexRope(cementRO.segments, this.getCementTexture());\n          }\n        },\n        (cementSqueezesRO: CementSqueezeRenderObject) => {\n          if (this.internalLayerVisibility.pAndALayerId) {\n            this.drawComplexRope(cementSqueezesRO.segments, this.getCementSqueezeTexture());\n          }\n        },\n      ),\n    );\n\n    this.perforationRopeAndTextureReferences.forEach(({ rope, texture }) => {\n      rope.destroy({\n        children: true,\n        texture: true,\n        baseTexture: true,\n      });\n      texture.destroy(true);\n    });\n    this.perforationRopeAndTextureReferences = [];\n\n    if (this.internalLayerVisibility.perforationLayerId) {\n      const { perforationOptions } = this.options as SchematicLayerOptions<T>;\n      const packings = perforations.filter(hasPacking);\n      const fracLines = perforations.filter(hasFracLines);\n      const spikes = perforations.filter(hasSpikes);\n      packings.forEach((perforation) => {\n        const perfShapes = this.createPerforationShape(perforation, casings, holeSizes);\n        const perfShapesByDiameter: { [key: number]: ComplexRopeSegment[] } = perfShapes.reduce(\n          (dict: { [key: number]: ComplexRopeSegment[] }, ps) => {\n            if (!dict[ps.diameter]) {\n              dict[ps.diameter] = [];\n            }\n            dict[ps.diameter] = [...dict[ps.diameter], ps];\n            return dict;\n          },\n          {},\n        );\n        Object.values(perfShapesByDiameter).forEach((perfShapesWithSameDiameter) => {\n          const texture = createPerforationPackingTexture(perforation, perfShapesWithSameDiameter[0], perforationOptions);\n          const rope = this.drawComplexRope(perfShapesWithSameDiameter, texture);\n          this.perforationRopeAndTextureReferences.push({ rope, texture });\n        });\n      });\n\n      fracLines.forEach((perforation) => {\n        const perfShapes = this.createPerforationShape(perforation, casings, holeSizes);\n        const thiccPerfShapes = perfShapes.map((ps) => ({ ...ps, diameter: ps.diameter * 3 }));\n        const perfShapesByDiameter: { [key: number]: ComplexRopeSegment[] } = thiccPerfShapes.reduce(\n          (dict: { [key: number]: ComplexRopeSegment[] }, ps) => {\n            if (!dict[ps.diameter]) {\n              dict[ps.diameter] = [];\n            }\n            dict[ps.diameter] = [...dict[ps.diameter], ps];\n            return dict;\n          },\n          {},\n        );\n        Object.values(perfShapesByDiameter).forEach((perfShapesWithSameDiameter) => {\n          perfShapesWithSameDiameter.forEach((perfShape) => {\n            const texture = createPerforationFracLineTexture(perforation, perfShape, perforationOptions);\n            const rope = this.drawComplexRope([perfShape], texture);\n            this.perforationRopeAndTextureReferences.push({ rope, texture });\n          });\n        });\n      });\n      spikes.forEach((perforation) => {\n        const perfShapes = this.createPerforationShape(perforation, casings, holeSizes);\n        const thiccPerfShapes = perfShapes.map((ps) => ({ ...ps, diameter: ps.diameter * 3 }));\n        const perfShapesByDiameter: { [key: number]: ComplexRopeSegment[] } = thiccPerfShapes.reduce(\n          (dict: { [key: number]: ComplexRopeSegment[] }, ps) => {\n            if (!dict[ps.diameter]) {\n              dict[ps.diameter] = [];\n            }\n            dict[ps.diameter] = [...dict[ps.diameter], ps];\n            return dict;\n          },\n          {},\n        );\n        Object.values(perfShapesByDiameter).forEach((perfShapesWithSameDiameter) => {\n          perfShapesWithSameDiameter.forEach((perfShape) => {\n            const texture = createPerforationSpikeTexture(perforation, perforations, perfShape, perforationOptions);\n            const rope = this.drawComplexRope([perfShape], texture);\n            this.perforationRopeAndTextureReferences.push({ rope, texture });\n          });\n        });\n      });\n    }\n\n    if (this.internalLayerVisibility.completionLayerId) {\n      completion.forEach(\n        foldCompletion(\n          (obj: Screen) => this.drawScreen(obj),\n          (obj: Tubing) => this.drawTubing(obj),\n          (obj: CompletionSymbol) => {\n            const symbolRenderObject = this.prepareSymbolRenderObject(obj);\n            this.drawSymbolComponent(symbolRenderObject);\n          },\n        ),\n      );\n    }\n\n    if (this.internalLayerVisibility.pAndALayerId) {\n      remainingPAndA.forEach((obj) => {\n        if (isPAndASymbol(obj)) {\n          const symbolRenderObject = this.prepareSymbolRenderObject(obj);\n          this.drawSymbolComponent(symbolRenderObject);\n        }\n        if (isCementPlug(obj)) {\n          this.drawCementPlug(obj, casings, completion, holeSizes);\n        }\n      });\n    }\n  }\n\n  private updateSymbolCache(symbols: { [key: string]: string }) {\n    if (!this.textureSymbolCacheArray) {\n      this.textureSymbolCacheArray = {};\n    }\n    if (!symbols) {\n      return;\n    }\n\n    const existingKeys = Object.keys(this.textureSymbolCacheArray);\n    Object.entries(symbols).forEach(([key, symbol]: [string, string]) => {\n      if (!existingKeys.includes(key)) {\n        this.textureSymbolCacheArray[key] = Texture.from(symbol);\n      }\n    });\n  }\n\n  private drawCementPlug(cementPlug: CementPlug, casings: Casing[], completion: Completion[], holes: HoleSize[]) {\n    const { exaggerationFactor, cementPlugOptions } = this.options as SchematicLayerOptions<T>;\n\n    const cementPlugSegments = createComplexRopeSegmentsForCementPlug(\n      cementPlug,\n      casings,\n      completion,\n      holes,\n      exaggerationFactor,\n      this.getZFactorScaledPathForPoints,\n    );\n    this.drawComplexRope(cementPlugSegments, this.getCementPlugTexture(cementPlugOptions));\n\n    const { rightPath, leftPath } = cementPlugSegments.reduce<{ rightPath: Point[]; leftPath: Point[] }>(\n      (acc, current) => {\n        const { leftPath, rightPath } = createTubularRenderingObject(current.diameter / 2, current.points);\n\n        return {\n          rightPath: [...acc.rightPath, ...rightPath],\n          leftPath: [...acc.leftPath, ...leftPath],\n        };\n      },\n      { rightPath: [], leftPath: [] },\n    );\n    // eslint-disable-next-line no-magic-numbers\n    this.drawOutline(leftPath, rightPath, convertColor('black'), 0.25, 'TopAndBottom');\n  }\n\n  private createCasingRenderObject(casing: Casing): CasingRenderObject {\n    const { exaggerationFactor } = this.options as SchematicLayerOptions<T>;\n    return prepareCasingRenderObject(exaggerationFactor, casing, this.getZFactorScaledPathForPoints);\n  }\n\n  private getCementPlugTexture(cementPlugOptions: CementPlugOptions): Texture {\n    if (!this.cementPlugTextureCache) {\n      this.cementPlugTextureCache = createCementPlugTexture(cementPlugOptions);\n    }\n    return this.cementPlugTextureCache;\n  }\n\n  private prepareSymbolRenderObject = (component: CompletionSymbol | PAndASymbol): SymbolRenderObject => {\n    const { exaggerationFactor } = this.options as SchematicLayerOptions<T>;\n\n    const exaggeratedDiameter = component.diameter * exaggerationFactor;\n\n    const pathPoints = this.getZFactorScaledPathForPoints(component.start, component.end);\n\n    return {\n      pathPoints,\n      referenceDiameter: exaggeratedDiameter,\n      symbolKey: component.symbolKey,\n    };\n  };\n\n  private drawSymbolComponent = ({ pathPoints, referenceDiameter, symbolKey }: SymbolRenderObject): void => {\n    const texture = this.getSymbolTexture(symbolKey, referenceDiameter);\n    // The rope renders fine in CANVAS/fallback mode\n    this.drawSVGRope(pathPoints, texture);\n  };\n\n  private drawSVGRope(path: Point[], texture: Texture): void {\n    if (path.length === 0) {\n      return null;\n    }\n\n    const rope: UniformTextureStretchRope = new UniformTextureStretchRope(texture, path);\n\n    this.addChild(rope);\n  }\n\n  private getSymbolTexture(symbolKey: string, diameter: number): Texture {\n    return new Texture(this.textureSymbolCacheArray[symbolKey].baseTexture, null, new Rectangle(0, 0, 0, diameter), null, groupD8.MAIN_DIAGONAL);\n  }\n\n  private drawHoleSize = (maxHoleDiameter: number, holeObject: HoleSize): void => {\n    if (holeObject == null) {\n      return;\n    }\n\n    const pathPoints = this.getZFactorScaledPathForPoints(holeObject.start, holeObject.end);\n    if (pathPoints.length === 0) {\n      return;\n    }\n\n    const { exaggerationFactor, holeOptions } = this.options as SchematicLayerOptions<T>;\n    const exaggeratedDiameter = holeObject.diameter * exaggerationFactor;\n    const { rightPath, leftPath } = createTubularRenderingObject(exaggeratedDiameter / 2, pathPoints);\n\n    if (this.renderType() === RENDERER_TYPE.CANVAS) {\n      const polygonCoords = makeTubularPolygon(leftPath, rightPath);\n      this.drawBigPolygon(polygonCoords, convertColor(holeOptions.firstColor));\n    } else {\n      const texture = this.getHoleTexture(holeOptions, exaggeratedDiameter, maxHoleDiameter);\n      this.drawHoleRope(pathPoints, texture, maxHoleDiameter);\n    }\n\n    this.drawOutline(leftPath, rightPath, convertColor(holeOptions.lineColor), HOLE_OUTLINE * exaggerationFactor, 'TopAndBottom', 0);\n  };\n\n  private drawHoleRope(path: Point[], texture: Texture, maxHoleDiameter: number): void {\n    if (path.length === 0) {\n      return null;\n    }\n\n    const rope: SimpleRope = new SimpleRope(texture, path, maxHoleDiameter / DEFAULT_TEXTURE_SIZE);\n\n    this.addChild(rope);\n  }\n\n  private getHoleTexture(holeOptions: HoleOptions, diameter: number, maxHoleDiameter: number): Texture {\n    const size = DEFAULT_TEXTURE_SIZE;\n    const height = size;\n    const width = size;\n\n    const textureDiameter = (diameter / maxHoleDiameter) * size;\n\n    if (!this.holeTextureCache) {\n      this.holeTextureCache = createHoleBaseTexture(holeOptions, width, height);\n    }\n\n    const baseTexture = this.holeTextureCache.baseTexture;\n    const sidePadding = (height - textureDiameter) / 2;\n    const frame = new Rectangle(0, sidePadding, width, textureDiameter);\n    const texture = new Texture(baseTexture, frame);\n\n    return texture;\n  }\n\n  /**\n   * The rendering order of these components needs to be aligned\n   * @param casingRenderObjects\n   * @param cementRenderObject\n   * @param cementSqueezes\n   * @returns ordered rendering list\n   */\n  private sortCementAndCasingRenderObjects(\n    casingRenderObjects: CasingRenderObject[],\n    cementRenderObject: CementRenderObject[],\n    cementSqueezes: CementSqueezeRenderObject[],\n  ): InterlacedRenderObjects[] {\n    type InterlaceReducerAcc = {\n      result: InterlacedRenderObjects[];\n      remainingCement: CementRenderObject[];\n      remainingCementSqueezes: CementSqueezeRenderObject[];\n    };\n\n    let zIndex = 0;\n\n    const { result } = casingRenderObjects.reduce(\n      (acc: InterlaceReducerAcc, casingRenderObject: CasingRenderObject): InterlaceReducerAcc => {\n        const foundCementShape = acc.remainingCement.find((cement) => cement.casingIds.includes(casingRenderObject.id));\n        const foundCementSqueezes = acc.remainingCementSqueezes.filter((squeeze) => squeeze.casingIds.includes(casingRenderObject.id));\n\n        if (foundCementShape) {\n          foundCementShape.zIndex = zIndex++;\n        }\n        foundCementSqueezes.forEach((item) => (item.zIndex = zIndex++));\n        casingRenderObject.zIndex = zIndex++;\n\n        return {\n          result: [...acc.result, foundCementShape, casingRenderObject, ...foundCementSqueezes],\n          remainingCement: acc.remainingCement.filter((c) => c !== foundCementShape),\n          remainingCementSqueezes: acc.remainingCementSqueezes.filter((squeeze) => !foundCementSqueezes.includes(squeeze)),\n        };\n      },\n      { result: [], remainingCement: cementRenderObject, remainingCementSqueezes: cementSqueezes },\n    );\n\n    return result.filter((item) => item !== undefined).sort((a, b) => a.zIndex - b.zIndex);\n  }\n\n  /**\n   *\n   * @param intervals\n   * @param texture\n   * optionally fetch the exaggerationFactor from a different options prop\n   * options.perforationOptions for example\n   * @param getExaggerationFactor\n   * @returns\n   */\n  private drawComplexRope(intervals: ComplexRopeSegment[], texture: Texture): ComplexRope {\n    if (intervals.length === 0) {\n      return null;\n    }\n    const { exaggerationFactor } = this.options as SchematicLayerOptions<T>;\n\n    const rope = new ComplexRope(texture, intervals, exaggerationFactor);\n\n    this.addChild(rope);\n\n    return rope;\n  }\n\n  private static getOutlineClosureType = (index: number, maxIndex: number): OutlineClosure => {\n    if (index === 0) {\n      if (index === maxIndex) {\n        return 'TopAndBottom';\n      }\n      return 'Top';\n    }\n    if (index === maxIndex) {\n      return 'Bottom';\n    }\n\n    return 'None';\n  };\n\n  private drawCasing = (casingRenderObject: CasingRenderObject): void => {\n    const { casingOptions } = this.options as SchematicLayerOptions<T>;\n    const casingSolidColorNumber = convertColor(casingOptions.solidColor);\n    const casingLineColorNumber = convertColor(casingOptions.lineColor);\n\n    casingRenderObject.sections.forEach((section, index, list) => {\n      const outlineClosureType = SchematicLayer.getOutlineClosureType(index, list.length - 1);\n      // Pixi.js-legacy handles SimpleRope and advanced render methods poorly\n      if (this.renderType() === RENDERER_TYPE.CANVAS) {\n        this.drawBigPolygon(section.polygon, casingSolidColorNumber);\n      } else {\n        const texture = this.createCasingTexture(casingRenderObject.referenceDiameter);\n        this.drawRope(section.pathPoints, texture, casingSolidColorNumber);\n      }\n      if (section.kind === 'casing-window') {\n        this.drawCasingWindowOutline(section.leftPath, section.rightPath, casingOptions, casingRenderObject.casingWallWidth);\n      } else {\n        this.drawOutline(section.leftPath, section.rightPath, casingLineColorNumber, casingRenderObject.casingWallWidth, outlineClosureType);\n      }\n    });\n  };\n\n  private createCasingTexture(diameter: number): Texture {\n    const textureWidthPO2 = 16;\n    return new Texture(Texture.WHITE.baseTexture, null, new Rectangle(0, 0, textureWidthPO2, diameter));\n  }\n\n  private drawShoe(casingEnd: number, casingRadius: number): void {\n    const { exaggerationFactor, casingOptions } = this.options as SchematicLayerOptions<T>;\n    const shoeWidth = casingOptions.shoeSize.width * exaggerationFactor;\n    const shoeLength = casingOptions.shoeSize.length * exaggerationFactor;\n\n    const shoeCoords = this.generateShoe(casingEnd, casingRadius, shoeLength, shoeWidth);\n    const shoeCoords2 = this.generateShoe(casingEnd, casingRadius, shoeLength, -shoeWidth);\n    this.drawBigPolygon(shoeCoords2);\n    this.drawBigPolygon(shoeCoords);\n  }\n\n  private generateShoe = (casingEnd: number, casingRadius: number, length: number, width: number): Point[] => {\n    const start = casingEnd - length;\n    const end = casingEnd;\n\n    const points = this.getZFactorScaledPathForPoints(start, end);\n\n    const normal = createNormals(points);\n    const shoeEdge: Point[] = offsetPoints(points, normal, casingRadius * (width < 0 ? -1 : 1));\n\n    const shoeTipPoint = points[points.length - 1];\n    const shoeTipNormal = normal[normal.length - 1];\n    const shoeTip: Point = offsetPoint(shoeTipPoint, shoeTipNormal, width + casingRadius * (width < 0 ? -1 : 1));\n\n    return [...shoeEdge, shoeTip];\n  };\n\n  private createCementSqueezeShape = (\n    squeeze: CementSqueeze,\n    casings: Casing[],\n    completion: Completion[],\n    holes: HoleSize[],\n  ): ComplexRopeSegment[] => {\n    const { exaggerationFactor } = this.options as SchematicLayerOptions<T>;\n    return createComplexRopeSegmentsForCementSqueeze(squeeze, casings, completion, holes, exaggerationFactor, this.getZFactorScaledPathForPoints);\n  };\n\n  private getCementTexture(): Texture {\n    if (!this.cementTextureCache) {\n      const { cementOptions } = this.options as SchematicLayerOptions<T>;\n      this.cementTextureCache = createCementTexture(cementOptions);\n    }\n    return this.cementTextureCache;\n  }\n\n  private createPerforationShape = (perforation: Perforation, casings: Casing[], holes: HoleSize[]): PerforationShape[] => {\n    const { exaggerationFactor } = this.options as SchematicLayerOptions<T>;\n    return createComplexRopeSegmentsForPerforation(perforation, casings, holes, exaggerationFactor, this.getZFactorScaledPathForPoints);\n  };\n\n  private getCementSqueezeTexture(): Texture {\n    if (!this.cementSqueezeTextureCache) {\n      const { cementSqueezeOptions } = this.options as SchematicLayerOptions<T>;\n      this.cementSqueezeTextureCache = createCementSqueezeTexture(cementSqueezeOptions);\n    }\n    return this.cementSqueezeTextureCache;\n  }\n\n  private drawScreen({ start, end, diameter }: Screen): void {\n    const { exaggerationFactor, screenOptions } = this.options as SchematicLayerOptions<T>;\n    const exaggeratedDiameter = exaggerationFactor * diameter;\n\n    const pathPoints = this.getZFactorScaledPathForPoints(start, end);\n    const { leftPath, rightPath } = createTubularRenderingObject(exaggeratedDiameter / 2, pathPoints);\n    const polygon = makeTubularPolygon(leftPath, rightPath);\n\n    const texture = this.getScreenTexture();\n    if (this.renderType() === RENDERER_TYPE.CANVAS) {\n      this.drawBigTexturedPolygon(polygon, texture);\n    } else {\n      this.drawCompletionRope(pathPoints, texture, exaggeratedDiameter);\n    }\n    this.drawOutline(leftPath, rightPath, convertColor(screenOptions.lineColor), SCREEN_OUTLINE * exaggerationFactor, 'TopAndBottom');\n  }\n\n  private drawTubing({ diameter, start, end }: Tubing): void {\n    const { exaggerationFactor, tubingOptions } = this.options as SchematicLayerOptions<T>;\n    const exaggeratedDiameter = exaggerationFactor * diameter;\n\n    const pathPoints = this.getZFactorScaledPathForPoints(start, end);\n    const { leftPath, rightPath } = createTubularRenderingObject(exaggeratedDiameter / 2, pathPoints);\n    const polygon = makeTubularPolygon(leftPath, rightPath);\n\n    const texture = this.getTubingTexture(tubingOptions);\n    if (this.renderType() === RENDERER_TYPE.CANVAS) {\n      this.drawBigTexturedPolygon(polygon, texture);\n    } else {\n      this.drawCompletionRope(pathPoints, texture, exaggeratedDiameter);\n    }\n  }\n\n  private getTubingTexture(tubingOptions: TubingOptions): Texture {\n    if (!this.tubingTextureCache) {\n      this.tubingTextureCache = createTubingTexture(tubingOptions);\n    }\n    return this.tubingTextureCache;\n  }\n\n  private getScreenTexture(): Texture {\n    if (!this.screenTextureCache) {\n      const { screenOptions } = this.options as SchematicLayerOptions<T>;\n      this.screenTextureCache = createScreenTexture(screenOptions);\n    }\n    return this.screenTextureCache;\n  }\n\n  private drawCompletionRope(path: Point[], texture: Texture, diameter: number): void {\n    if (path.length === 0) {\n      return;\n    }\n\n    const rope: FixedWidthSimpleRope = new FixedWidthSimpleRope(texture, path, diameter);\n    this.addChild(rope);\n  }\n}\n"],"names":["max","values","valueof","value","index","sum","RopeGeometry","MeshGeometry","width","points","textureScale","vertexBuffer","uvBuffer","indexBuffer","uvs","indices","amount","prev","textureWidth","total","i","dx","dy","distance","indexCount","lastPoint","nextPoint","perpX","perpY","vertices","point","perpLength","num","SimpleRope","Mesh","texture","ropeGeometry","meshMaterial","MeshMaterial","WRAP_MODES","renderer","geometry","assertNever","x","isPAndASymbol","item","isCementSqueeze","isCementPlug","foldCompletion","fScreen","fTubing","fSymbol","completion","foldPerforationSubKind","options","subKind","hasPacking","perf","hasFracLines","hasSpikes","isSubkindCasedHoleGravelPack","isSubKindCasedHoleFracPack","intersect","b","defaultInternalLayerOptions","layerId","defaultHoleOptions","defaultCasingOptions","SHOE_WIDTH","SHOE_LENGTH","defaultPerforationOptions","defaultCementOptions","defaultCementSqueezeOptions","defaultScreenOptions","defaultTubingOptions","defaultCementPlugOptions","dashLineOptionsDefault","_DashLine","graphics","__publicField","PIXI.Point","a","x1","y1","x2","y2","y","closePath","length","angle","closed","gap","cos","sin","x0","y0","place","dashIndex","dashStart","dashX","dashSize","remaining","dist","lastDash","radius","matrix","interval","first","next","radiusX","radiusY","p","height","lineStyle","PIXI.Matrix","textureStart","key","canvas","context","PIXI.Texture","PIXI.SCALE_MODES","DashLine","pointToVector","Vector2","vectorToPoint","v","Point","createNormals","_coord","list","offsetPoint","vector","offset","offsetPoints","vectors","makeTubularPolygon","rightPath","leftPath","d","overlaps","top1","bottom1","top2","bottom2","strictlyOverlaps","uniq","arr","findIntersectingItems","start","end","otherStrings","holes","overlappingHoles","hole","overlappingOuterStrings","casing","getUniqueDiameterChangeDepths","intervalStart","intervalEnd","diameterIntervals","trimmedChangedDepths","getInnerStringDiameter","stringType","findCementOuterDiameterAtDepth","attachedStrings","nonAttachedStrings","depth","attachedStringAtDepth","casingOrCompletion","attachedOuterDiameter","outerCasingAtDepth","holeAtDepth","findPerforationOuterDiameterAtDepth","perforationSubKind","findCementPlugInnerDiameterAtDepth","minimumDiameter","c","nonAttachedStringAtDepth","createComplexRopeSegmentsForCement","cement","casings","exaggerationFactor","getPoints","splitByReferencedStrings","bottomOfCement","outerDiameterIntervals","nextDepth","diameterAtChangeDepth","referenceIds","acc","current","createComplexRopeSegmentsForCementSqueeze","squeeze","diameterAtDepth","createComplexRopeSegmentsForCementPlug","plug","innerDiameterIntervals","createGradientFill","canvasCtx","firstColor","secondColor","startPctOffset","gradient","createHoleBaseTexture","Texture","createScreenTexture","scalingFactor","size","DEFAULT_TEXTURE_SIZE","baseLineWidth","distanceBetweenLines","createTubingTexture","innerColor","outerColor","innerColorStart","innerColorEnd","createCementTexture","lineWidth","createCementPlugTexture","createCementSqueezeTexture","createTubularRenderingObject","pathPoints","normals","createCasingInterval","createCasingWindowInterval","getCasingIntervalsWithWindows","result","cw","intervals","lastBottom","currentWindow","startCasingInterval","updatedLastBottom","windowStart","windowEnd","windowInterval","nextLastBottom","endCasingInterval","newIntervals","prepareCasingRenderObject","getPathPoints","exaggeratedDiameter","exaggeratedRadius","exaggeratedInnerRadius","casingWallWidth","sections","casingInterval","createComplexRopeSegmentsForPerforation","perforation","drawPacking","ctx","perforationOptions","packingOpacity","yellow","xy","wh","drawFracLines","extendedPerfShapeDiameter","startAt","fracLineCurve","amountOfSpikes","spikeWidth","diameter","fracLineLength","spikeLength","offsetX","offsetY","fracLines","bottom","controlPoint1","middle","controlPoint2","drawSpikes","left","right","errorTexture","errorMessage","existingContext","Rectangle","groupD8","createPerforationCanvas","perfShape","createPerforationTexture","createSubkindPerforationTexture","otherPerforations","intersectionsWithCasedHoleGravel","intersectionsWithCasedHoleFracPack","createSubkindCasedHoleFracturationTexture","createSubkindCasedHoleFracPackTexture","createSubkindCasedHoleGravelPackTexture","createSubkindOpenHoleGravelPackTexture","createSubkindOpenHoleFracPackTexture","_perforation","createPerforationPackingTexture","createPerforationFracLineTexture","createPerforationSpikeTexture","ComplexRopeGeometry","segments","pointCount","segment","segmentCount","maxDiameter","uvIndex","indicesIndex","j","lastIndex","ComplexRope","FixedWidthSimpleRopeGeometry","FixedWidthSimpleRope","UniformTextureStretchRopeGeometry","totalLength","prevPoint","UniformTextureStretchRope","foldInterlacedRenderObjects","fCasing","fCement","fCementSqueeze","renderObject","defaultSchematicLayerOptions","_SchematicLayer","PixiLayer","id","scaleLinear","coords","color","polygon","Graphics","component","referenceDiameter","symbolKey","maxHoleDiameter","holeObject","holeOptions","RENDERER_TYPE","polygonCoords","convertColor","HOLE_OUTLINE","casingRenderObject","casingOptions","casingSolidColorNumber","casingLineColorNumber","section","outlineClosureType","casingEnd","casingRadius","normal","shoeEdge","shoeTipPoint","shoeTipNormal","shoeTip","event","shouldRecalculate","yRatio","flippedX","flippedY","isVisible","internalLayerOptions","keyFound","_key","domain","baseYSpan","baseDomain","path","tint","rope","lineColor","outlineClosure","lineAlignment","leftPathReverse","startPointRight","startPointLeft","line","windowOptions","flippedPaths","_b","_a","linePath","dashedPath","dashedAlignment","solidAlignment","startPointLinePath","dashedLine","startPointDashedPath","currentPoint","holeSizes","cements","symbols","pAndA","perforations","EXAGGERATED_DIAMETER","casingRenderObjects","cementShapes","cementSqueezes","remainingPAndA","squeezes","cementSqueezesShape","casingRO","cementRO","cementSqueezesRO","packings","spikes","perfShapesByDiameter","dict","ps","perfShapesWithSameDiameter","obj","symbolRenderObject","existingKeys","symbol","cementPlug","cementPlugOptions","cementPlugSegments","textureDiameter","baseTexture","sidePadding","frame","cementRenderObject","zIndex","foundCementShape","foundCementSqueezes","shoeWidth","shoeLength","shoeCoords","shoeCoords2","cementOptions","cementSqueezeOptions","screenOptions","SCREEN_OUTLINE","tubingOptions","SchematicLayer","maxIndex"],"mappings":"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"}