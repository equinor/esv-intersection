{"version":3,"file":"GeomodelLayerV2.6dc21a8a.js","sources":["../../../../src/layers/GeomodelLabelsLayer.ts","../../../../src/layers/GeomodelLayerV2.ts"],"sourcesContent":["import Vector2 from '@equinor/videx-vector2';\nimport { clamp } from '@equinor/videx-math';\n\nimport { CanvasLayer } from './base/CanvasLayer';\nimport { OnUpdateEvent, OnRescaleEvent, OnMountEvent } from '../interfaces';\nimport { SurfaceArea, SurfaceLine, findSampleAtPos, SurfaceData } from '../datautils';\nimport { SURFACE_LINE_WIDTH } from '../constants';\nimport { LayerOptions } from './base/Layer';\n\nconst DEFAULT_MARGINS = 18;\nconst DEFAULT_MIN_FONT_SIZE = 8;\nconst DEFAULT_MAX_FONT_SIZE = 13;\nconst DEFAULT_TEXT_COLOR = 'black';\nconst DEFAULT_FONT = 'Arial';\nconst MAX_FONT_SIZE_IN_WORLD_COORDINATES = 70;\n\nexport interface GeomodelLayerLabelsOptions<T extends SurfaceData> extends LayerOptions<T> {\n  margins?: number;\n  minFontSize?: number;\n  maxFontSize?: number;\n  textColor?: string;\n  font?: string;\n}\n\ninterface SurfaceAreaWithAvgTopDepth extends SurfaceArea {\n  avgTopDepth: number;\n}\n\nexport class GeomodelLabelsLayer<T extends SurfaceData> extends CanvasLayer<T> {\n  defaultMargins: number = DEFAULT_MARGINS;\n  defaultMinFontSize: number = DEFAULT_MIN_FONT_SIZE;\n  defaultMaxFontSize: number = DEFAULT_MAX_FONT_SIZE;\n  defaultTextColor: string = DEFAULT_TEXT_COLOR;\n  defaultFont: string = DEFAULT_FONT;\n\n  rescaleEvent: OnRescaleEvent;\n  isLabelsOnLeftSide: boolean = true;\n  maxFontSizeInWorldCoordinates: number = MAX_FONT_SIZE_IN_WORLD_COORDINATES;\n  isXFlipped: boolean = false;\n  areasWithAvgTopDepth: SurfaceAreaWithAvgTopDepth[] = null;\n\n  constructor(id?: string, options?: GeomodelLayerLabelsOptions<T>) {\n    super(id, options);\n    this.render = this.render.bind(this);\n    this.getMarginsInWorldCoordinates = this.getMarginsInWorldCoordinates.bind(this);\n    this.getSurfacesAreaEdges = this.getSurfacesAreaEdges.bind(this);\n    this.updateXFlipped = this.updateXFlipped.bind(this);\n    this.generateSurfacesWithAvgDepth = this.generateSurfacesWithAvgDepth.bind(this);\n  }\n\n  get options(): GeomodelLayerLabelsOptions<T> {\n    return this._options;\n  }\n\n  setData(data: T): void {\n    super.setData(data);\n    this.areasWithAvgTopDepth = null;\n  }\n\n  generateSurfacesWithAvgDepth(): void {\n    const { areas } = this.data;\n    this.areasWithAvgTopDepth = areas.reduce((acc: SurfaceAreaWithAvgTopDepth[], area: SurfaceArea) => {\n      // Filter surfaces without label\n      if (!area.label) {\n        return acc;\n      }\n      const sumAndCount = area.data.reduce(\n        (a: { sum: number; count: number }, d: number[]) => {\n          if (d[1] != null) {\n            a.sum += d[1];\n            a.count++;\n          }\n          return a;\n        },\n        {\n          sum: 0,\n          count: 0,\n        },\n      );\n      if (sumAndCount.count === 0) {\n        return acc;\n      }\n      const avgTopDepth = sumAndCount.sum / sumAndCount.count;\n\n      acc.push({\n        ...area,\n        avgTopDepth,\n      });\n      return acc;\n    }, []);\n  }\n\n  onMount(event: OnMountEvent): void {\n    super.onMount(event);\n  }\n\n  onUpdate(event: OnUpdateEvent<T>): void {\n    super.onUpdate(event);\n    this.render();\n  }\n\n  onRescale(event: OnRescaleEvent): void {\n    this.rescaleEvent = event;\n    this.updateXFlipped();\n    this.resetTransform();\n    this.render();\n  }\n\n  render(): void {\n    if (!this.rescaleEvent) {\n      return;\n    }\n\n    requestAnimationFrame(() => {\n      this.clearCanvas();\n\n      if (!this.data) {\n        return;\n      }\n\n      if (!this.areasWithAvgTopDepth) {\n        this.generateSurfacesWithAvgDepth();\n      }\n\n      this.drawAreaLabels();\n      this.drawLineLabels();\n    });\n  }\n\n  drawAreaLabels(): void {\n    this.areasWithAvgTopDepth.forEach((s: SurfaceAreaWithAvgTopDepth, i: number, array: SurfaceAreaWithAvgTopDepth[]) => {\n      const topmostSurfaceNotDrawnYet = array.reduce((acc: SurfaceAreaWithAvgTopDepth | null, v, index): SurfaceAreaWithAvgTopDepth | null => {\n        if (index > i) {\n          if (acc == null) {\n            acc = v;\n          } else {\n            if (v.avgTopDepth < acc.avgTopDepth) {\n              acc = v;\n            }\n          }\n        }\n        return acc;\n      }, null);\n\n      if (!topmostSurfaceNotDrawnYet) {\n        return;\n      }\n\n      this.drawAreaLabel(s, topmostSurfaceNotDrawnYet, array, i);\n    });\n  }\n\n  drawLineLabels(): void {\n    this.data.lines.filter((surfaceLine: SurfaceLine) => surfaceLine.label).forEach((surfaceLine: SurfaceLine) => this.drawLineLabel(surfaceLine));\n  }\n\n  drawAreaLabel = (surfaceArea: SurfaceArea, nextSurfaceArea: SurfaceArea, surfaces: SurfaceArea[], i: number): void => {\n    const { data } = surfaceArea;\n    const { ctx, maxFontSizeInWorldCoordinates, isXFlipped } = this;\n    const { xScale, yScale, xRatio, yRatio, zFactor } = this.rescaleEvent;\n    let isLabelsOnLeftSide = this.checkDrawLabelsOnLeftSide();\n    const margins = (this.options.margins || this.defaultMargins) * (isXFlipped ? -1 : 1);\n    const marginsInWorldCoords = margins / xRatio;\n    const minFontSize = this.options.minFontSize || this.defaultMinFontSize;\n    const maxFontSize = this.options.maxFontSize || this.defaultMaxFontSize;\n\n    let fontSizeInWorldCoords = maxFontSize / yRatio;\n    if (fontSizeInWorldCoords > maxFontSizeInWorldCoordinates) {\n      fontSizeInWorldCoords = maxFontSizeInWorldCoordinates;\n      if (fontSizeInWorldCoords * yRatio < minFontSize) {\n        fontSizeInWorldCoords = minFontSize / yRatio;\n      }\n    }\n\n    const leftEdge = xScale.invert(xScale.range()[0]) + marginsInWorldCoords;\n    const rightEdge = xScale.invert(xScale.range()[1]) - marginsInWorldCoords;\n    const [surfaceAreaLeftEdge, surfaceAreaRightEdge] = this.getSurfacesAreaEdges();\n\n    // Get label metrics\n    ctx.save();\n    ctx.font = `${fontSizeInWorldCoords * yRatio}px ${this.options.font || this.defaultFont}`;\n    let labelMetrics = ctx.measureText(surfaceArea.label);\n    let labelLengthInWorldCoords = labelMetrics.width / xRatio;\n\n    // Check if label will fit horizontally\n    if (isLabelsOnLeftSide) {\n      const labelRightEdge = leftEdge + (isXFlipped ? -labelLengthInWorldCoords : labelLengthInWorldCoords);\n      if ((!isXFlipped && labelRightEdge > surfaceAreaRightEdge) || (isXFlipped && labelRightEdge < surfaceAreaRightEdge)) {\n        isLabelsOnLeftSide = false;\n      }\n    } else {\n      const labelLeftEdge = rightEdge + (isXFlipped ? labelLengthInWorldCoords : -labelLengthInWorldCoords);\n      if ((!isXFlipped && labelLeftEdge < surfaceAreaLeftEdge) || (isXFlipped && labelLeftEdge > surfaceAreaLeftEdge)) {\n        isLabelsOnLeftSide = true;\n      }\n    }\n\n    // Find edge where to draw\n    let startPos;\n    const portionOfLabelLengthUsedForPosCalc = 0.07;\n    if (isLabelsOnLeftSide) {\n      startPos = isXFlipped ? Math.min(surfaceAreaLeftEdge, leftEdge) : Math.max(surfaceAreaLeftEdge, leftEdge);\n    } else {\n      startPos = isXFlipped ? Math.max(surfaceAreaRightEdge, rightEdge) : Math.min(surfaceAreaRightEdge, rightEdge);\n    }\n\n    const topEdge = yScale.invert(yScale.range()[0]);\n    const bottomEdge = yScale.invert(yScale.range()[1]);\n\n    // Calculate where to sample points\n    const dirSteps = 5;\n    const posSteps = 3;\n    const posStep =\n      portionOfLabelLengthUsedForPosCalc * (labelLengthInWorldCoords / posSteps) * (isLabelsOnLeftSide ? 1 : -1) * (isXFlipped ? -1 : 1);\n    const dirStep = (labelLengthInWorldCoords / dirSteps) * (isLabelsOnLeftSide ? 1 : -1) * (isXFlipped ? -1 : 1);\n\n    // Sample points from top and calculate position\n    const topData = data.map((d) => [d[0], d[1]]);\n    const topPos = this.calcPos(topData, startPos, posSteps, posStep, topEdge, bottomEdge);\n    if (!topPos) {\n      return;\n    }\n\n    // Sample points from bottom and calculate position\n    const bottomData = data.map((d) => [d[0], d[2]]);\n    let bottomPos = this.calcPos(\n      bottomData,\n      startPos,\n      posSteps,\n      posStep,\n      topEdge,\n      bottomEdge,\n      nextSurfaceArea ? nextSurfaceArea.data.map((d) => [d[0], d[1]]) : null,\n      surfaces,\n      i,\n    );\n    if (!bottomPos) {\n      bottomPos = new Vector2(topPos.x, bottomEdge);\n    }\n\n    // Check if there is enough height for label\n    const thickness = bottomPos.y - topPos.y;\n    if (thickness < fontSizeInWorldCoords) {\n      // Check minimum fontsize\n      if (thickness * yRatio < minFontSize) {\n        return;\n      }\n      // Use reduced fontsize\n      fontSizeInWorldCoords = thickness;\n      ctx.font = `${fontSizeInWorldCoords * yRatio}px ${this.options.font || this.defaultFont}`;\n      labelMetrics = ctx.measureText(surfaceArea.label);\n      labelLengthInWorldCoords = labelMetrics.width / xRatio;\n    }\n    // Sample points from top and bottom and calculate direction vector\n    const initialDirVec = isLabelsOnLeftSide !== isXFlipped ? Vector2.right : Vector2.left;\n    const areaDir = this.calcAreaDir(\n      topData,\n      bottomData,\n      startPos,\n      dirSteps,\n      dirStep,\n      initialDirVec,\n      topEdge,\n      bottomEdge,\n      0,\n      Math.PI / 4,\n      4,\n      nextSurfaceArea ? nextSurfaceArea.data.map((d) => [d[0], d[1]]) : null,\n      surfaces,\n      i,\n    );\n    const scaledAngle = Math.atan(Math.tan(areaDir) * zFactor);\n\n    // Draw label\n    const textX = startPos;\n    const textY = (topPos.y + bottomPos.y) / 2;\n    const textAngle = isXFlipped ? -scaledAngle : scaledAngle;\n    ctx.textAlign = isLabelsOnLeftSide ? 'left' : 'right';\n    ctx.translate(xScale(textX), yScale(textY));\n    ctx.rotate(textAngle);\n    ctx.fillStyle = this.options.textColor || this.defaultTextColor;\n    ctx.font = `${fontSizeInWorldCoords * yRatio}px ${this.options.font || this.defaultFont}`;\n    ctx.textBaseline = 'middle';\n    ctx.fillText(surfaceArea.label, 0, 0);\n\n    ctx.restore();\n  };\n\n  drawLineLabel = (s: SurfaceLine): void => {\n    const { ctx, isXFlipped } = this;\n    const { xScale, yScale, xRatio, yRatio, zFactor } = this.rescaleEvent;\n    const isLabelsOnLeftSide = this.checkDrawLabelsOnLeftSide();\n    const marginsInWorldCoords = this.getMarginsInWorldCoordinates();\n    const maxFontSize = this.options.maxFontSize || this.defaultMaxFontSize;\n\n    const fontSizeInWorldCoords = maxFontSize / yRatio;\n\n    ctx.save();\n    ctx.font = `${fontSizeInWorldCoords * yRatio}px ${this.options.font || this.defaultFont}`;\n    const labelMetrics = ctx.measureText(s.label);\n    const labelLengthInWorldCoords = labelMetrics.width / xRatio;\n\n    const leftEdge = xScale.invert(xScale.range()[0]) + marginsInWorldCoords;\n    const rightEdge = xScale.invert(xScale.range()[1]) - marginsInWorldCoords;\n    const [surfaceAreaLeftEdge, surfaceAreaRightEdge] = this.getSurfacesAreaEdges();\n\n    // Find edge where to draw\n    let startPos;\n    const steps = 5;\n    if (isLabelsOnLeftSide) {\n      startPos = isXFlipped ? Math.max(surfaceAreaRightEdge, rightEdge) : Math.min(surfaceAreaRightEdge, rightEdge);\n    } else {\n      startPos = isXFlipped ? Math.min(surfaceAreaLeftEdge, leftEdge) : Math.max(surfaceAreaLeftEdge, leftEdge);\n    }\n\n    // Calculate where to sample points\n    const step = (labelLengthInWorldCoords / steps) * (isLabelsOnLeftSide ? -1 : 1);\n\n    // Sample points and calculate position and direction vector\n    const { data } = s;\n    const pos = this.calcPos(data, startPos, steps, step);\n    const dir = this.calcLineDir(data, startPos, steps, step, zFactor, isLabelsOnLeftSide ? Vector2.left : Vector2.right);\n    if (!pos || !dir) {\n      return;\n    }\n\n    // Calculate position and direction for label\n    const textX = startPos;\n    const textY = pos.y - SURFACE_LINE_WIDTH - fontSizeInWorldCoords / 2;\n    const textDir = Vector2.angleRight(dir) - (isLabelsOnLeftSide ? Math.PI : 0);\n\n    // Draw label\n    ctx.textAlign = isLabelsOnLeftSide ? 'right' : 'left';\n    ctx.translate(xScale(textX), yScale(textY));\n    ctx.rotate(textDir);\n    ctx.fillStyle = this.colorToCSSColor(s.color);\n    ctx.textBaseline = 'middle';\n    ctx.fillText(s.label, 0, 0);\n\n    ctx.restore();\n  };\n\n  colorToCSSColor(color: number | string): string {\n    if (typeof color === 'string') {\n      return color;\n    }\n\n    let hexString = color.toString(16);\n    // eslint-disable-next-line no-magic-numbers\n    hexString = '000000'.substr(0, 6 - hexString.length) + hexString;\n    return `#${hexString}`;\n  }\n\n  calcPos(\n    data: number[][],\n    offset: number,\n    count: number,\n    step: number,\n    topLimit: number = null,\n    bottomLimit: number = null,\n    alternativeSurfaceData: number[][] = null,\n    surfaces: SurfaceArea[] | null = null,\n    currentSurfaceIndex: number = null,\n  ): Vector2 {\n    const pos = Vector2.zero.mutable;\n    let samples = 0;\n    for (let i = 0; i < count; i++) {\n      const x = offset + i * step;\n      const y = findSampleAtPos(data, x, topLimit, bottomLimit);\n      if (y) {\n        const alternativeY = this.getAlternativeYValueIfAvailable(x, topLimit, bottomLimit, alternativeSurfaceData, surfaces, currentSurfaceIndex);\n        // Use topmost of value from current surface and alternative surface\n        const usedY = alternativeY ? Math.min(y, alternativeY) : y;\n        pos.add(x, usedY);\n        samples++;\n      }\n    }\n\n    if (samples === 0) {\n      return null;\n    }\n\n    return Vector2.divide(pos, samples);\n  }\n\n  getAlternativeYValueIfAvailable(\n    x: number,\n    topLimit: number,\n    bottomLimit: number,\n    alternativeSurfaceData: number[][],\n    surfaces: SurfaceArea[] | null,\n    currentSurfaceIndex: number,\n  ): number {\n    if (!alternativeSurfaceData) {\n      return null;\n    }\n    // Find sample from passed in surface data\n    let altY = findSampleAtPos(alternativeSurfaceData, x, topLimit, bottomLimit);\n    if (altY == null && surfaces && currentSurfaceIndex != null) {\n      //Find topmost surface after current which gives us data\n      let si = currentSurfaceIndex + 1;\n      while (altY == null && si < surfaces.length) {\n        const altSurface = surfaces[si++];\n        altY = findSampleAtPos(\n          altSurface.data.map((d: number[]) => [d[0], d[1]]),\n          x,\n          topLimit,\n          bottomLimit,\n        );\n      }\n    }\n    return altY;\n  }\n\n  calcLineDir(\n    data: number[][],\n    offset: number,\n    count: number,\n    step: number,\n    zFactor: number,\n    initalVector: Vector2 = Vector2.left,\n    topLimit: number = null,\n    bottomLimit: number = null,\n  ): Vector2 {\n    const dir = initalVector.mutable;\n\n    const startY = findSampleAtPos(data, offset, topLimit, bottomLimit);\n    if (startY === null) {\n      return dir;\n    }\n\n    const vecAtEnd = new Vector2(offset, startY * zFactor);\n    const tmpVec = Vector2.zero.mutable;\n    for (let i = 1; i <= count; i++) {\n      const x = offset + i * step;\n      const y = findSampleAtPos(data, offset, topLimit, bottomLimit);\n      if (y !== null) {\n        tmpVec.set(x, y * zFactor);\n        tmpVec.sub(vecAtEnd);\n        dir.add(tmpVec);\n      }\n    }\n\n    return dir;\n  }\n\n  calcAreaDir(\n    top: number[][],\n    bottom: number[][],\n    offset: number,\n    count: number,\n    step: number,\n    initalVector: Vector2 = Vector2.left,\n    topLimit: number = null,\n    bottomLimit: number = null,\n    minReductionAngle: number = 0,\n    maxReductionAngle: number = Math.PI / 4,\n    angleReductionExponent: number = 4,\n    alternativeSurfaceBottomData: number[][] = null,\n    surfaces: SurfaceArea[] | null = null,\n    currentSurfaceIndex: number = null,\n  ): number {\n    const angles: number[] = [];\n    const tmpVec = Vector2.zero.mutable;\n    let vecAtEnd;\n    for (let i = 0; i <= count; i++) {\n      const x = offset + i * step;\n      const topY = findSampleAtPos(top, x, topLimit, bottomLimit);\n      const bottomY = findSampleAtPos(bottom, x, topLimit, bottomLimit) || bottomLimit;\n      // Find position of next surface in case it's higher than current base\n      const alternativeBottomY = this.getAlternativeYValueIfAvailable(\n        x,\n        topLimit,\n        bottomLimit,\n        alternativeSurfaceBottomData,\n        surfaces,\n        currentSurfaceIndex,\n      );\n      // Use topmost of value from current surface and alternative surface\n      const usedBottomY = alternativeBottomY ? Math.min(bottomY, alternativeBottomY) : bottomY;\n      if (i === 0) {\n        if (topY === null) {\n          return Vector2.angleRight(initalVector);\n        }\n        const startY = (topY + usedBottomY) / 2;\n        vecAtEnd = new Vector2(offset, startY);\n      } else {\n        if (topY !== null) {\n          tmpVec.set(x, (topY + usedBottomY) / 2);\n          tmpVec.sub(vecAtEnd);\n\n          angles.push(Vector2.angleRight(tmpVec));\n        } else {\n          angles.push(Vector2.angleRight(initalVector));\n        }\n      }\n    }\n\n    const refAngle = angles[0];\n    const offsetAngles = angles.map((d: number) => d - refAngle);\n    let factors = 0;\n    const offsetSum = offsetAngles.reduce((acc: number, v: number) => {\n      const ratio = (Math.abs(v) - minReductionAngle) / maxReductionAngle;\n      const factor = Math.pow(1 - clamp(ratio, 0, 1), angleReductionExponent);\n      factors += factor;\n      return acc + v * factor;\n    }, 0);\n    const angle = offsetSum / factors + refAngle;\n    return angle;\n  }\n\n  updateXFlipped(): void {\n    const { xBounds } = this.rescaleEvent;\n    this.isXFlipped = xBounds[0] > xBounds[1];\n  }\n\n  getMarginsInWorldCoordinates(): number {\n    const { xRatio } = this.rescaleEvent;\n    const margins = (this.options.margins || this.defaultMargins) * (this.isXFlipped ? -1 : 1);\n    const marginsInWorldCoords = margins / xRatio;\n    return marginsInWorldCoords;\n  }\n\n  getSurfacesAreaEdges(): number[] {\n    const endPoints = this.data.areas.reduce((acc, area) => {\n      const { data } = area;\n      const firstValidPoint = data.find((d: number[]) => d[1] != null);\n      if (firstValidPoint) {\n        acc.push(firstValidPoint[0]);\n      }\n      // TODO: Use findLast() when TypeScript stops complaining about it\n      for (let i = data.length - 1; i >= 0; i--) {\n        if (data[i][1] != null) {\n          acc.push(data[i][0]);\n          break;\n        }\n      }\n\n      return acc;\n    }, []);\n    endPoints.push(\n      ...this.data.lines.reduce((acc, line) => {\n        const { data } = line;\n        const firstValidPoint = data.find((d: number[]) => d[1] != null);\n        if (firstValidPoint) {\n          acc.push(firstValidPoint[0]);\n        }\n        // TODO: Use findLast() when TypeScript stops complaining about it\n        for (let i = data.length - 1; i >= 0; i--) {\n          if (data[i][1] != null) {\n            acc.push(data[i][0]);\n            break;\n          }\n        }\n        return acc;\n      }, []),\n    );\n\n    const minX = Math.min(...endPoints);\n    const maxX = Math.max(...endPoints);\n    const marginsInWorldCoords = this.getMarginsInWorldCoordinates();\n    const { isXFlipped } = this;\n    const surfaceAreaLeftEdge = isXFlipped ? maxX + marginsInWorldCoords : minX + marginsInWorldCoords;\n    const surfaceAreaRightEdge = isXFlipped ? minX - marginsInWorldCoords : maxX - marginsInWorldCoords;\n    return [surfaceAreaLeftEdge, surfaceAreaRightEdge];\n  }\n\n  checkDrawLabelsOnLeftSide(): boolean {\n    const { referenceSystem, isXFlipped } = this;\n    if (!referenceSystem) {\n      return true;\n    }\n\n    const { xScale, yScale, xRatio } = this.rescaleEvent;\n    const t = 200; // TODO: Use actual size of largest label or average size of all\n\n    const [dx1, dx2] = xScale.domain();\n    const [dy1, dy2] = yScale.domain();\n\n    let top = referenceSystem.interpolators.curtain.lookup(dy1, 1, 0) as number[][];\n    if (top.length === 0) {\n      top = [referenceSystem.interpolators.curtain.getPointAt(0.0) as number[]];\n    }\n    let bottom = referenceSystem.interpolators.curtain.lookup(dy2, 1, 0) as number[][];\n    if (bottom.length === 0) {\n      bottom = [referenceSystem.interpolators.curtain.getPointAt(1.0) as number[]];\n    }\n\n    const maxX = Math.max(top[0][0], bottom[0][0]);\n    const minX = Math.min(top[0][0], bottom[0][0]);\n\n    const wbBBox = {\n      left: isXFlipped ? maxX : minX,\n      right: isXFlipped ? minX : maxX,\n    };\n\n    const margin = this.getMarginsInWorldCoordinates();\n    const screenLeftEdge = dx1 + margin;\n    const screenRightEdge = dx2 - margin;\n\n    const [surfaceAreaLeftEdge, surfaceAreaRightEdge] = this.getSurfacesAreaEdges();\n\n    const leftLimit = isXFlipped ? Math.min(screenLeftEdge, surfaceAreaLeftEdge) : Math.max(screenLeftEdge, surfaceAreaLeftEdge);\n    const rightLimit = isXFlipped ? Math.max(screenRightEdge, surfaceAreaRightEdge) : Math.min(screenRightEdge, surfaceAreaRightEdge);\n\n    const spaceOnLeftSide = Math.max(isXFlipped ? leftLimit - wbBBox.left : wbBBox.left - leftLimit, 0);\n    const spaceOnRightSide = Math.max(isXFlipped ? wbBBox.right - rightLimit : rightLimit - wbBBox.right, 0);\n\n    const spaceOnLeftSideInScreenCoordinates = spaceOnLeftSide * xRatio;\n    const spaceOnRightSideInScreenCoordinates = spaceOnRightSide * xRatio;\n    const isLabelsOnLeftSide =\n      spaceOnLeftSide > spaceOnRightSide ||\n      spaceOnLeftSideInScreenCoordinates > t ||\n      (spaceOnLeftSideInScreenCoordinates < t && spaceOnRightSideInScreenCoordinates < t && isXFlipped) ||\n      bottom[0][1] < dy1;\n\n    return isLabelsOnLeftSide;\n  }\n}\n","import { Graphics } from 'pixi.js';\nimport { PixiLayer } from './base/PixiLayer';\nimport { OnUpdateEvent, OnRescaleEvent } from '../interfaces';\nimport { SurfaceArea, SurfaceData, SurfaceLine } from '../datautils';\nimport { SURFACE_LINE_WIDTH } from '../constants';\n\nconst DEFAULT_Y_BOTTOM = 10000;\n\nexport class GeomodelLayerV2<T extends SurfaceData> extends PixiLayer<T> {\n  private isPreRendered: boolean = false;\n\n  onRescale(event: OnRescaleEvent): void {\n    super.onRescale(event);\n\n    if (!this.isPreRendered) {\n      this.clearLayer();\n      this.preRender();\n    }\n\n    this.render();\n  }\n\n  onUpdate(event: OnUpdateEvent<T>): void {\n    super.onUpdate(event);\n\n    this.isPreRendered = false;\n    this.clearLayer();\n    this.preRender();\n    this.render();\n  }\n\n  preRender(): void {\n    const { data }: { data: SurfaceData } = this;\n\n    if (!data) {\n      return;\n    }\n\n    data.areas.forEach((a: SurfaceArea) => this.generateAreaPolygon(a));\n    data.lines.forEach((l: SurfaceLine) => this.generateSurfaceLine(l));\n\n    this.isPreRendered = true;\n  }\n\n  createPolygons = (data: number[][]): number[][] => {\n    const polygons: number[][] = [];\n    let polygon: number[] = null;\n\n    // Start generating polygons\n    for (let i = 0; i < data.length; i++) {\n      // Generate top of polygon as long as we have valid values\n      const topIsValid = !!data[i][1];\n      if (topIsValid) {\n        if (polygon === null) {\n          polygon = [];\n        }\n        polygon.push(data[i][0], data[i][1]);\n      }\n\n      const endIsReached = i === data.length - 1;\n      if (!topIsValid || endIsReached) {\n        if (polygon) {\n          // Generate bottom of polygon\n          for (let j: number = !topIsValid ? i - 1 : i; j >= 0; j--) {\n            if (!data[j][1]) {\n              break;\n            }\n            polygon.push(data[j][0], data[j][2] || DEFAULT_Y_BOTTOM);\n          }\n          polygons.push(polygon);\n          polygon = null;\n        }\n      }\n    }\n    return polygons;\n  };\n\n  generateAreaPolygon = (s: SurfaceArea): void => {\n    const g = new Graphics();\n    g.lineStyle(1, s.color as number, 1);\n    g.beginFill(s.color as number);\n    const polygons = this.createPolygons(s.data);\n    polygons.forEach((polygon: number[]) => g.drawPolygon(polygon));\n    g.endFill();\n    this.addChild(g);\n  };\n\n  generateSurfaceLine = (s: SurfaceLine): void => {\n    const g = new Graphics();\n    const { data: d } = s;\n\n    const alignment = 0.5;\n    g.lineStyle(SURFACE_LINE_WIDTH, s.color as number, 1, alignment, true);\n\n    let penDown = false;\n    for (let i = 0; i < d.length; i++) {\n      if (d[i][1]) {\n        if (penDown) {\n          g.lineTo(d[i][0], d[i][1]);\n        } else {\n          g.moveTo(d[i][0], d[i][1]);\n          penDown = true;\n        }\n      } else {\n        penDown = false;\n      }\n    }\n    this.addChild(g);\n  };\n}\n"],"names":["DEFAULT_MARGINS","DEFAULT_MIN_FONT_SIZE","DEFAULT_MAX_FONT_SIZE","DEFAULT_TEXT_COLOR","DEFAULT_FONT","MAX_FONT_SIZE_IN_WORLD_COORDINATES","GeomodelLabelsLayer","CanvasLayer","id","options","__publicField","surfaceArea","nextSurfaceArea","surfaces","data","ctx","maxFontSizeInWorldCoordinates","isXFlipped","xScale","yScale","xRatio","yRatio","zFactor","isLabelsOnLeftSide","marginsInWorldCoords","minFontSize","fontSizeInWorldCoords","leftEdge","rightEdge","surfaceAreaLeftEdge","surfaceAreaRightEdge","labelMetrics","labelLengthInWorldCoords","labelRightEdge","labelLeftEdge","startPos","portionOfLabelLengthUsedForPosCalc","topEdge","bottomEdge","dirSteps","posSteps","posStep","dirStep","topData","d","topPos","bottomData","bottomPos","Vector2","thickness","initialDirVec","areaDir","scaledAngle","textX","textY","textAngle","s","steps","step","pos","dir","SURFACE_LINE_WIDTH","textDir","areas","acc","area","sumAndCount","a","avgTopDepth","event","i","array","topmostSurfaceNotDrawnYet","v","index","surfaceLine","color","hexString","offset","count","topLimit","bottomLimit","alternativeSurfaceData","currentSurfaceIndex","samples","x","y","findSampleAtPos","alternativeY","usedY","altY","si","altSurface","initalVector","startY","vecAtEnd","tmpVec","top","bottom","minReductionAngle","maxReductionAngle","angleReductionExponent","alternativeSurfaceBottomData","angles","topY","bottomY","alternativeBottomY","usedBottomY","refAngle","offsetAngles","factors","ratio","factor","clamp","xBounds","endPoints","firstValidPoint","line","minX","maxX","referenceSystem","t","dx1","dx2","dy1","dy2","wbBBox","margin","screenLeftEdge","screenRightEdge","leftLimit","rightLimit","spaceOnLeftSide","spaceOnRightSide","spaceOnLeftSideInScreenCoordinates","spaceOnRightSideInScreenCoordinates","DEFAULT_Y_BOTTOM","GeomodelLayerV2","PixiLayer","polygons","polygon","topIsValid","endIsReached","j","g","Graphics","alignment","penDown","l"],"mappings":"2UASA,MAAMA,GAAkB,GAClBC,GAAwB,EACxBC,GAAwB,GACxBC,GAAqB,QACrBC,GAAe,QACfC,GAAqC,GAcpC,MAAMC,WAAmDC,EAAe,CAa7E,YAAYC,EAAaC,EAAyC,CAChE,MAAMD,EAAIC,CAAO,EAbnBC,EAAA,sBAAyBV,IACzBU,EAAA,0BAA6BT,IAC7BS,EAAA,0BAA6BR,IAC7BQ,EAAA,wBAA2BP,IAC3BO,EAAA,mBAAsBN,IAEtBM,EAAA,qBACAA,EAAA,0BAA8B,IAC9BA,EAAA,qCAAwCL,IACxCK,EAAA,kBAAsB,IACtBA,EAAA,4BAAqD,MAqHrDA,EAAA,qBAAgB,CAACC,EAA0BC,EAA8BC,EAAyB,IAAoB,CAC9G,KAAA,CAAE,KAAAC,CAAS,EAAAH,EACX,CAAE,IAAAI,EAAK,8BAAAC,EAA+B,WAAAC,CAAA,EAAe,KACrD,CAAE,OAAAC,EAAQ,OAAAC,EAAQ,OAAAC,EAAQ,OAAAC,EAAQ,QAAAC,GAAY,KAAK,aACrD,IAAAC,EAAqB,KAAK,4BAE9B,MAAMC,GADW,KAAK,QAAQ,SAAW,KAAK,iBAAmBP,EAAa,GAAK,GAC5CG,EACjCK,EAAc,KAAK,QAAQ,aAAe,KAAK,mBAGrD,IAAIC,GAFgB,KAAK,QAAQ,aAAe,KAAK,oBAEXL,EACtCK,EAAwBV,IACFU,EAAAV,EACpBU,EAAwBL,EAASI,IACnCC,EAAwBD,EAAcJ,IAI1C,MAAMM,EAAWT,EAAO,OAAOA,EAAO,QAAQ,EAAE,EAAIM,EAC9CI,EAAYV,EAAO,OAAOA,EAAO,QAAQ,EAAE,EAAIM,EAC/C,CAACK,EAAqBC,CAAoB,EAAI,KAAK,qBAAqB,EAG9Ef,EAAI,KAAK,EACTA,EAAI,KAAO,GAAGW,EAAwBL,OAAY,KAAK,QAAQ,MAAQ,KAAK,cAC5E,IAAIU,EAAehB,EAAI,YAAYJ,EAAY,KAAK,EAChDqB,EAA2BD,EAAa,MAAQX,EAGpD,GAAIG,EAAoB,CACtB,MAAMU,EAAiBN,GAAYV,EAAa,CAACe,EAA2BA,IACvE,CAACf,GAAcgB,EAAiBH,GAA0Bb,GAAcgB,EAAiBH,KACvEP,EAAA,GACvB,KACK,CACL,MAAMW,EAAgBN,GAAaX,EAAae,EAA2B,CAACA,IACvE,CAACf,GAAciB,EAAgBL,GAAyBZ,GAAciB,EAAgBL,KACpEN,EAAA,GAEzB,CAGI,IAAAY,EACJ,MAAMC,EAAqC,IACvCb,EACSY,EAAAlB,EAAa,KAAK,IAAIY,EAAqBF,CAAQ,EAAI,KAAK,IAAIE,EAAqBF,CAAQ,EAE7FQ,EAAAlB,EAAa,KAAK,IAAIa,EAAsBF,CAAS,EAAI,KAAK,IAAIE,EAAsBF,CAAS,EAG9G,MAAMS,EAAUlB,EAAO,OAAOA,EAAO,QAAQ,EAAE,EACzCmB,EAAanB,EAAO,OAAOA,EAAO,QAAQ,EAAE,EAG5CoB,EAAW,EACXC,EAAW,EACXC,EACJL,GAAsCJ,EAA2BQ,IAAajB,EAAqB,EAAI,KAAON,EAAa,GAAK,GAC5HyB,EAAWV,EAA2BO,GAAahB,EAAqB,EAAI,KAAON,EAAa,GAAK,GAGrG0B,EAAU7B,EAAK,IAAK8B,GAAM,CAACA,EAAE,GAAIA,EAAE,EAAE,CAAC,EACtCC,EAAS,KAAK,QAAQF,EAASR,EAAUK,EAAUC,EAASJ,EAASC,CAAU,EACrF,GAAI,CAACO,EACH,OAII,MAAAC,EAAahC,EAAK,IAAK8B,GAAM,CAACA,EAAE,GAAIA,EAAE,EAAE,CAAC,EAC/C,IAAIG,EAAY,KAAK,QACnBD,EACAX,EACAK,EACAC,EACAJ,EACAC,EACA1B,EAAkBA,EAAgB,KAAK,IAAKgC,GAAM,CAACA,EAAE,GAAIA,EAAE,EAAE,CAAC,EAAI,KAClE/B,EACA,CAAA,EAEGkC,IACHA,EAAY,IAAIC,EAAQH,EAAO,EAAGP,CAAU,GAIxC,MAAAW,EAAYF,EAAU,EAAIF,EAAO,EACvC,GAAII,EAAYvB,EAAuB,CAEjC,GAAAuB,EAAY5B,EAASI,EACvB,OAGsBC,EAAAuB,EACxBlC,EAAI,KAAO,GAAGW,EAAwBL,OAAY,KAAK,QAAQ,MAAQ,KAAK,cAC7DU,EAAAhB,EAAI,YAAYJ,EAAY,KAAK,EAChDqB,EAA2BD,EAAa,MAAQX,CAClD,CAEA,MAAM8B,EAAgB3B,IAAuBN,EAAa+B,EAAQ,MAAQA,EAAQ,KAC5EG,EAAU,KAAK,YACnBR,EACAG,EACAX,EACAI,EACAG,EACAQ,EACAb,EACAC,EACA,EACA,KAAK,GAAK,EACV,EACA1B,EAAkBA,EAAgB,KAAK,IAAKgC,GAAM,CAACA,EAAE,GAAIA,EAAE,EAAE,CAAC,EAAI,KAClE/B,EACA,CAAA,EAEIuC,EAAc,KAAK,KAAK,KAAK,IAAID,CAAO,EAAI7B,CAAO,EAGnD+B,EAAQlB,EACRmB,GAAST,EAAO,EAAIE,EAAU,GAAK,EACnCQ,EAAYtC,EAAa,CAACmC,EAAcA,EAC1CrC,EAAA,UAAYQ,EAAqB,OAAS,QAC9CR,EAAI,UAAUG,EAAOmC,CAAK,EAAGlC,EAAOmC,CAAK,CAAC,EAC1CvC,EAAI,OAAOwC,CAAS,EACpBxC,EAAI,UAAY,KAAK,QAAQ,WAAa,KAAK,iBAC/CA,EAAI,KAAO,GAAGW,EAAwBL,OAAY,KAAK,QAAQ,MAAQ,KAAK,cAC5EN,EAAI,aAAe,SACnBA,EAAI,SAASJ,EAAY,MAAO,EAAG,CAAC,EAEpCI,EAAI,QAAQ,CAAA,GAGdL,EAAA,qBAAiB8C,GAAyB,CAClC,KAAA,CAAE,IAAAzC,EAAK,WAAAE,CAAe,EAAA,KACtB,CAAE,OAAAC,EAAQ,OAAAC,EAAQ,OAAAC,EAAQ,OAAAC,EAAQ,QAAAC,GAAY,KAAK,aACnDC,EAAqB,KAAK,4BAC1BC,EAAuB,KAAK,+BAG5BE,GAFc,KAAK,QAAQ,aAAe,KAAK,oBAETL,EAE5CN,EAAI,KAAK,EACTA,EAAI,KAAO,GAAGW,EAAwBL,OAAY,KAAK,QAAQ,MAAQ,KAAK,cAEtE,MAAAW,EADejB,EAAI,YAAYyC,EAAE,KAAK,EACE,MAAQpC,EAEhDO,EAAWT,EAAO,OAAOA,EAAO,QAAQ,EAAE,EAAIM,EAC9CI,EAAYV,EAAO,OAAOA,EAAO,QAAQ,EAAE,EAAIM,EAC/C,CAACK,EAAqBC,CAAoB,EAAI,KAAK,qBAAqB,EAG1E,IAAAK,EACJ,MAAMsB,EAAQ,EACVlC,EACSY,EAAAlB,EAAa,KAAK,IAAIa,EAAsBF,CAAS,EAAI,KAAK,IAAIE,EAAsBF,CAAS,EAEjGO,EAAAlB,EAAa,KAAK,IAAIY,EAAqBF,CAAQ,EAAI,KAAK,IAAIE,EAAqBF,CAAQ,EAI1G,MAAM+B,EAAQ1B,EAA2ByB,GAAUlC,EAAqB,GAAK,GAGvE,CAAE,KAAAT,CAAS,EAAA0C,EACXG,EAAM,KAAK,QAAQ7C,EAAMqB,EAAUsB,EAAOC,CAAI,EAC9CE,EAAM,KAAK,YAAY9C,EAAMqB,EAAUsB,EAAOC,EAAMpC,EAASC,EAAqByB,EAAQ,KAAOA,EAAQ,KAAK,EAChH,GAAA,CAACW,GAAO,CAACC,EACX,OAIF,MAAMP,EAAQlB,EACRmB,EAAQK,EAAI,EAAIE,EAAqBnC,EAAwB,EAC7DoC,EAAUd,EAAQ,WAAWY,CAAG,GAAKrC,EAAqB,KAAK,GAAK,GAGtER,EAAA,UAAYQ,EAAqB,QAAU,OAC/CR,EAAI,UAAUG,EAAOmC,CAAK,EAAGlC,EAAOmC,CAAK,CAAC,EAC1CvC,EAAI,OAAO+C,CAAO,EAClB/C,EAAI,UAAY,KAAK,gBAAgByC,EAAE,KAAK,EAC5CzC,EAAI,aAAe,SACnBA,EAAI,SAASyC,EAAE,MAAO,EAAG,CAAC,EAE1BzC,EAAI,QAAQ,CAAA,GAxSZ,KAAK,OAAS,KAAK,OAAO,KAAK,IAAI,EACnC,KAAK,6BAA+B,KAAK,6BAA6B,KAAK,IAAI,EAC/E,KAAK,qBAAuB,KAAK,qBAAqB,KAAK,IAAI,EAC/D,KAAK,eAAiB,KAAK,eAAe,KAAK,IAAI,EACnD,KAAK,6BAA+B,KAAK,6BAA6B,KAAK,IAAI,CACjF,CAEA,IAAI,SAAyC,CAC3C,OAAO,KAAK,QACd,CAEA,QAAQD,EAAe,CACrB,MAAM,QAAQA,CAAI,EAClB,KAAK,qBAAuB,IAC9B,CAEA,8BAAqC,CAC7B,KAAA,CAAE,MAAAiD,CAAM,EAAI,KAAK,KACvB,KAAK,qBAAuBA,EAAM,OAAO,CAACC,EAAmCC,IAAsB,CAE7F,GAAA,CAACA,EAAK,MACD,OAAAD,EAEH,MAAAE,EAAcD,EAAK,KAAK,OAC5B,CAACE,EAAmCvB,KAC9BA,EAAE,IAAM,OACVuB,EAAE,KAAOvB,EAAE,GACTuB,EAAA,SAEGA,GAET,CACE,IAAK,EACL,MAAO,CACT,CAAA,EAEE,GAAAD,EAAY,QAAU,EACjB,OAAAF,EAEH,MAAAI,EAAcF,EAAY,IAAMA,EAAY,MAElD,OAAAF,EAAI,KAAK,CACP,GAAGC,EACH,YAAAG,CAAA,CACD,EACMJ,CACT,EAAG,CAAE,CAAA,CACP,CAEA,QAAQK,EAA2B,CACjC,MAAM,QAAQA,CAAK,CACrB,CAEA,SAASA,EAA+B,CACtC,MAAM,SAASA,CAAK,EACpB,KAAK,OAAO,CACd,CAEA,UAAUA,EAA6B,CACrC,KAAK,aAAeA,EACpB,KAAK,eAAe,EACpB,KAAK,eAAe,EACpB,KAAK,OAAO,CACd,CAEA,QAAe,CACT,CAAC,KAAK,cAIV,sBAAsB,IAAM,CAC1B,KAAK,YAAY,EAEZ,KAAK,OAIL,KAAK,sBACR,KAAK,6BAA6B,EAGpC,KAAK,eAAe,EACpB,KAAK,eAAe,EAAA,CACrB,CACH,CAEA,gBAAuB,CACrB,KAAK,qBAAqB,QAAQ,CAACb,EAA+Bc,EAAWC,IAAwC,CACnH,MAAMC,EAA4BD,EAAM,OAAO,CAACP,EAAwCS,EAAGC,KACrFA,EAAQJ,IACNN,GAAO,MAGLS,EAAE,YAAcT,EAAI,eAChBA,EAAAS,GAILT,GACN,IAAI,EAEH,CAACQ,GAIL,KAAK,cAAchB,EAAGgB,EAA2BD,EAAOD,CAAC,CAAA,CAC1D,CACH,CAEA,gBAAuB,CACrB,KAAK,KAAK,MAAM,OAAQK,GAA6BA,EAAY,KAAK,EAAE,QAASA,GAA6B,KAAK,cAAcA,CAAW,CAAC,CAC/I,CA4LA,gBAAgBC,EAAgC,CAC1C,GAAA,OAAOA,GAAU,SACZ,OAAAA,EAGL,IAAAC,EAAYD,EAAM,SAAS,EAAE,EAEjC,OAAAC,EAAY,SAAS,OAAO,EAAG,EAAIA,EAAU,MAAM,EAAIA,EAChD,IAAIA,GACb,CAEA,QACE/D,EACAgE,EACAC,EACArB,EACAsB,EAAmB,KACnBC,EAAsB,KACtBC,EAAqC,KACrCrE,EAAiC,KACjCsE,EAA8B,KACrB,CACH,MAAAxB,EAAMX,EAAQ,KAAK,QACzB,IAAIoC,EAAU,EACd,QAASd,EAAI,EAAGA,EAAIS,EAAOT,IAAK,CACxB,MAAAe,EAAIP,EAASR,EAAIZ,EACjB4B,EAAIC,EAAgBzE,EAAMuE,EAAGL,EAAUC,CAAW,EACxD,GAAIK,EAAG,CACC,MAAAE,EAAe,KAAK,gCAAgCH,EAAGL,EAAUC,EAAaC,EAAwBrE,EAAUsE,CAAmB,EAEnIM,EAAQD,EAAe,KAAK,IAAIF,EAAGE,CAAY,EAAIF,EACrD3B,EAAA,IAAI0B,EAAGI,CAAK,EAChBL,GACF,CACF,CAEA,OAAIA,IAAY,EACP,KAGFpC,EAAQ,OAAOW,EAAKyB,CAAO,CACpC,CAEA,gCACEC,EACAL,EACAC,EACAC,EACArE,EACAsE,EACQ,CACR,GAAI,CAACD,EACI,OAAA,KAGT,IAAIQ,EAAOH,EAAgBL,EAAwBG,EAAGL,EAAUC,CAAW,EAC3E,GAAIS,GAAQ,MAAQ7E,GAAYsE,GAAuB,KAAM,CAE3D,IAAIQ,EAAKR,EAAsB,EAC/B,KAAOO,GAAQ,MAAQC,EAAK9E,EAAS,QAAQ,CAC3C,MAAM+E,EAAa/E,EAAS8E,KACrBD,EAAAH,EACLK,EAAW,KAAK,IAAKhD,GAAgB,CAACA,EAAE,GAAIA,EAAE,EAAE,CAAC,EACjDyC,EACAL,EACAC,CAAA,CAEJ,CACF,CACO,OAAAS,CACT,CAEA,YACE5E,EACAgE,EACAC,EACArB,EACApC,EACAuE,EAAwB7C,EAAQ,KAChCgC,EAAmB,KACnBC,EAAsB,KACb,CACT,MAAMrB,EAAMiC,EAAa,QAEnBC,EAASP,EAAgBzE,EAAMgE,EAAQE,EAAUC,CAAW,EAClE,GAAIa,IAAW,KACN,OAAAlC,EAGT,MAAMmC,EAAW,IAAI/C,EAAQ8B,EAAQgB,EAASxE,CAAO,EAC/C0E,EAAShD,EAAQ,KAAK,QAC5B,QAASsB,EAAI,EAAGA,GAAKS,EAAOT,IAAK,CACzB,MAAAe,EAAIP,EAASR,EAAIZ,EACjB4B,EAAIC,EAAgBzE,EAAMgE,EAAQE,EAAUC,CAAW,EACzDK,IAAM,OACDU,EAAA,IAAIX,EAAGC,EAAIhE,CAAO,EACzB0E,EAAO,IAAID,CAAQ,EACnBnC,EAAI,IAAIoC,CAAM,EAElB,CAEO,OAAApC,CACT,CAEA,YACEqC,EACAC,EACApB,EACAC,EACArB,EACAmC,EAAwB7C,EAAQ,KAChCgC,EAAmB,KACnBC,EAAsB,KACtBkB,EAA4B,EAC5BC,EAA4B,KAAK,GAAK,EACtCC,EAAiC,EACjCC,EAA2C,KAC3CzF,EAAiC,KACjCsE,EAA8B,KACtB,CACR,MAAMoB,EAAmB,CAAA,EACnBP,EAAShD,EAAQ,KAAK,QACxB,IAAA+C,EACJ,QAASzB,EAAI,EAAGA,GAAKS,EAAOT,IAAK,CACzB,MAAAe,EAAIP,EAASR,EAAIZ,EACjB8C,EAAOjB,EAAgBU,EAAKZ,EAAGL,EAAUC,CAAW,EACpDwB,EAAUlB,EAAgBW,EAAQb,EAAGL,EAAUC,CAAW,GAAKA,EAE/DyB,EAAqB,KAAK,gCAC9BrB,EACAL,EACAC,EACAqB,EACAzF,EACAsE,CAAA,EAGIwB,EAAcD,EAAqB,KAAK,IAAID,EAASC,CAAkB,EAAID,EACjF,GAAInC,IAAM,EAAG,CACX,GAAIkC,IAAS,KACJ,OAAAxD,EAAQ,WAAW6C,CAAY,EAElC,MAAAC,GAAUU,EAAOG,GAAe,EAC3BZ,EAAA,IAAI/C,EAAQ8B,EAAQgB,CAAM,CAAA,MAEjCU,IAAS,MACXR,EAAO,IAAIX,GAAImB,EAAOG,GAAe,CAAC,EACtCX,EAAO,IAAID,CAAQ,EAEnBQ,EAAO,KAAKvD,EAAQ,WAAWgD,CAAM,CAAC,GAEtCO,EAAO,KAAKvD,EAAQ,WAAW6C,CAAY,CAAC,CAGlD,CAEA,MAAMe,EAAWL,EAAO,GAClBM,EAAeN,EAAO,IAAK3D,GAAcA,EAAIgE,CAAQ,EAC3D,IAAIE,EAAU,EAQP,OAPWD,EAAa,OAAO,CAAC7C,EAAaS,IAAc,CAChE,MAAMsC,GAAS,KAAK,IAAItC,CAAC,EAAI0B,GAAqBC,EAC5CY,EAAS,KAAK,IAAI,EAAIC,GAAMF,EAAO,EAAG,CAAC,EAAGV,CAAsB,EAC3D,OAAAS,GAAAE,EACJhD,EAAMS,EAAIuC,GAChB,CAAC,EACsBF,EAAUF,CAEtC,CAEA,gBAAuB,CACf,KAAA,CAAE,QAAAM,CAAQ,EAAI,KAAK,aACpB,KAAA,WAAaA,EAAQ,GAAKA,EAAQ,EACzC,CAEA,8BAAuC,CAC/B,KAAA,CAAE,OAAA9F,CAAO,EAAI,KAAK,aAGjB,OAFU,KAAK,QAAQ,SAAW,KAAK,iBAAmB,KAAK,WAAa,GAAK,GACjDA,CAEzC,CAEA,sBAAiC,CAC/B,MAAM+F,EAAY,KAAK,KAAK,MAAM,OAAO,CAACnD,EAAKC,IAAS,CAChD,KAAA,CAAE,KAAAnD,CAAS,EAAAmD,EACXmD,EAAkBtG,EAAK,KAAM8B,GAAgBA,EAAE,IAAM,IAAI,EAC3DwE,GACEpD,EAAA,KAAKoD,EAAgB,EAAE,EAG7B,QAAS9C,EAAIxD,EAAK,OAAS,EAAGwD,GAAK,EAAGA,IAChC,GAAAxD,EAAKwD,GAAG,IAAM,KAAM,CAClBN,EAAA,KAAKlD,EAAKwD,GAAG,EAAE,EACnB,KACF,CAGK,OAAAN,CACT,EAAG,CAAE,CAAA,EACKmD,EAAA,KACR,GAAG,KAAK,KAAK,MAAM,OAAO,CAACnD,EAAKqD,IAAS,CACjC,KAAA,CAAE,KAAAvG,CAAS,EAAAuG,EACXD,EAAkBtG,EAAK,KAAM8B,GAAgBA,EAAE,IAAM,IAAI,EAC3DwE,GACEpD,EAAA,KAAKoD,EAAgB,EAAE,EAG7B,QAAS9C,EAAIxD,EAAK,OAAS,EAAGwD,GAAK,EAAGA,IAChC,GAAAxD,EAAKwD,GAAG,IAAM,KAAM,CAClBN,EAAA,KAAKlD,EAAKwD,GAAG,EAAE,EACnB,KACF,CAEK,OAAAN,CACT,EAAG,EAAE,CAAA,EAGP,MAAMsD,EAAO,KAAK,IAAI,GAAGH,CAAS,EAC5BI,EAAO,KAAK,IAAI,GAAGJ,CAAS,EAC5B3F,EAAuB,KAAK,+BAC5B,CAAE,WAAAP,CAAe,EAAA,KACjBY,EAAsBZ,EAAasG,EAAO/F,EAAuB8F,EAAO9F,EACxEM,EAAuBb,EAAaqG,EAAO9F,EAAuB+F,EAAO/F,EACxE,MAAA,CAACK,EAAqBC,CAAoB,CACnD,CAEA,2BAAqC,CAC7B,KAAA,CAAE,gBAAA0F,EAAiB,WAAAvG,CAAe,EAAA,KACxC,GAAI,CAACuG,EACI,MAAA,GAGT,KAAM,CAAE,OAAAtG,EAAQ,OAAAC,EAAQ,OAAAC,CAAA,EAAW,KAAK,aAClCqG,EAAI,IAEJ,CAACC,EAAKC,CAAG,EAAIzG,EAAO,OAAO,EAC3B,CAAC0G,EAAKC,CAAG,EAAI1G,EAAO,OAAO,EAEjC,IAAI8E,EAAMuB,EAAgB,cAAc,QAAQ,OAAOI,EAAK,EAAG,CAAC,EAC5D3B,EAAI,SAAW,IACjBA,EAAM,CAACuB,EAAgB,cAAc,QAAQ,WAAW,CAAG,CAAa,GAE1E,IAAItB,EAASsB,EAAgB,cAAc,QAAQ,OAAOK,EAAK,EAAG,CAAC,EAC/D3B,EAAO,SAAW,IACpBA,EAAS,CAACsB,EAAgB,cAAc,QAAQ,WAAW,CAAG,CAAa,GAGvE,MAAAD,EAAO,KAAK,IAAItB,EAAI,GAAG,GAAIC,EAAO,GAAG,EAAE,EACvCoB,EAAO,KAAK,IAAIrB,EAAI,GAAG,GAAIC,EAAO,GAAG,EAAE,EAEvC4B,EAAS,CACb,KAAM7G,EAAasG,EAAOD,EAC1B,MAAOrG,EAAaqG,EAAOC,CAAA,EAGvBQ,EAAS,KAAK,+BACdC,EAAiBN,EAAMK,EACvBE,EAAkBN,EAAMI,EAExB,CAAClG,EAAqBC,CAAoB,EAAI,KAAK,qBAAqB,EAExEoG,EAAYjH,EAAa,KAAK,IAAI+G,EAAgBnG,CAAmB,EAAI,KAAK,IAAImG,EAAgBnG,CAAmB,EACrHsG,EAAalH,EAAa,KAAK,IAAIgH,EAAiBnG,CAAoB,EAAI,KAAK,IAAImG,EAAiBnG,CAAoB,EAE1HsG,EAAkB,KAAK,IAAInH,EAAaiH,EAAYJ,EAAO,KAAOA,EAAO,KAAOI,EAAW,CAAC,EAC5FG,EAAmB,KAAK,IAAIpH,EAAa6G,EAAO,MAAQK,EAAaA,EAAaL,EAAO,MAAO,CAAC,EAEjGQ,EAAqCF,EAAkBhH,EACvDmH,EAAsCF,EAAmBjH,EAOxD,OALLgH,EAAkBC,GAClBC,EAAqCb,GACpCa,EAAqCb,GAAKc,EAAsCd,GAAKxG,GACtFiF,EAAO,GAAG,GAAK0B,CAGnB,CACF,CCpmBA,MAAMY,GAAmB,IAElB,MAAMC,WAA+CC,EAAa,CAAlE,kCACGhI,EAAA,qBAAyB,IAmCjCA,EAAA,sBAAkBI,GAAiC,CACjD,MAAM6H,EAAuB,CAAA,EAC7B,IAAIC,EAAoB,KAGxB,QAAS,EAAI,EAAG,EAAI9H,EAAK,OAAQ,IAAK,CAEpC,MAAM+H,EAAa,CAAC,CAAC/H,EAAK,GAAG,GACzB+H,IACED,IAAY,OACdA,EAAU,CAAA,GAEZA,EAAQ,KAAK9H,EAAK,GAAG,GAAIA,EAAK,GAAG,EAAE,GAG/B,MAAAgI,EAAe,IAAMhI,EAAK,OAAS,EACrC,IAAA,CAAC+H,GAAcC,IACbF,EAAS,CAEF,QAAAG,EAAaF,EAAqB,EAAR,EAAI,EAAOE,GAAK,GAC5CjI,EAAKiI,GAAG,GADuCA,IAIpDH,EAAQ,KAAK9H,EAAKiI,GAAG,GAAIjI,EAAKiI,GAAG,IAAMP,EAAgB,EAEzDG,EAAS,KAAKC,CAAO,EACXA,EAAA,IACZ,CAEJ,CACO,OAAAD,CAAA,GAGTjI,EAAA,2BAAuB8C,GAAyB,CACxC,MAAAwF,EAAI,IAAIC,EACdD,EAAE,UAAU,EAAGxF,EAAE,MAAiB,CAAC,EACjCwF,EAAA,UAAUxF,EAAE,KAAe,EACZ,KAAK,eAAeA,EAAE,IAAI,EAClC,QAASoF,GAAsBI,EAAE,YAAYJ,CAAO,CAAC,EAC9DI,EAAE,QAAQ,EACV,KAAK,SAASA,CAAC,CAAA,GAGjBtI,EAAA,2BAAuB8C,GAAyB,CACxC,MAAAwF,EAAI,IAAIC,EACR,CAAE,KAAMrG,CAAM,EAAAY,EAEd0F,EAAY,GAClBF,EAAE,UAAUnF,EAAoBL,EAAE,MAAiB,EAAG0F,EAAW,EAAI,EAErE,IAAIC,EAAU,GACd,QAAS7E,EAAI,EAAGA,EAAI1B,EAAE,OAAQ0B,IACxB1B,EAAE0B,GAAG,GACH6E,EACFH,EAAE,OAAOpG,EAAE0B,GAAG,GAAI1B,EAAE0B,GAAG,EAAE,GAEzB0E,EAAE,OAAOpG,EAAE0B,GAAG,GAAI1B,EAAE0B,GAAG,EAAE,EACf6E,EAAA,IAGFA,EAAA,GAGd,KAAK,SAASH,CAAC,CAAA,GAhGjB,UAAU3E,EAA6B,CACrC,MAAM,UAAUA,CAAK,EAEhB,KAAK,gBACR,KAAK,WAAW,EAChB,KAAK,UAAU,GAGjB,KAAK,OAAO,CACd,CAEA,SAASA,EAA+B,CACtC,MAAM,SAASA,CAAK,EAEpB,KAAK,cAAgB,GACrB,KAAK,WAAW,EAChB,KAAK,UAAU,EACf,KAAK,OAAO,CACd,CAEA,WAAkB,CACV,KAAA,CAAE,KAAAvD,CAAgC,EAAA,KAEpC,CAACA,IAILA,EAAK,MAAM,QAASqD,GAAmB,KAAK,oBAAoBA,CAAC,CAAC,EAClErD,EAAK,MAAM,QAASsI,GAAmB,KAAK,oBAAoBA,CAAC,CAAC,EAElE,KAAK,cAAgB,GACvB,CAmEF"}