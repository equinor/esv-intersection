{"version":3,"file":"GeomodelLayerV2-d50a63f8.js","sources":["../../../../src/layers/GeomodelLabelsLayer.ts","../../../../src/layers/GeomodelLayerV2.ts"],"sourcesContent":["import Vector2 from '@equinor/videx-vector2';\nimport { clamp } from '@equinor/videx-math';\n\nimport { CanvasLayer } from './base/CanvasLayer';\nimport { OnUpdateEvent, OnRescaleEvent, OnMountEvent } from '../interfaces';\nimport { SurfaceArea, SurfaceLine, findSampleAtPos, SurfaceData } from '../datautils';\nimport { SURFACE_LINE_WIDTH } from '../constants';\nimport { LayerOptions } from './base/Layer';\n\nconst DEFAULT_MARGINS = 18;\nconst DEFAULT_MIN_FONT_SIZE = 8;\nconst DEFAULT_MAX_FONT_SIZE = 13;\nconst DEFAULT_TEXT_COLOR = 'black';\nconst DEFAULT_FONT = 'Arial';\nconst MAX_FONT_SIZE_IN_WORLD_COORDINATES = 70;\n\nexport interface GeomodelLayerLabelsOptions<T extends SurfaceData> extends LayerOptions<T> {\n  margins?: number;\n  minFontSize?: number;\n  maxFontSize?: number;\n  textColor?: string;\n  font?: string;\n}\n\ninterface SurfaceAreaWithAvgTopDepth extends SurfaceArea {\n  avgTopDepth: number;\n}\n\nexport class GeomodelLabelsLayer<T extends SurfaceData> extends CanvasLayer<T> {\n  defaultMargins: number = DEFAULT_MARGINS;\n  defaultMinFontSize: number = DEFAULT_MIN_FONT_SIZE;\n  defaultMaxFontSize: number = DEFAULT_MAX_FONT_SIZE;\n  defaultTextColor: string = DEFAULT_TEXT_COLOR;\n  defaultFont: string = DEFAULT_FONT;\n\n  rescaleEvent: OnRescaleEvent | undefined;\n  isLabelsOnLeftSide = true;\n  maxFontSizeInWorldCoordinates: number = MAX_FONT_SIZE_IN_WORLD_COORDINATES;\n  isXFlipped = false;\n  areasWithAvgTopDepth: SurfaceAreaWithAvgTopDepth[] = [];\n\n  constructor(id?: string, options?: GeomodelLayerLabelsOptions<T>) {\n    super(id, options);\n    this.render = this.render.bind(this);\n    this.getMarginsInWorldCoordinates = this.getMarginsInWorldCoordinates.bind(this);\n    this.getSurfacesAreaEdges = this.getSurfacesAreaEdges.bind(this);\n    this.updateXFlipped = this.updateXFlipped.bind(this);\n    this.generateSurfacesWithAvgDepth = this.generateSurfacesWithAvgDepth.bind(this);\n  }\n\n  override get options(): GeomodelLayerLabelsOptions<T> {\n    return this._options;\n  }\n\n  override setData(data: T): void {\n    super.setData(data);\n    this.areasWithAvgTopDepth = [];\n  }\n\n  generateSurfacesWithAvgDepth(): void {\n    const areas = this.data?.areas ?? [];\n    this.areasWithAvgTopDepth = areas.reduce((acc: SurfaceAreaWithAvgTopDepth[], area: SurfaceArea) => {\n      // Filter surfaces without label\n      if (!area.label) {\n        return acc;\n      }\n      const sumAndCount = area.data.reduce(\n        (a: { sum: number; count: number }, d: number[]) => {\n          if (d[1] != null) {\n            a.sum += d[1];\n            a.count++;\n          }\n          return a;\n        },\n        {\n          sum: 0,\n          count: 0,\n        },\n      );\n      if (sumAndCount.count === 0) {\n        return acc;\n      }\n      const avgTopDepth = sumAndCount.sum / sumAndCount.count;\n\n      acc.push({\n        ...area,\n        avgTopDepth,\n      });\n      return acc;\n    }, []);\n  }\n\n  override onMount(event: OnMountEvent): void {\n    super.onMount(event);\n  }\n\n  override onUpdate(event: OnUpdateEvent<T>): void {\n    super.onUpdate(event);\n    this.render();\n  }\n\n  override onRescale(event: OnRescaleEvent): void {\n    this.rescaleEvent = event;\n    this.updateXFlipped();\n    this.resetTransform();\n    this.render();\n  }\n\n  render(): void {\n    if (!this.rescaleEvent) {\n      return;\n    }\n\n    requestAnimationFrame(() => {\n      this.clearCanvas();\n\n      if (!this.data) {\n        return;\n      }\n\n      if (this.areasWithAvgTopDepth.length <= 0) {\n        this.generateSurfacesWithAvgDepth();\n      }\n\n      this.drawAreaLabels();\n      this.drawLineLabels();\n    });\n  }\n\n  drawAreaLabels(): void {\n    this.areasWithAvgTopDepth.forEach((s: SurfaceAreaWithAvgTopDepth, i: number, array: SurfaceAreaWithAvgTopDepth[]) => {\n      const topmostSurfaceNotDrawnYet = array.reduce((acc: SurfaceAreaWithAvgTopDepth | null, v, index): SurfaceAreaWithAvgTopDepth | null => {\n        if (index > i) {\n          if (acc == null) {\n            acc = v;\n          } else {\n            if (v.avgTopDepth < acc.avgTopDepth) {\n              acc = v;\n            }\n          }\n        }\n        return acc;\n      }, null);\n\n      this.drawAreaLabel(s, topmostSurfaceNotDrawnYet, array, i);\n    });\n  }\n\n  drawLineLabels(): void {\n    this.data?.lines.filter((surfaceLine: SurfaceLine) => surfaceLine.label).forEach((surfaceLine: SurfaceLine) => this.drawLineLabel(surfaceLine));\n  }\n\n  drawAreaLabel = (surfaceArea: SurfaceArea, nextSurfaceArea: SurfaceArea | null, surfaces: SurfaceArea[], i: number): void => {\n    const { data } = surfaceArea;\n    const { ctx, maxFontSizeInWorldCoordinates, isXFlipped } = this;\n    const { xScale, yScale, xRatio, yRatio, zFactor } = this.rescaleEvent!;\n    if (ctx == null) return;\n\n    let isLabelsOnLeftSide = this.checkDrawLabelsOnLeftSide();\n    const margins = (this.options.margins || this.defaultMargins) * (isXFlipped ? -1 : 1);\n    const marginsInWorldCoords = margins / xRatio;\n    const minFontSize = this.options.minFontSize || this.defaultMinFontSize;\n    const maxFontSize = this.options.maxFontSize || this.defaultMaxFontSize;\n\n    let fontSizeInWorldCoords = maxFontSize / yRatio;\n    if (fontSizeInWorldCoords > maxFontSizeInWorldCoordinates) {\n      fontSizeInWorldCoords = maxFontSizeInWorldCoordinates;\n      if (fontSizeInWorldCoords * yRatio < minFontSize) {\n        fontSizeInWorldCoords = minFontSize / yRatio;\n      }\n    }\n\n    const leftEdge = xScale.invert(xScale.range()[0]!) + marginsInWorldCoords;\n    const rightEdge = xScale.invert(xScale.range()[1]!) - marginsInWorldCoords;\n    const [surfaceAreaLeftEdge, surfaceAreaRightEdge] = this.getSurfacesAreaEdges() as [number, number];\n\n    // Get label metrics\n    ctx.save();\n    ctx.font = `${fontSizeInWorldCoords * yRatio}px ${this.options.font || this.defaultFont}`;\n    let labelMetrics = ctx.measureText(surfaceArea.label ?? '');\n    let labelLengthInWorldCoords = labelMetrics.width / xRatio;\n\n    // Check if label will fit horizontally\n    if (isLabelsOnLeftSide) {\n      const labelRightEdge = leftEdge + (isXFlipped ? -labelLengthInWorldCoords : labelLengthInWorldCoords);\n      if ((!isXFlipped && labelRightEdge > surfaceAreaRightEdge) || (isXFlipped && labelRightEdge < surfaceAreaRightEdge)) {\n        isLabelsOnLeftSide = false;\n      }\n    } else {\n      const labelLeftEdge = rightEdge + (isXFlipped ? labelLengthInWorldCoords : -labelLengthInWorldCoords);\n      if ((!isXFlipped && labelLeftEdge < surfaceAreaLeftEdge) || (isXFlipped && labelLeftEdge > surfaceAreaLeftEdge)) {\n        isLabelsOnLeftSide = true;\n      }\n    }\n\n    // Find edge where to draw\n    let startPos: number;\n    const portionOfLabelLengthUsedForPosCalc = 0.07;\n    if (isLabelsOnLeftSide) {\n      startPos = isXFlipped ? Math.min(surfaceAreaLeftEdge, leftEdge) : Math.max(surfaceAreaLeftEdge, leftEdge);\n    } else {\n      startPos = isXFlipped ? Math.max(surfaceAreaRightEdge, rightEdge) : Math.min(surfaceAreaRightEdge, rightEdge);\n    }\n\n    const topEdge = yScale.invert(yScale.range()[0]!);\n    const bottomEdge = yScale.invert(yScale.range()[1]!);\n\n    // Calculate where to sample points\n    const dirSteps = 5;\n    const posSteps = 3;\n    const posStep =\n      portionOfLabelLengthUsedForPosCalc * (labelLengthInWorldCoords / posSteps) * (isLabelsOnLeftSide ? 1 : -1) * (isXFlipped ? -1 : 1);\n    const dirStep = (labelLengthInWorldCoords / dirSteps) * (isLabelsOnLeftSide ? 1 : -1) * (isXFlipped ? -1 : 1);\n\n    // Sample points from top and calculate position\n    const topData = data.map((d) => [d[0]!, d[1]!]);\n    const topPos = this.calcPos(topData, startPos, posSteps, posStep, topEdge, bottomEdge);\n    if (!topPos) {\n      return;\n    }\n\n    // Sample points from bottom and calculate position\n    const bottomData = data.map((d) => [d[0]!, d[2]!]);\n    let bottomPos = this.calcPos(\n      bottomData,\n      startPos,\n      posSteps,\n      posStep,\n      topEdge,\n      bottomEdge,\n      nextSurfaceArea?.data.map((d) => [d[0]!, d[1]!]) ?? [],\n      surfaces,\n      i,\n    );\n    if (!bottomPos) {\n      bottomPos = new Vector2(topPos.x, bottomEdge);\n    }\n\n    // Check if there is enough height for label\n    const thickness = bottomPos.y - topPos.y;\n    if (thickness < fontSizeInWorldCoords) {\n      // Check minimum fontsize\n      if (thickness * yRatio < minFontSize) {\n        return;\n      }\n      // Use reduced fontsize\n      fontSizeInWorldCoords = thickness;\n      ctx.font = `${fontSizeInWorldCoords * yRatio}px ${this.options.font || this.defaultFont}`;\n      labelMetrics = ctx.measureText(surfaceArea.label ?? '');\n      labelLengthInWorldCoords = labelMetrics.width / xRatio;\n    }\n    // Sample points from top and bottom and calculate direction vector\n    const initialDirVec = isLabelsOnLeftSide !== isXFlipped ? Vector2.right : Vector2.left;\n    const areaDir = this.calcAreaDir(\n      topData,\n      bottomData,\n      startPos,\n      dirSteps,\n      dirStep,\n      initialDirVec,\n      topEdge,\n      bottomEdge,\n      0,\n      Math.PI / 4,\n      4,\n      nextSurfaceArea?.data.map((d) => [d[0]!, d[1]!]) ?? [],\n      surfaces,\n      i,\n    );\n    const scaledAngle = Math.atan(Math.tan(areaDir) * zFactor);\n\n    // Draw label\n    const textX = startPos;\n    const textY = (topPos.y + bottomPos.y) / 2;\n    const textAngle = isXFlipped ? -scaledAngle : scaledAngle;\n\n    if (ctx) {\n      ctx.textAlign = isLabelsOnLeftSide ? 'left' : 'right';\n      ctx.translate(xScale(textX), yScale(textY));\n      ctx.rotate(textAngle);\n      ctx.fillStyle = this.options.textColor || this.defaultTextColor;\n      ctx.font = `${fontSizeInWorldCoords * yRatio}px ${this.options.font || this.defaultFont}`;\n      ctx.textBaseline = 'middle';\n      ctx.fillText(surfaceArea.label ?? '', 0, 0);\n\n      ctx.restore();\n    }\n  };\n\n  drawLineLabel = (s: SurfaceLine): void => {\n    const { ctx, isXFlipped } = this;\n    const { xScale, yScale, xRatio, yRatio, zFactor } = this.rescaleEvent!;\n    if (ctx == null) return;\n    const isLabelsOnLeftSide = this.checkDrawLabelsOnLeftSide();\n    const marginsInWorldCoords = this.getMarginsInWorldCoordinates();\n    const maxFontSize = this.options.maxFontSize || this.defaultMaxFontSize;\n\n    const fontSizeInWorldCoords = maxFontSize / yRatio;\n\n    ctx.save();\n    ctx.font = `${fontSizeInWorldCoords * yRatio}px ${this.options.font || this.defaultFont}`;\n    const labelMetrics = ctx.measureText(s.label);\n    const labelLengthInWorldCoords = labelMetrics.width / xRatio;\n\n    const leftEdge = xScale.invert(xScale.range()[0]!) + marginsInWorldCoords;\n    const rightEdge = xScale.invert(xScale.range()[1]!) - marginsInWorldCoords;\n    const [surfaceAreaLeftEdge, surfaceAreaRightEdge] = this.getSurfacesAreaEdges() as [number, number];\n\n    // Find edge where to draw\n    let startPos: number;\n    const steps = 5;\n    if (isLabelsOnLeftSide) {\n      startPos = isXFlipped ? Math.max(surfaceAreaRightEdge, rightEdge) : Math.min(surfaceAreaRightEdge, rightEdge);\n    } else {\n      startPos = isXFlipped ? Math.min(surfaceAreaLeftEdge, leftEdge) : Math.max(surfaceAreaLeftEdge, leftEdge);\n    }\n\n    // Calculate where to sample points\n    const step = (labelLengthInWorldCoords / steps) * (isLabelsOnLeftSide ? -1 : 1);\n\n    // Sample points and calculate position and direction vector\n    const { data } = s;\n    const pos = this.calcPos(data, startPos, steps, step);\n    const dir = this.calcLineDir(data, startPos, steps, step, zFactor, isLabelsOnLeftSide ? Vector2.left : Vector2.right);\n    if (!pos || !dir) {\n      return;\n    }\n\n    // Calculate position and direction for label\n    const textX = startPos;\n    const textY = pos.y - SURFACE_LINE_WIDTH - fontSizeInWorldCoords / 2;\n    const textDir = Vector2.angleRight(dir) - (isLabelsOnLeftSide ? Math.PI : 0);\n\n    // Draw label\n    if (ctx) {\n      ctx.textAlign = isLabelsOnLeftSide ? 'right' : 'left';\n      ctx.translate(xScale(textX), yScale(textY));\n      ctx.rotate(textDir);\n      ctx.fillStyle = this.colorToCSSColor(s.color);\n      ctx.textBaseline = 'middle';\n      ctx.fillText(s.label, 0, 0);\n\n      ctx.restore();\n    }\n  };\n\n  colorToCSSColor(color: number | string): string {\n    if (typeof color === 'string') {\n      return color;\n    }\n\n    let hexString = color.toString(16);\n    hexString = '000000'.substr(0, 6 - hexString.length) + hexString;\n    return `#${hexString}`;\n  }\n\n  calcPos(\n    data: number[][],\n    offset: number,\n    count: number,\n    step: number,\n    topLimit?: number,\n    bottomLimit?: number,\n    alternativeSurfaceData?: number[][],\n    surfaces: SurfaceArea[] | null = null,\n    currentSurfaceIndex?: number,\n  ): Vector2 | null {\n    const pos = Vector2.zero.mutable;\n    let samples = 0;\n    for (let i = 0; i < count; i++) {\n      const x = offset + i * step;\n      const y = findSampleAtPos(data, x, topLimit, bottomLimit);\n      if (y) {\n        const alternativeY = this.getAlternativeYValueIfAvailable(x, topLimit, bottomLimit, alternativeSurfaceData, surfaces, currentSurfaceIndex);\n        // Use topmost of value from current surface and alternative surface\n        const usedY = alternativeY ? Math.min(y, alternativeY) : y;\n        pos.add(x, usedY);\n        samples++;\n      }\n    }\n\n    if (samples === 0) {\n      return null;\n    }\n\n    return Vector2.divide(pos, samples);\n  }\n\n  getAlternativeYValueIfAvailable(\n    x: number,\n    topLimit?: number,\n    bottomLimit?: number,\n    alternativeSurfaceData?: number[][],\n    surfaces: SurfaceArea[] | null = null,\n    currentSurfaceIndex?: number,\n  ): number | null {\n    if (!alternativeSurfaceData) {\n      return null;\n    }\n    // Find sample from passed in surface data\n    let altY = findSampleAtPos(alternativeSurfaceData, x, topLimit, bottomLimit);\n    if (altY == null && surfaces && currentSurfaceIndex != null) {\n      //Find topmost surface after current which gives us data\n      let si = currentSurfaceIndex + 1;\n      while (altY == null && si < surfaces.length) {\n        const altSurface = surfaces[si++];\n        altY = findSampleAtPos(altSurface?.data.map((d: number[]) => [d[0]!, d[1]!]) ?? [], x, topLimit, bottomLimit);\n      }\n    }\n    return altY;\n  }\n\n  calcLineDir(\n    data: number[][],\n    offset: number,\n    count: number,\n    step: number,\n    zFactor: number,\n    initalVector: Vector2 = Vector2.left,\n    topLimit?: number,\n    bottomLimit?: number,\n  ): Vector2 {\n    const dir = initalVector.mutable;\n\n    const startY = findSampleAtPos(data, offset, topLimit, bottomLimit);\n    if (startY === null) {\n      return dir;\n    }\n\n    const vecAtEnd = new Vector2(offset, startY * zFactor);\n    const tmpVec = Vector2.zero.mutable;\n    for (let i = 1; i <= count; i++) {\n      const x = offset + i * step;\n      const y = findSampleAtPos(data, offset, topLimit, bottomLimit);\n      if (y !== null) {\n        tmpVec.set(x, y * zFactor);\n        tmpVec.sub(vecAtEnd);\n        dir.add(tmpVec);\n      }\n    }\n\n    return dir;\n  }\n\n  calcAreaDir(\n    top: number[][],\n    bottom: number[][],\n    offset: number,\n    count: number,\n    step: number,\n    initalVector: Vector2 = Vector2.left,\n    topLimit: number,\n    bottomLimit: number,\n    minReductionAngle = 0,\n    maxReductionAngle: number = Math.PI / 4,\n    angleReductionExponent = 4,\n    alternativeSurfaceBottomData: number[][],\n    surfaces: SurfaceArea[] | null = null,\n    currentSurfaceIndex: number,\n  ): number {\n    const angles: number[] = [];\n    const tmpVec = Vector2.zero.mutable;\n    let vecAtEnd: Vector2;\n    for (let i = 0; i <= count; i++) {\n      const x = offset + i * step;\n      const topY = findSampleAtPos(top, x, topLimit, bottomLimit);\n      const bottomY = findSampleAtPos(bottom, x, topLimit, bottomLimit) || bottomLimit;\n      // Find position of next surface in case it's higher than current base\n      const alternativeBottomY = this.getAlternativeYValueIfAvailable(\n        x,\n        topLimit,\n        bottomLimit,\n        alternativeSurfaceBottomData,\n        surfaces,\n        currentSurfaceIndex,\n      );\n      // Use topmost of value from current surface and alternative surface\n      const usedBottomY = alternativeBottomY ? Math.min(bottomY, alternativeBottomY) : bottomY;\n      if (i === 0) {\n        if (topY === null) {\n          return Vector2.angleRight(initalVector);\n        }\n        const startY = (topY + usedBottomY) / 2;\n        vecAtEnd = new Vector2(offset, startY);\n      } else {\n        if (topY !== null) {\n          tmpVec.set(x, (topY + usedBottomY) / 2);\n          tmpVec.sub(vecAtEnd!);\n\n          angles.push(Vector2.angleRight(tmpVec));\n        } else {\n          angles.push(Vector2.angleRight(initalVector));\n        }\n      }\n    }\n\n    const refAngle = angles[0]!;\n    const offsetAngles = angles.map((d: number) => d - refAngle);\n    let factors = 0;\n    const offsetSum = offsetAngles.reduce((acc: number, v: number) => {\n      const ratio = (Math.abs(v) - minReductionAngle) / maxReductionAngle;\n      const factor = Math.pow(1 - clamp(ratio, 0, 1), angleReductionExponent);\n      factors += factor;\n      return acc + v * factor;\n    }, 0);\n    const angle = offsetSum / factors + refAngle;\n    return angle;\n  }\n\n  updateXFlipped(): void {\n    const { xBounds } = this.rescaleEvent!;\n    this.isXFlipped = xBounds[0] > xBounds[1];\n  }\n\n  getMarginsInWorldCoordinates(): number {\n    const { xRatio } = this.rescaleEvent!;\n    const margins = (this.options.margins || this.defaultMargins) * (this.isXFlipped ? -1 : 1);\n    const marginsInWorldCoords = margins / xRatio;\n    return marginsInWorldCoords;\n  }\n\n  getSurfacesAreaEdges(): number[] {\n    const endPoints =\n      this.data?.areas.reduce((acc, area) => {\n        const { data } = area;\n        const firstValidPoint = data.find((d: number[]) => d[1] != null);\n        if (firstValidPoint) {\n          acc.push(firstValidPoint[0]!);\n        }\n        // TODO: Use findLast() when TypeScript stops complaining about it\n        for (let i = data.length - 1; i >= 0; i--) {\n          if (data[i]?.[1] != null) {\n            acc.push(data[i]?.[0]!);\n            break;\n          }\n        }\n\n        return acc;\n      }, [] as number[]) ?? [];\n    endPoints.push(\n      ...(this.data?.lines.reduce((acc, line) => {\n        const { data } = line;\n        const firstValidPoint = data.find((d: number[]) => d[1] != null);\n        if (firstValidPoint) {\n          acc.push(firstValidPoint[0]!);\n        }\n        // TODO: Use findLast() when TypeScript stops complaining about it\n        for (let i = data.length - 1; i >= 0; i--) {\n          if (data[i]?.[1] != null) {\n            acc.push(data[i]?.[0]!);\n            break;\n          }\n        }\n        return acc;\n      }, [] as number[]) ?? []),\n    );\n\n    const minX = Math.min(...endPoints);\n    const maxX = Math.max(...endPoints);\n    const marginsInWorldCoords = this.getMarginsInWorldCoordinates();\n    const { isXFlipped } = this;\n    const surfaceAreaLeftEdge = isXFlipped ? maxX + marginsInWorldCoords : minX + marginsInWorldCoords;\n    const surfaceAreaRightEdge = isXFlipped ? minX - marginsInWorldCoords : maxX - marginsInWorldCoords;\n    return [surfaceAreaLeftEdge, surfaceAreaRightEdge];\n  }\n\n  checkDrawLabelsOnLeftSide(): boolean {\n    const { referenceSystem, isXFlipped } = this;\n    if (!referenceSystem) {\n      return true;\n    }\n\n    const { xScale, yScale, xRatio } = this.rescaleEvent!;\n    const t = 200; // TODO: Use actual size of largest label or average size of all\n\n    const [dx1, dx2] = xScale.domain() as [number, number];\n    const [dy1, dy2] = yScale.domain() as [number, number];\n\n    let top = referenceSystem.interpolators.curtain.getIntersects(dy1, 1, 0) as number[][];\n    if (top.length === 0) {\n      top = [referenceSystem.interpolators.curtain.getPointAt(0.0) as number[]];\n    }\n    let bottom = referenceSystem.interpolators.curtain.getIntersects(dy2, 1, 0) as number[][];\n    if (bottom.length === 0) {\n      bottom = [referenceSystem.interpolators.curtain.getPointAt(1.0) as number[]];\n    }\n\n    const maxX = Math.max(top[0]?.[0]!, bottom[0]?.[0]!);\n    const minX = Math.min(top[0]?.[0]!, bottom[0]?.[0]!);\n\n    const wbBBox = {\n      left: isXFlipped ? maxX : minX,\n      right: isXFlipped ? minX : maxX,\n    };\n\n    const margin = this.getMarginsInWorldCoordinates();\n    const screenLeftEdge = dx1 + margin;\n    const screenRightEdge = dx2 - margin;\n\n    const [surfaceAreaLeftEdge, surfaceAreaRightEdge] = this.getSurfacesAreaEdges() as [number, number];\n\n    const leftLimit = isXFlipped ? Math.min(screenLeftEdge, surfaceAreaLeftEdge) : Math.max(screenLeftEdge, surfaceAreaLeftEdge);\n    const rightLimit = isXFlipped ? Math.max(screenRightEdge, surfaceAreaRightEdge) : Math.min(screenRightEdge, surfaceAreaRightEdge);\n\n    const spaceOnLeftSide = Math.max(isXFlipped ? leftLimit - wbBBox.left : wbBBox.left - leftLimit, 0);\n    const spaceOnRightSide = Math.max(isXFlipped ? wbBBox.right - rightLimit : rightLimit - wbBBox.right, 0);\n\n    const spaceOnLeftSideInScreenCoordinates = spaceOnLeftSide * xRatio;\n    const spaceOnRightSideInScreenCoordinates = spaceOnRightSide * xRatio;\n    const isLabelsOnLeftSide =\n      spaceOnLeftSide > spaceOnRightSide ||\n      spaceOnLeftSideInScreenCoordinates > t ||\n      (spaceOnLeftSideInScreenCoordinates < t && spaceOnRightSideInScreenCoordinates < t && isXFlipped) ||\n      bottom[0]?.[1]! < dy1;\n\n    return isLabelsOnLeftSide;\n  }\n}\n","import { Graphics } from 'pixi.js';\nimport { PixiLayer } from './base/PixiLayer';\nimport { OnUpdateEvent, OnRescaleEvent } from '../interfaces';\nimport { SurfaceArea, SurfaceData, SurfaceLine } from '../datautils';\nimport { SURFACE_LINE_WIDTH } from '../constants';\n\nconst DEFAULT_Y_BOTTOM = 10000;\n\nexport class GeomodelLayerV2<T extends SurfaceData> extends PixiLayer<T> {\n  private isPreRendered = false;\n\n  override onRescale(event: OnRescaleEvent): void {\n    super.onRescale(event);\n\n    if (!this.isPreRendered) {\n      this.clearLayer();\n      this.preRender();\n    }\n\n    this.render();\n  }\n\n  override onUpdate(event: OnUpdateEvent<T>): void {\n    super.onUpdate(event);\n\n    this.isPreRendered = false;\n    this.clearLayer();\n    this.preRender();\n    this.render();\n  }\n\n  preRender(): void {\n    const { data } = this;\n\n    if (!data) {\n      return;\n    }\n\n    data.areas.forEach((a) => this.generateAreaPolygon(a));\n    data.lines.forEach((l) => this.generateSurfaceLine(l));\n\n    this.isPreRendered = true;\n  }\n\n  createPolygons = (data: number[][]): number[][] => {\n    const polygons: number[][] = [];\n    let polygon: number[] | undefined;\n\n    // Start generating polygons\n    for (let i = 0; i < data.length; i++) {\n      // Generate top of polygon as long as we have valid values\n      const topIsValid = !!data[i]?.[1];\n      if (topIsValid) {\n        if (polygon == null) {\n          polygon = [];\n        }\n        polygon.push(data[i]?.[0]!, data[i]?.[1]!);\n      }\n\n      const endIsReached = i === data.length - 1;\n      if (!topIsValid || endIsReached) {\n        if (polygon) {\n          // Generate bottom of polygon\n          for (let j: number = !topIsValid ? i - 1 : i; j >= 0; j--) {\n            if (!data[j]?.[1]) {\n              break;\n            }\n            polygon.push(data[j]?.[0]!, data[j]?.[2] || DEFAULT_Y_BOTTOM);\n          }\n          polygons.push(polygon);\n          polygon = undefined;\n        }\n      }\n    }\n    return polygons;\n  };\n\n  generateAreaPolygon = (s: SurfaceArea): void => {\n    const g = new Graphics();\n    g.lineStyle(1, s.color as number, 1);\n    g.beginFill(s.color as number);\n    const polygons = this.createPolygons(s.data);\n    polygons.forEach((polygon: number[]) => g.drawPolygon(polygon));\n    g.endFill();\n    this.addChild(g);\n  };\n\n  generateSurfaceLine = (s: SurfaceLine): void => {\n    const g = new Graphics();\n    const { data: d } = s;\n\n    const alignment = 0.5;\n    g.lineStyle(SURFACE_LINE_WIDTH, s.color as number, 1, alignment, true);\n\n    let penDown = false;\n    for (let i = 0; i < d.length; i++) {\n      const lineData = d[i];\n      if (lineData && lineData[1] && lineData[0]) {\n        if (penDown) {\n          g.lineTo(lineData[0], lineData[1]);\n        } else {\n          g.moveTo(lineData[0], lineData[1]);\n          penDown = true;\n        }\n      } else {\n        penDown = false;\n      }\n    }\n    this.addChild(g);\n  };\n}\n"],"names":["DEFAULT_MARGINS","DEFAULT_MIN_FONT_SIZE","DEFAULT_MAX_FONT_SIZE","DEFAULT_TEXT_COLOR","DEFAULT_FONT","MAX_FONT_SIZE_IN_WORLD_COORDINATES","GeomodelLabelsLayer","CanvasLayer","id","options","surfaceArea","nextSurfaceArea","surfaces","i","data","ctx","maxFontSizeInWorldCoordinates","isXFlipped","xScale","yScale","xRatio","yRatio","zFactor","isLabelsOnLeftSide","marginsInWorldCoords","minFontSize","fontSizeInWorldCoords","leftEdge","rightEdge","surfaceAreaLeftEdge","surfaceAreaRightEdge","labelMetrics","labelLengthInWorldCoords","labelRightEdge","labelLeftEdge","startPos","portionOfLabelLengthUsedForPosCalc","topEdge","bottomEdge","dirSteps","posSteps","posStep","dirStep","topData","d","topPos","bottomData","bottomPos","Vector2","thickness","initialDirVec","areaDir","scaledAngle","textX","textY","textAngle","s","steps","step","pos","dir","SURFACE_LINE_WIDTH","textDir","areas","_a","acc","area","sumAndCount","a","avgTopDepth","event","array","topmostSurfaceNotDrawnYet","v","index","surfaceLine","color","hexString","offset","count","topLimit","bottomLimit","alternativeSurfaceData","currentSurfaceIndex","samples","x","y","findSampleAtPos","alternativeY","usedY","altY","si","altSurface","initalVector","startY","vecAtEnd","tmpVec","top","bottom","minReductionAngle","maxReductionAngle","angleReductionExponent","alternativeSurfaceBottomData","angles","topY","bottomY","alternativeBottomY","usedBottomY","refAngle","offsetAngles","factors","ratio","factor","clamp","xBounds","endPoints","firstValidPoint","_b","line","minX","maxX","referenceSystem","t","dx1","dx2","dy1","dy2","_c","_d","wbBBox","margin","screenLeftEdge","screenRightEdge","leftLimit","rightLimit","spaceOnLeftSide","spaceOnRightSide","spaceOnLeftSideInScreenCoordinates","spaceOnRightSideInScreenCoordinates","_e","DEFAULT_Y_BOTTOM","GeomodelLayerV2","PixiLayer","polygons","polygon","topIsValid","endIsReached","j","_f","g","Graphics","alignment","penDown","lineData","l"],"mappings":"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"}