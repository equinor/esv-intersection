{"version":3,"file":"SchematicLayer.d0a5c34c.js","sources":["../../../../node_modules/d3-array/src/max.js","../../../../node_modules/d3-array/src/sum.js","../../../../src/layers/schematicInterfaces.ts","../../../../src/utils/vectorUtils.ts","../../../../src/datautils/schematicShapeGenerator.ts","../../../../src/layers/CustomDisplayObjects/ComplexRopeGeometry.ts","../../../../src/layers/CustomDisplayObjects/ComplexRope.ts","../../../../src/layers/CustomDisplayObjects/FixedWidthSimpleRopeGeometry.ts","../../../../src/layers/CustomDisplayObjects/FixedWidthSimpleRope.ts","../../../../src/layers/CustomDisplayObjects/UniformTextureStretchRopeGeometry.ts","../../../../src/layers/CustomDisplayObjects/UniformTextureStretchRope.ts","../../../../src/layers/SchematicLayer.ts"],"sourcesContent":["export default function max(values, valueof) {\n  let max;\n  if (valueof === undefined) {\n    for (const value of values) {\n      if (value != null\n          && (max < value || (max === undefined && value >= value))) {\n        max = value;\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if ((value = valueof(value, ++index, values)) != null\n          && (max < value || (max === undefined && value >= value))) {\n        max = value;\n      }\n    }\n  }\n  return max;\n}\n","export default function sum(values, valueof) {\n  let sum = 0;\n  if (valueof === undefined) {\n    for (let value of values) {\n      if (value = +value) {\n        sum += value;\n      }\n    }\n  } else {\n    let index = -1;\n    for (let value of values) {\n      if (value = +valueof(value, ++index, values)) {\n        sum += value;\n      }\n    }\n  }\n  return sum;\n}\n","import { SHOE_LENGTH, SHOE_WIDTH } from '../constants';\n\nexport function assertNever(x: never): never {\n  throw new Error(`Unexpected object: ${JSON.stringify(x)}`);\n}\n\n/**\n * The closure type of the outline\n */\nexport type OutlineClosure = 'None' | 'TopAndBottom' | 'Top' | 'Bottom';\n\nexport interface HoleSize {\n  kind: 'hole';\n  id: string;\n  diameter: number;\n  start: number;\n  end: number;\n}\n\nexport interface CasingWindow {\n  id: string;\n  start: number;\n  end: number;\n}\n\nexport interface Casing {\n  kind: 'casing';\n  id: string;\n  diameter: number;\n  start: number;\n  end: number;\n  hasShoe: boolean;\n  innerDiameter: number;\n  windows?: CasingWindow[];\n}\n\ninterface SymbolComponent {\n  id: string;\n  diameter: number;\n  start: number;\n  end: number;\n  symbolKey: string;\n}\n\nexport interface PAndASymbol extends SymbolComponent {\n  kind: 'pAndASymbol';\n}\n\nexport const isPAndASymbol = (item: PAndA): item is PAndASymbol => item.kind === 'pAndASymbol';\n\nexport interface CementSqueeze {\n  kind: 'cementSqueeze';\n  id: string;\n  start: number;\n  end: number;\n  /**\n   * Referenced Casing and Completion ids\n   */\n  referenceIds: string[];\n}\n\nexport const isCementSqueeze = (item: PAndA): item is CementSqueeze => item.kind === 'cementSqueeze';\n\nexport interface CementPlug {\n  kind: 'cementPlug';\n  id: string;\n  start: number;\n  end: number;\n  /**\n   * Referenced Casing, Completion ids\n   */\n  referenceIds: string[];\n}\n\nexport const isCementPlug = (item: PAndA): item is CementSqueeze => item.kind === 'cementPlug';\n\nexport type PAndA = PAndASymbol | CementSqueeze | CementPlug;\n\ninterface BaseCompletion {\n  id: string;\n  diameter: number;\n  start: number;\n  end: number;\n}\n\nexport interface Screen extends BaseCompletion {\n  kind: 'screen';\n}\nexport interface Tubing extends BaseCompletion {\n  kind: 'tubing';\n}\n\nexport interface CompletionSymbol extends BaseCompletion {\n  kind: 'completionSymbol';\n  symbolKey: string;\n}\n\nexport type Completion = Tubing | Screen | CompletionSymbol;\n\nexport const foldCompletion =\n  <T>(fScreen: (obj: Screen) => T, fTubing: (obj: Tubing) => T, fSymbol: (obj: CompletionSymbol) => T) =>\n  (completion: Completion): T => {\n    switch (completion.kind) {\n      case 'screen':\n        return fScreen(completion);\n      case 'tubing':\n        return fTubing(completion);\n      case 'completionSymbol':\n        return fSymbol(completion);\n      default:\n        return assertNever(completion);\n    }\n  };\n\nexport interface Cement {\n  kind: 'cement';\n  id: string;\n  /**\n   *  Referenced Casing and Completion ids\n   */\n  referenceIds: string[];\n  toc: number;\n}\n\n/**\n * 'Open hole' and 'Open hole screen' are not included as they are not visualized and also not included in the ruleset\n */\nexport type PerforationSubKind =\n  | 'Perforation'\n  | 'Open hole gravel pack'\n  | 'Open hole frac pack'\n  | 'Cased hole frac pack'\n  | 'Cased hole gravel pack'\n  | 'Cased hole fracturation';\n\nexport interface Perforation {\n  kind: 'perforation';\n  subKind: PerforationSubKind;\n  id: string;\n  start: number;\n  end: number;\n  /**\n   * is the perforation open or sealed?\n   */\n  isOpen: boolean;\n}\n\nexport const foldPerforationSubKind = <T>(\n  options: {\n    Perforation: (kind: 'Perforation') => T;\n    OpenHoleGravelPack: (kind: 'Open hole gravel pack') => T;\n    OpenHoleFracPack: (kind: 'Open hole frac pack') => T;\n    CasedHoleGravelPack: (kind: 'Cased hole gravel pack') => T;\n    CasedHoleFracPack: (kind: 'Cased hole frac pack') => T;\n    CasedHoleFracturation: (kind: 'Cased hole fracturation') => T;\n  },\n  subKind: PerforationSubKind,\n) => {\n  switch (subKind) {\n    case 'Perforation':\n      return options.Perforation(subKind);\n\n    case 'Open hole gravel pack':\n      return options.OpenHoleGravelPack(subKind);\n\n    case 'Open hole frac pack':\n      return options.OpenHoleFracPack(subKind);\n\n    case 'Cased hole fracturation':\n      return options.CasedHoleFracturation(subKind);\n\n    case 'Cased hole frac pack':\n      return options.CasedHoleFracPack(subKind);\n\n    case 'Cased hole gravel pack':\n      return options.CasedHoleGravelPack(subKind);\n\n    default:\n      return assertNever(subKind);\n  }\n};\n\nexport const shouldPerforationStartAtHoleDiameter = (perf: Perforation) =>\n  foldPerforationSubKind(\n    {\n      Perforation: () => true,\n      OpenHoleGravelPack: () => true,\n      OpenHoleFracPack: () => false,\n      CasedHoleFracturation: () => false,\n      CasedHoleGravelPack: () => false,\n      CasedHoleFracPack: () => false,\n    },\n    perf.subKind,\n  );\n\nexport const shouldPerforationStartAtCasingDiameter = (perf: Perforation) =>\n  foldPerforationSubKind(\n    {\n      Perforation: () => false,\n      OpenHoleGravelPack: () => false,\n      OpenHoleFracPack: () => true,\n      CasedHoleFracturation: () => true,\n      CasedHoleGravelPack: () => true,\n      CasedHoleFracPack: () => true,\n    },\n    perf.subKind,\n  );\n\nexport const hasPacking = (perf: Perforation): boolean =>\n  foldPerforationSubKind(\n    {\n      Perforation: () => false,\n      OpenHoleGravelPack: () => true,\n      OpenHoleFracPack: () => true,\n      CasedHoleFracturation: () => false,\n      CasedHoleGravelPack: () => true,\n      CasedHoleFracPack: () => true,\n    },\n    perf.subKind,\n  );\n\nexport function hasFracLines(perf: Perforation): boolean {\n  return foldPerforationSubKind(\n    {\n      Perforation: () => false,\n      OpenHoleGravelPack: () => false,\n      OpenHoleFracPack: () => true,\n      CasedHoleFracturation: () => true,\n      CasedHoleGravelPack: () => false,\n      CasedHoleFracPack: () => true,\n    },\n    perf.subKind,\n  );\n}\n\nexport function hasSpikes(perf: Perforation): boolean {\n  return foldPerforationSubKind(\n    {\n      Perforation: () => true,\n      OpenHoleGravelPack: () => false,\n      OpenHoleFracPack: () => false,\n      CasedHoleFracturation: () => false,\n      CasedHoleGravelPack: () => false,\n      CasedHoleFracPack: () => false,\n    },\n    perf.subKind,\n  );\n}\n\nexport function isSubkindCasedHoleGravelPack(perf: Perforation): boolean {\n  return foldPerforationSubKind(\n    {\n      Perforation: () => false,\n      OpenHoleGravelPack: () => false,\n      OpenHoleFracPack: () => false,\n      CasedHoleFracturation: () => false,\n      CasedHoleGravelPack: () => true,\n      CasedHoleFracPack: () => false,\n    },\n    perf.subKind,\n  );\n}\n\nexport function isSubKindPerforation(perf: Perforation): boolean {\n  return foldPerforationSubKind(\n    {\n      Perforation: () => true,\n      OpenHoleGravelPack: () => false,\n      OpenHoleFracPack: () => false,\n      CasedHoleFracturation: () => false,\n      CasedHoleGravelPack: () => false,\n      CasedHoleFracPack: () => false,\n    },\n    perf.subKind,\n  );\n}\n\nexport function isSubKindCasedHoleFracPack(perf: Perforation): boolean {\n  return foldPerforationSubKind(\n    {\n      Perforation: () => false,\n      OpenHoleGravelPack: () => false,\n      OpenHoleFracPack: () => false,\n      CasedHoleFracturation: () => false,\n      CasedHoleGravelPack: () => false,\n      CasedHoleFracPack: () => true,\n    },\n    perf.subKind,\n  );\n}\n\nexport function isOpenHoleFracPack(perf: Perforation) {\n  return foldPerforationSubKind(\n    {\n      Perforation: () => false,\n      OpenHoleGravelPack: () => false,\n      OpenHoleFracPack: () => true,\n      CasedHoleFracturation: () => false,\n      CasedHoleGravelPack: () => false,\n      CasedHoleFracPack: () => false,\n    },\n    perf.subKind,\n  );\n}\n\nexport const intersect = (a: Perforation, b: Perforation): boolean => {\n  return a.start < b.end && a.end > b.start;\n};\n\nexport interface SchematicData {\n  holeSizes: HoleSize[];\n  casings: Casing[];\n  cements: Cement[];\n  completion: Completion[];\n  pAndA: PAndA[];\n  symbols: {\n    [key: string]: string;\n  };\n  perforations: Perforation[];\n}\n\nexport interface InternalLayerOptions {\n  holeLayerId: string;\n  casingLayerId: string;\n  completionLayerId: string;\n  cementLayerId: string;\n  pAndALayerId: string;\n  perforationLayerId: string;\n}\n\nexport const defaultInternalLayerOptions = (layerId: string): InternalLayerOptions => ({\n  holeLayerId: `${layerId}-hole`,\n  casingLayerId: `${layerId}-casing`,\n  completionLayerId: `${layerId}-completion`,\n  cementLayerId: `${layerId}-cement`,\n  pAndALayerId: `${layerId}-pAndA`,\n  perforationLayerId: `${layerId}-perforation`,\n});\n\nexport interface HoleOptions {\n  firstColor: string;\n  secondColor: string;\n  lineColor: string;\n}\n\nexport const defaultHoleOptions: HoleOptions = {\n  firstColor: '#8c541d',\n  secondColor: '#eee3d8',\n  lineColor: '#8b4513',\n};\n\nexport interface CasingShoeSize {\n  width: number;\n  length: number;\n}\n\nexport interface WindowOptions {\n  dashColor: string;\n  dashLength: number;\n  spaceLength: number;\n}\n\nexport interface CasingOptions {\n  solidColor: string;\n  lineColor: string;\n  shoeSize: CasingShoeSize;\n  windowOptions: WindowOptions;\n}\n\nexport const defaultCasingOptions: CasingOptions = {\n  solidColor: '#dcdcdc',\n  lineColor: '#575757',\n  shoeSize: {\n    width: SHOE_WIDTH,\n    length: SHOE_LENGTH,\n  },\n  windowOptions: {\n    dashColor: '#dc0000',\n    dashLength: 5,\n    spaceLength: 3,\n  },\n};\n\nexport interface PerforationOptions {\n  stroke: string;\n  yellow: string;\n  grey: string;\n  red: string;\n  outline: string;\n  transparent: string;\n  spikeWidth: number;\n  spikeLength: number;\n  packingOpacity: number;\n  fracLineLength: number;\n  fracLineCurve: number;\n  scalingFactor: number;\n}\n\nexport const defaultPerforationOptions: PerforationOptions = {\n  stroke: 'rgba(0, 0, 0, 0.25)',\n  yellow: '#FFFC00',\n  grey: 'gray',\n  red: '#FF5050',\n  outline: 'black',\n  transparent: 'rgba(255, 255, 255, 0)',\n  spikeWidth: 50,\n  spikeLength: 50,\n  packingOpacity: 0.5,\n  fracLineCurve: 10,\n  fracLineLength: 25,\n  scalingFactor: 25,\n};\n\nexport interface CementOptions {\n  firstColor: string;\n  secondColor: string;\n  scalingFactor: number;\n}\n\nexport const defaultCementOptions: CementOptions = {\n  firstColor: '#c7b9ab',\n  secondColor: '#5b5b5b',\n  scalingFactor: 4,\n};\n\nexport interface CementSqueezeOptions {\n  firstColor: string;\n  secondColor: string;\n  scalingFactor: number;\n}\n\nexport const defaultCementSqueezeOptions: CementSqueezeOptions = {\n  firstColor: '#8b6713',\n  secondColor: '#000000',\n  scalingFactor: 4,\n};\n\nexport interface ScreenOptions {\n  scalingFactor: number;\n  lineColor: string;\n}\n\nexport const defaultScreenOptions: ScreenOptions = {\n  scalingFactor: 4,\n  lineColor: '#63666a',\n};\n\nexport interface TubingOptions {\n  innerColor: string;\n  outerColor: string;\n  scalingFactor: number;\n}\n\nexport const defaultTubingOptions: TubingOptions = {\n  scalingFactor: 1,\n  innerColor: '#eeeeff',\n  outerColor: '#777788',\n};\n\nexport interface CementPlugOptions {\n  firstColor: string;\n  secondColor: string;\n  scalingFactor: number;\n}\n\nexport const defaultCementPlugOptions: CementPlugOptions = {\n  firstColor: '#c7b9ab',\n  secondColor: '#000000',\n  scalingFactor: 4,\n};\n","import { IPoint, Point } from 'pixi.js';\nimport Vector2 from '@equinor/videx-vector2';\n\nexport const pointToVector = (p: IPoint): Vector2 => new Vector2(p.x, p.y);\nexport const pointToArray = (p: IPoint): [number, number] => [p.x, p.y];\nexport const vectorToPoint = (v: Vector2): Point => new Point(v[0], v[1]);\nexport const vectorToArray = (v: Vector2): [number, number] => [v[0], v[1]];\nexport const arrayToPoint = (a: number[]): Point => new Point(a[0], a[1]);\nexport const arrayToVector = (a: number[]): Vector2 => new Vector2(a[0], a[1]);\n\nexport const calcDist = (prev: [number, number], point: [number, number]): number => {\n  return arrayToVector(point).sub(prev).magnitude;\n};\n\nexport const calcDistPoint = (prev: Point, point: Point): number => {\n  return pointToVector(point).sub(prev.x, prev.y).magnitude;\n};\n\nexport const calcNormal = (p1: Point, p2: Point): Point => {\n  const d = pointToVector(p2).sub(p1.x, p1.y);\n  d.x = d.y === 0 ? 1 : d.x;\n  d.y = d.x === 0 ? 1 : d.y;\n  return vectorToPoint(d.rotate90()); //TODO: normalize\n};\n\nexport const convertToUnitVector = (p: Point): Point => {\n  return vectorToPoint(pointToVector(p).normalize());\n};\n\nexport const createNormals = (points: IPoint[]): Vector2[] => {\n  if (points.length < 2) {\n    return [new Vector2(0)];\n  }\n\n  let n: Vector2;\n\n  return points.map((_coord, i, list) => {\n    if (i < list.length - 1) {\n      const p = pointToVector(list[i]);\n      const q = pointToVector(list[i + 1]);\n      const np = q.sub(p);\n      const rotate = np.rotate90();\n      n = rotate.normalized();\n      return n;\n    }\n\n    // reuse previous normal for last coord\n    return n;\n  });\n};\n\n// TODO check if this can be simplified and return Vector/number[]\nexport const offsetPoint = (point: IPoint, vector: Vector2, offset: number): Point => {\n  const p = pointToVector(point);\n  return vectorToPoint(p.add(vector.scale(offset)));\n};\n\nexport const offsetPoints = (points: IPoint[], vectors: Vector2[], offset: number): Point[] => {\n  if (points.length !== vectors.length) {\n    throw new Error('Number of vectors does not match number of points');\n  }\n\n  return points.map((point, index) => {\n    const vector = vectors[index];\n    return offsetPoint(point, vector, offset);\n  });\n};\n","import { groupD8, IPoint, Point, Rectangle, Texture, WRAP_MODES } from 'pixi.js';\nimport { DEFAULT_TEXTURE_SIZE } from '../constants';\nimport {\n  Casing,\n  CasingWindow,\n  Cement,\n  CementOptions,\n  CementPlug,\n  CementPlugOptions,\n  CementSqueeze,\n  CementSqueezeOptions,\n  Completion,\n  HoleOptions,\n  HoleSize,\n  ScreenOptions,\n  TubingOptions,\n  Perforation,\n  PerforationOptions,\n  foldPerforationSubKind,\n  intersect,\n  isSubKindCasedHoleFracPack,\n  isSubkindCasedHoleGravelPack,\n  PerforationSubKind,\n} from '../layers/schematicInterfaces';\nimport { ComplexRopeSegment } from '../layers/CustomDisplayObjects/ComplexRope';\nimport { createNormals, offsetPoints } from '../utils/vectorUtils';\n\nexport type PerforationShape = ComplexRopeSegment;\n\nexport interface TubularRenderingObject {\n  leftPath: Point[];\n  rightPath: Point[];\n}\n\nexport interface CasingRenderObject {\n  id: string;\n  kind: 'casing';\n  referenceDiameter: number;\n  referenceRadius: number;\n  casingWallWidth: number;\n  hasShoe: boolean;\n  bottom: number;\n  zIndex?: number;\n  sections: {\n    kind: 'casing' | 'casing-window';\n    leftPath: Point[];\n    rightPath: Point[];\n    pathPoints: Point[];\n    polygon: IPoint[];\n  }[];\n}\n\nexport const getEndLines = (\n  rightPath: IPoint[],\n  leftPath: IPoint[],\n): {\n  top: IPoint[];\n  bottom: IPoint[];\n} => {\n  return {\n    top: [rightPath[0], leftPath[0]],\n    bottom: [rightPath[rightPath.length - 1], leftPath[leftPath.length - 1]],\n  };\n};\n\nexport const makeTubularPolygon = (rightPath: Point[], leftPath: Point[]): Point[] => {\n  return [...leftPath, ...rightPath.map<Point>((d) => d.clone()).reverse()];\n};\n\nexport const overlaps = (top1: number, bottom1: number, top2: number, bottom2: number): boolean => top1 <= bottom2 && top2 <= bottom1;\n\nexport const strictlyOverlaps = (top1: number, bottom1: number, top2: number, bottom2: number): boolean => top1 < bottom2 && top2 < bottom1;\n\nexport const uniq = <T>(arr: T[]): T[] => Array.from<T>(new Set(arr));\n\nconst findIntersectingItems = (\n  start: number,\n  end: number,\n  otherStrings: (Casing | Completion)[],\n  holes: HoleSize[],\n): { overlappingHoles: HoleSize[]; overlappingOuterStrings: (Casing | Completion)[] } => {\n  const overlappingHoles = holes.filter((hole: HoleSize) => overlaps(start, end, hole.start, hole.end));\n\n  const overlappingOuterStrings = otherStrings.filter((casing: Casing | Completion) => overlaps(start, end, casing.start, casing.end));\n\n  return {\n    overlappingHoles,\n    overlappingOuterStrings,\n  };\n};\n\nexport const getUniqueDiameterChangeDepths = (\n  [intervalStart, intervalEnd]: [number, number],\n  diameterIntervals: { start: number; end: number }[],\n): number[] => {\n  const epsilon = 0.0001;\n  const diameterChangeDepths = diameterIntervals.flatMap(\n    (\n      d, // to find diameter right before/after object\n    ) => [d.start - epsilon, d.start, d.end, d.end + epsilon],\n  );\n  const trimmedChangedDepths = diameterChangeDepths.filter((d) => d >= intervalStart && d <= intervalEnd); // trim\n\n  trimmedChangedDepths.push(intervalStart);\n  trimmedChangedDepths.push(intervalEnd);\n\n  const uniqDepths = uniq(trimmedChangedDepths);\n  return uniqDepths.sort((a: number, b: number) => a - b);\n};\n\nconst getInnerStringDiameter = (stringType: Casing | Completion): number =>\n  stringType.kind === 'casing' ? stringType.innerDiameter : stringType.diameter;\n\nexport const findCementOuterDiameterAtDepth = (\n  attachedStrings: (Casing | Completion)[],\n  nonAttachedStrings: (Casing | Completion)[],\n  holes: HoleSize[],\n  depth: number,\n): number => {\n  const defaultCementWidth = 100; // Default to flow cement outside to show error in data\n\n  const attachedStringAtDepth = attachedStrings.find(\n    (casingOrCompletion: Casing | Completion) => casingOrCompletion.start <= depth && casingOrCompletion.end >= depth,\n  );\n  const attachedOuterDiameter = attachedStringAtDepth ? attachedStringAtDepth.diameter : 0;\n\n  const outerCasingAtDepth = nonAttachedStrings\n    .filter((casingOrCompletion: Casing | Completion) => getInnerStringDiameter(casingOrCompletion) > attachedOuterDiameter)\n    .sort((a: Casing | Completion, b: Casing | Completion) => getInnerStringDiameter(a) - getInnerStringDiameter(b)) // ascending\n    .find((casing) => casing.start <= depth && casing.end >= depth);\n\n  const holeAtDepth = holes.find((hole: HoleSize) => hole.start <= depth && hole.end >= depth && hole.diameter > attachedOuterDiameter);\n\n  if (outerCasingAtDepth) {\n    return getInnerStringDiameter(outerCasingAtDepth);\n  }\n\n  if (holeAtDepth) {\n    return holeAtDepth.diameter;\n  }\n\n  return defaultCementWidth;\n};\n\nexport const findPerforationOuterDiameterAtDepth = (\n  nonAttachedStrings: (Casing | Completion)[],\n  holes: HoleSize[],\n  depth: number,\n  perforationSubKind: PerforationSubKind,\n): number => {\n  const defaultPerforationWidth = 100; // Default to flow perforation outside to show error in data\n\n  const outerCasingAtDepth = nonAttachedStrings\n    .sort((a: Casing | Completion, b: Casing | Completion) => b.diameter - a.diameter) // descending\n    .find((casing) => casing.start <= depth && casing.end >= depth);\n\n  const holeAtDepth = holes.find((hole: HoleSize) => hole.start <= depth && hole.end >= depth);\n\n  if (outerCasingAtDepth && perforationSubKind !== 'Open hole frac pack' && perforationSubKind !== 'Open hole gravel pack') {\n    return getInnerStringDiameter(outerCasingAtDepth);\n  }\n\n  if (holeAtDepth) {\n    return holeAtDepth.diameter;\n  }\n\n  return defaultPerforationWidth;\n};\n\nexport const findCementPlugInnerDiameterAtDepth = (\n  attachedStrings: (Casing | Completion)[],\n  nonAttachedStrings: (Casing | Completion)[],\n  holes: HoleSize[],\n  depth: number,\n): number => {\n  // Default to flow cement outside to show error in data\n  const defaultCementWidth = 100;\n  const attachedStringAtDepth = attachedStrings\n    .sort((a: Casing | Completion, b: Casing | Completion) => getInnerStringDiameter(a) - getInnerStringDiameter(b)) // ascending\n    .find((casingOrCompletion) => casingOrCompletion.start <= depth && casingOrCompletion.end >= depth);\n\n  if (attachedStringAtDepth) {\n    return getInnerStringDiameter(attachedStringAtDepth);\n  }\n\n  // Start from an attached diameter\n  const minimumDiameter = attachedStrings.length ? Math.min(...attachedStrings.map((c) => getInnerStringDiameter(c))) : 0;\n  const nonAttachedStringAtDepth = nonAttachedStrings\n    .sort((a: Casing | Completion, b: Casing | Completion) => getInnerStringDiameter(a) - getInnerStringDiameter(b)) // ascending\n    .find(\n      (casingOrCompletion: Casing | Completion) =>\n        casingOrCompletion.start <= depth && casingOrCompletion.end >= depth && minimumDiameter <= getInnerStringDiameter(casingOrCompletion),\n    );\n\n  if (nonAttachedStringAtDepth) {\n    return getInnerStringDiameter(nonAttachedStringAtDepth);\n  }\n\n  const holeAtDepth = holes.find((hole) => hole.start <= depth && hole.end >= depth && hole.diameter);\n\n  if (holeAtDepth) {\n    return holeAtDepth.diameter;\n  }\n\n  return defaultCementWidth;\n};\n\nexport const createComplexRopeSegmentsForCement = (\n  cement: Cement,\n  casings: Casing[],\n  completion: Completion[],\n  holes: HoleSize[],\n  exaggerationFactor: number,\n  getPoints: (start: number, end: number) => Point[],\n): ComplexRopeSegment[] => {\n  const { attachedStrings, nonAttachedStrings } = splitByReferencedStrings(cement.referenceIds, casings, completion);\n\n  if (attachedStrings.length === 0) {\n    throw new Error(`Invalid cement data, can't find referenced casing/completion string for cement with id '${cement.id}'`);\n  }\n\n  attachedStrings.sort((a: Casing, b: Casing) => a.end - b.end); // ascending\n  const bottomOfCement = attachedStrings[attachedStrings.length - 1].end;\n\n  const { overlappingOuterStrings, overlappingHoles } = findIntersectingItems(cement.toc, bottomOfCement, nonAttachedStrings, holes);\n\n  const outerDiameterIntervals = [...overlappingOuterStrings, ...overlappingHoles].map((d) => ({\n    start: d.start,\n    end: d.end,\n  }));\n\n  const changeDepths = getUniqueDiameterChangeDepths([cement.toc, bottomOfCement], outerDiameterIntervals);\n\n  const diameterIntervals = changeDepths.flatMap((depth: number, index: number, list: number[]) => {\n    if (index === list.length - 1) {\n      return [];\n    }\n\n    const nextDepth = list[index + 1];\n    const diameterAtChangeDepth = findCementOuterDiameterAtDepth(attachedStrings, overlappingOuterStrings, overlappingHoles, depth);\n\n    return [{ top: depth, bottom: nextDepth, diameter: diameterAtChangeDepth * exaggerationFactor }];\n  });\n\n  const ropeSegments = diameterIntervals.map((interval) => ({\n    diameter: interval.diameter,\n    points: getPoints(interval.top, interval.bottom),\n  }));\n\n  return ropeSegments;\n};\n\nconst splitByReferencedStrings = (\n  referenceIds: string[],\n  casings: Casing[],\n  completion: Completion[],\n): { attachedStrings: (Casing | Completion)[]; nonAttachedStrings: (Casing | Completion)[] } =>\n  [...casings, ...completion].reduce(\n    (acc, current) => {\n      if (referenceIds.includes(current.id)) {\n        return { ...acc, attachedStrings: [...acc.attachedStrings, current] };\n      }\n      return { ...acc, nonAttachedStrings: [...acc.nonAttachedStrings, current] };\n    },\n    { attachedStrings: [], nonAttachedStrings: [] },\n  );\n\nexport const createComplexRopeSegmentsForCementSqueeze = (\n  squeeze: CementSqueeze,\n  casings: Casing[],\n  completion: Completion[],\n  holes: HoleSize[],\n  exaggerationFactor: number,\n  getPoints: (start: number, end: number) => Point[],\n): ComplexRopeSegment[] => {\n  const { attachedStrings, nonAttachedStrings } = splitByReferencedStrings(squeeze.referenceIds, casings, completion);\n\n  if (attachedStrings.length === 0) {\n    throw new Error(`Invalid cement squeeze data, can't find referenced casing/completion for squeeze with id '${squeeze.id}'`);\n  }\n\n  const { overlappingOuterStrings, overlappingHoles } = findIntersectingItems(squeeze.start, squeeze.end, nonAttachedStrings, holes);\n\n  const outerDiameterIntervals = [...overlappingOuterStrings, ...overlappingHoles].map((d) => ({\n    start: d.start,\n    end: d.end,\n  }));\n\n  const changeDepths = getUniqueDiameterChangeDepths([squeeze.start, squeeze.end], outerDiameterIntervals);\n\n  const diameterIntervals = changeDepths.flatMap((depth, index, list) => {\n    if (index === list.length - 1) {\n      return [];\n    }\n\n    const nextDepth = list[index + 1];\n\n    const diameterAtDepth = findCementOuterDiameterAtDepth(attachedStrings, overlappingOuterStrings, overlappingHoles, depth);\n\n    return [{ top: depth, bottom: nextDepth, diameter: diameterAtDepth * exaggerationFactor }];\n  });\n\n  const ropeSegments = diameterIntervals.map((interval) => ({\n    diameter: interval.diameter,\n    points: getPoints(interval.top, interval.bottom),\n  }));\n\n  return ropeSegments;\n};\n\nexport const createComplexRopeSegmentsForCementPlug = (\n  plug: CementPlug,\n  casings: Casing[],\n  completion: Completion[],\n  holes: HoleSize[],\n  exaggerationFactor: number,\n  getPoints: (start: number, end: number) => Point[],\n): ComplexRopeSegment[] => {\n  const { attachedStrings, nonAttachedStrings } = splitByReferencedStrings(plug.referenceIds, casings, completion);\n\n  const { overlappingHoles, overlappingOuterStrings } = findIntersectingItems(plug.start, plug.end, nonAttachedStrings, holes);\n  const innerDiameterIntervals = [...attachedStrings, ...overlappingHoles, ...overlappingOuterStrings].map((d) => ({\n    start: d.start,\n    end: d.end,\n  }));\n\n  const changeDepths = getUniqueDiameterChangeDepths([plug.start, plug.end], innerDiameterIntervals);\n\n  const diameterIntervals = changeDepths.flatMap((depth, index, list) => {\n    if (index === list.length - 1) {\n      return [];\n    }\n\n    const nextDepth = list[index + 1];\n    const diameterAtDepth = findCementPlugInnerDiameterAtDepth(attachedStrings, overlappingOuterStrings, overlappingHoles, depth);\n\n    return [{ top: depth, bottom: nextDepth, diameter: diameterAtDepth * exaggerationFactor }];\n  });\n\n  const ropeSegments = diameterIntervals.map((interval) => ({\n    diameter: interval.diameter,\n    points: getPoints(interval.top, interval.bottom),\n  }));\n\n  return ropeSegments;\n};\n\nconst createGradientFill = (\n  canvas: HTMLCanvasElement,\n  canvasCtx: CanvasRenderingContext2D,\n  firstColor: string,\n  secondColor: string,\n  startPctOffset: number,\n): CanvasGradient => {\n  const halfWayPct = 0.5;\n  const gradient = canvasCtx.createLinearGradient(0, 0, 0, canvas.height);\n  gradient.addColorStop(0, firstColor);\n  gradient.addColorStop(halfWayPct - startPctOffset, secondColor);\n  gradient.addColorStop(halfWayPct + startPctOffset, secondColor);\n  gradient.addColorStop(1, firstColor);\n\n  return gradient;\n};\n\nexport const createHoleBaseTexture = ({ firstColor, secondColor }: HoleOptions, width: number, height: number): Texture => {\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  const canvasCtx = canvas.getContext('2d');\n\n  canvasCtx.fillStyle = createGradientFill(canvas, canvasCtx, firstColor, secondColor, 0);\n  canvasCtx.fillRect(0, 0, canvas.width, canvas.height);\n\n  return Texture.from(canvas);\n};\n\nexport const createScreenTexture = ({ scalingFactor }: ScreenOptions): Texture => {\n  const canvas = document.createElement('canvas');\n  const size = DEFAULT_TEXTURE_SIZE * scalingFactor;\n  canvas.width = size;\n  canvas.height = size;\n  const canvasCtx = canvas.getContext('2d');\n\n  canvasCtx.fillStyle = 'white';\n  canvasCtx.fillRect(0, 0, canvas.width, canvas.height);\n\n  const baseLineWidth = size / 10; // eslint-disable-line no-magic-numbers\n  canvasCtx.strokeStyle = '#AAAAAA';\n  canvasCtx.lineWidth = baseLineWidth;\n  canvasCtx.beginPath();\n\n  const distanceBetweenLines = size / 3;\n  for (let i = -canvas.width; i < canvas.width; i++) {\n    canvasCtx.moveTo(-canvas.width + distanceBetweenLines * i, -canvas.height);\n    canvasCtx.lineTo(canvas.width + distanceBetweenLines * i, canvas.height * 2);\n  }\n  canvasCtx.stroke();\n  return Texture.from(canvas);\n};\n\nexport const createTubingTexture = ({ innerColor, outerColor, scalingFactor }: TubingOptions): Texture => {\n  const size = DEFAULT_TEXTURE_SIZE * scalingFactor;\n\n  const canvas = document.createElement('canvas');\n  canvas.width = size;\n  canvas.height = size;\n  const canvasCtx = canvas.getContext('2d');\n  const gradient = canvasCtx.createLinearGradient(0, 0, 0, size);\n\n  const innerColorStart = 0.3;\n  const innerColorEnd = 0.7;\n  gradient.addColorStop(0, outerColor);\n  gradient.addColorStop(innerColorStart, innerColor);\n  gradient.addColorStop(innerColorEnd, innerColor);\n  gradient.addColorStop(1, outerColor);\n\n  canvasCtx.fillStyle = gradient;\n  canvasCtx.fillRect(0, 0, canvas.width, canvas.height);\n\n  return Texture.from(canvas);\n};\n\nexport const createCementTexture = ({ firstColor, secondColor, scalingFactor }: CementOptions): Texture => {\n  const canvas = document.createElement('canvas');\n\n  const size = DEFAULT_TEXTURE_SIZE * scalingFactor;\n  const lineWidth = scalingFactor;\n  canvas.width = size;\n  canvas.height = size;\n  const canvasCtx = canvas.getContext('2d');\n\n  canvasCtx.fillStyle = firstColor;\n  canvasCtx.fillRect(0, 0, canvas.width, canvas.height);\n  canvasCtx.lineWidth = lineWidth;\n  canvasCtx.fillStyle = secondColor;\n  canvasCtx.beginPath();\n\n  const distanceBetweenLines = size / 12; // eslint-disable-line no-magic-numbers\n  for (let i = -canvas.width; i < canvas.width; i++) {\n    canvasCtx.moveTo(-canvas.width + distanceBetweenLines * i, -canvas.height);\n    canvasCtx.lineTo(canvas.width + distanceBetweenLines * i, canvas.height);\n  }\n  canvasCtx.stroke();\n\n  return Texture.from(canvas);\n};\n\nexport const createCementPlugTexture = ({ firstColor, secondColor, scalingFactor }: CementPlugOptions): Texture => {\n  const canvas = document.createElement('canvas');\n\n  const size = DEFAULT_TEXTURE_SIZE * scalingFactor;\n  canvas.width = size;\n  canvas.height = size;\n  const canvasCtx = canvas.getContext('2d');\n\n  canvasCtx.fillStyle = firstColor;\n  canvasCtx.fillRect(0, 0, canvas.width, canvas.height);\n  canvasCtx.lineWidth = scalingFactor;\n  canvasCtx.strokeStyle = secondColor;\n  canvasCtx.beginPath();\n\n  canvasCtx.setLineDash([20, 10]); // eslint-disable-line no-magic-numbers\n  const distanceBetweenLines = size / 12; // eslint-disable-line no-magic-numbers\n  for (let i = -canvas.width; i < canvas.width; i++) {\n    canvasCtx.moveTo(-canvas.width + distanceBetweenLines * i, -canvas.height);\n    canvasCtx.lineTo(canvas.width + distanceBetweenLines * i, canvas.height * 2);\n  }\n  canvasCtx.stroke();\n\n  return Texture.from(canvas);\n};\n\nexport const createCementSqueezeTexture = ({ firstColor, secondColor, scalingFactor }: CementSqueezeOptions): Texture => {\n  const canvas = document.createElement('canvas');\n\n  const size = DEFAULT_TEXTURE_SIZE * scalingFactor;\n  const lineWidth = scalingFactor;\n  canvas.width = size;\n  canvas.height = size;\n\n  const canvasCtx = canvas.getContext('2d');\n  canvasCtx.lineWidth = lineWidth;\n  canvasCtx.fillStyle = firstColor;\n  canvasCtx.strokeStyle = secondColor;\n\n  canvasCtx.fillRect(0, 0, canvas.width, canvas.height);\n  canvasCtx.beginPath();\n\n  canvasCtx.setLineDash([20, 10]); // eslint-disable-line no-magic-numbers\n  const distanceBetweenLines = size / 12; // eslint-disable-line no-magic-numbers\n  for (let i = -canvas.width; i < canvas.width; i++) {\n    canvasCtx.moveTo(-canvas.width + distanceBetweenLines * i, -canvas.height);\n    canvasCtx.lineTo(canvas.width + distanceBetweenLines * i, canvas.height * 2);\n  }\n  canvasCtx.stroke();\n\n  return Texture.from(canvas);\n};\n\nexport const createTubularRenderingObject = (radius: number, pathPoints: IPoint[]): TubularRenderingObject => {\n  const normals = createNormals(pathPoints);\n  const rightPath = offsetPoints(pathPoints, normals, radius);\n  const leftPath = offsetPoints(pathPoints, normals, -radius);\n\n  return { leftPath, rightPath };\n};\n\nexport type CasingInterval = {\n  kind: 'casing' | 'casing-window';\n  start: number;\n  end: number;\n};\n\nconst createCasingInterval = (start: number, end: number): CasingInterval => ({ kind: 'casing', start, end });\nconst createCasingWindowInterval = (start: number, end: number): CasingInterval => ({ kind: 'casing-window', start, end });\n\nexport const getCasingIntervalsWithWindows = (casing: Casing): CasingInterval[] => {\n  const result = (casing.windows || [])\n    .filter((cw: CasingWindow) => strictlyOverlaps(casing.start, casing.end, cw.start, cw.end))\n    .reduce<{ intervals: CasingInterval[]; lastBottom: number }>(\n      ({ intervals, lastBottom }, currentWindow: CasingWindow, index: number, list: CasingWindow[]) => {\n        const startCasingInterval: CasingInterval | null =\n          // last bottom before current start?\n          lastBottom < currentWindow.start ? createCasingInterval(lastBottom, currentWindow.start) : null;\n\n        const updatedLastBottom = startCasingInterval ? startCasingInterval.end : lastBottom;\n\n        const windowStart = Math.max(updatedLastBottom, currentWindow.start);\n        const windowEnd = Math.min(casing.end, currentWindow.end);\n        const windowInterval: CasingInterval = createCasingWindowInterval(windowStart, windowEnd);\n\n        const nextLastBottom = windowEnd;\n\n        const isLastWindow = index === list.length - 1;\n        const endCasingInterval: CasingInterval | null =\n          isLastWindow &&\n          // still room for a casing interval?\n          nextLastBottom < casing.end\n            ? createCasingInterval(nextLastBottom, casing.end)\n            : null;\n\n        const newIntervals: CasingInterval[] = [startCasingInterval, windowInterval, endCasingInterval].filter((i) => i);\n\n        return { intervals: [...intervals, ...newIntervals], lastBottom: nextLastBottom };\n      },\n      { intervals: [], lastBottom: casing.start },\n    );\n\n  if (!result.intervals.length) {\n    return [createCasingInterval(casing.start, casing.end)];\n  }\n\n  return result.intervals;\n};\n\nexport const prepareCasingRenderObject = (\n  exaggerationFactor: number,\n  casing: Casing,\n  getPathPoints: (start: number, end: number) => Point[],\n): CasingRenderObject => {\n  const exaggeratedDiameter = casing.diameter * exaggerationFactor;\n  const exaggeratedRadius = exaggeratedDiameter / 2;\n  const exaggeratedInnerDiameter = casing.innerDiameter * exaggerationFactor;\n  const exaggeratedInnerRadius = exaggeratedInnerDiameter / 2;\n  const casingWallWidth = exaggeratedRadius - exaggeratedInnerRadius;\n\n  const sections = getCasingIntervalsWithWindows(casing).map((casingInterval: CasingInterval) => {\n    const pathPoints = getPathPoints(casingInterval.start, casingInterval.end);\n    const { leftPath, rightPath } = createTubularRenderingObject(exaggeratedRadius, pathPoints);\n    return { kind: casingInterval.kind, leftPath, rightPath, pathPoints, polygon: makeTubularPolygon(leftPath, rightPath) };\n  });\n\n  return {\n    kind: 'casing',\n    id: casing.id,\n    referenceDiameter: exaggeratedDiameter,\n    referenceRadius: exaggeratedRadius,\n    sections,\n    casingWallWidth,\n    hasShoe: casing.hasShoe,\n    bottom: casing.end,\n  };\n};\n\nexport const createComplexRopeSegmentsForPerforation = (\n  perforation: Perforation,\n  casings: Casing[],\n  holes: HoleSize[],\n  exaggerationFactor: number,\n  getPoints: (start: number, end: number) => Point[],\n): ComplexRopeSegment[] => {\n  const { overlappingOuterStrings, overlappingHoles } = findIntersectingItems(perforation.start, perforation.end, casings, holes);\n\n  const outerDiameterIntervals = [...overlappingOuterStrings, ...overlappingHoles].map((d) => ({\n    start: d.start,\n    end: d.end,\n  }));\n\n  const changeDepths = getUniqueDiameterChangeDepths([perforation.start, perforation.end], outerDiameterIntervals);\n\n  const diameterIntervals = changeDepths.flatMap((depth, index, list) => {\n    if (index === list.length - 1) {\n      return [];\n    }\n\n    const nextDepth = list[index + 1];\n\n    const diameterAtDepth = findPerforationOuterDiameterAtDepth(overlappingOuterStrings, overlappingHoles, depth, perforation.subKind);\n\n    return [{ top: depth, bottom: nextDepth, diameter: diameterAtDepth * exaggerationFactor }];\n  });\n\n  const ropeSegments = diameterIntervals.map((interval) => {\n    const points = getPoints(interval.top, interval.bottom);\n\n    const diameter = interval.diameter;\n\n    return {\n      diameter,\n      points,\n    };\n  });\n\n  return ropeSegments;\n};\n\nconst drawPacking = (canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D, perforationOptions: PerforationOptions) => {\n  const { packingOpacity, yellow } = perforationOptions;\n\n  ctx.fillStyle = yellow;\n  ctx.strokeStyle = yellow;\n\n  const xy: [number, number] = [0, 0];\n  const wh: [number, number] = [canvas.width, canvas.height];\n  ctx.save();\n  ctx.globalAlpha = packingOpacity;\n  ctx.fillRect(...xy, ...wh);\n  ctx.restore();\n};\n\nconst drawFracLines = (\n  canvas: HTMLCanvasElement,\n  ctx: CanvasRenderingContext2D,\n  extendedPerfShapeDiameter: number,\n  perforationOptions: PerforationOptions,\n  startAt: 'diameter' | 'spike',\n) => {\n  const { fracLineCurve } = perforationOptions;\n\n  const amountOfSpikes = 10;\n  const spikeWidth = canvas.width / amountOfSpikes;\n\n  const diameter = (extendedPerfShapeDiameter / 3) * perforationOptions.scalingFactor;\n\n  const fracLineLength = diameter / 4;\n  const spikeLength = diameter / 2;\n  const offsetX = 0;\n  const offsetY = startAt === 'diameter' ? 0 : spikeLength;\n\n  const fracLines = () => {\n    for (let i = -1; i < amountOfSpikes; i++) {\n      const bottom: [number, number] = [i * spikeWidth + offsetX + spikeWidth / 2, canvas.height / 2 - fracLineLength - offsetY - fracLineLength];\n\n      ctx.beginPath();\n\n      const start: [number, number] = [...bottom];\n      const controlPoint1: [number, number] = [bottom[0] - fracLineCurve * 2, bottom[1] - fracLineLength / 4];\n      const middle: [number, number] = [bottom[0], bottom[1] - fracLineLength / 2];\n\n      const controlPoint2: [number, number] = [bottom[0] + fracLineCurve * 2, bottom[1] - fracLineLength / 2 - fracLineLength / 4];\n      const end: [number, number] = [bottom[0], bottom[1] - fracLineLength];\n\n      ctx.bezierCurveTo(...start, ...controlPoint1, ...middle);\n      ctx.bezierCurveTo(...middle, ...controlPoint2, ...end);\n\n      ctx.stroke();\n    }\n\n    for (let i = -1; i < amountOfSpikes; i++) {\n      const bottom: [number, number] = [i * spikeWidth + spikeWidth + offsetX + spikeWidth / 2, canvas.height / 2 + diameter / 2 + offsetY];\n\n      ctx.beginPath();\n\n      const start: [number, number] = [...bottom];\n      const controlPoint1: [number, number] = [bottom[0] - fracLineCurve * 2, bottom[1] + fracLineLength / 4];\n      const middle: [number, number] = [bottom[0], bottom[1] + fracLineLength / 2];\n\n      const controlPoint2: [number, number] = [bottom[0] + fracLineCurve * 2, bottom[1] + fracLineLength / 2 + fracLineLength / 4];\n      const end: [number, number] = [bottom[0], bottom[1] + fracLineLength];\n\n      ctx.bezierCurveTo(...start, ...controlPoint1, ...middle);\n      ctx.bezierCurveTo(...middle, ...controlPoint2, ...end);\n\n      ctx.stroke();\n    }\n  };\n\n  ctx.strokeStyle = perforationOptions.yellow;\n  ctx.lineWidth = 6;\n  ctx.save();\n  ctx.globalAlpha = perforationOptions.packingOpacity;\n  fracLines();\n  ctx.restore();\n  ctx.lineWidth = 1;\n  ctx.strokeStyle = perforationOptions.outline;\n  fracLines();\n\n  ctx.closePath();\n};\n\nconst drawSpikes = (\n  canvas: HTMLCanvasElement,\n  ctx: CanvasRenderingContext2D,\n  extendedPerfShapeDiameter: number,\n  perforationOptions: PerforationOptions,\n) => {\n  const amountOfSpikes = 10;\n  const spikeWidth = canvas.width / amountOfSpikes;\n  ctx.strokeStyle = perforationOptions.outline;\n\n  const diameter = (extendedPerfShapeDiameter / 3) * perforationOptions.scalingFactor;\n\n  ctx.lineWidth = 1;\n  const spikeLength = diameter / 2;\n  const offsetX = 0;\n\n  // left spikes\n  for (let i = 0; i <= amountOfSpikes; i++) {\n    const left: [number, number] = [i * spikeWidth + offsetX, canvas.height / 2 - diameter / 2];\n    const bottom: [number, number] = [left[0] - spikeWidth / 2, left[1] - spikeLength];\n    const right: [number, number] = [left[0] - spikeWidth, left[1]];\n\n    ctx.beginPath();\n    ctx.moveTo(...left);\n    ctx.lineTo(...bottom);\n    ctx.lineTo(...right);\n    ctx.fill();\n\n    ctx.lineWidth = 1;\n    ctx.stroke();\n  }\n\n  // right spikes\n  for (let i = 0; i <= amountOfSpikes; i++) {\n    const left: [number, number] = [i * spikeWidth + offsetX, canvas.height / 2 + diameter / 2];\n    const bottom: [number, number] = [left[0] - spikeWidth / 2, left[1] + spikeLength];\n    const right: [number, number] = [left[0] - spikeWidth, left[1]];\n\n    ctx.beginPath();\n    ctx.moveTo(...left);\n    ctx.lineTo(...bottom);\n    ctx.lineTo(...right);\n    ctx.fill();\n\n    ctx.lineWidth = 1;\n    ctx.stroke();\n  }\n\n  ctx.closePath();\n};\n\n// for visual debugging\n// if this shoes up, something is wrong\nconst errorTexture = (errorMessage = 'Error!', existingContext?: { canvas: HTMLCanvasElement; canvasCtx: CanvasRenderingContext2D }) => {\n  console.error(`${errorMessage}`);\n  const canvas = existingContext?.canvas || document.createElement('canvas');\n\n  const size = DEFAULT_TEXTURE_SIZE;\n  canvas.width = size / 2;\n  canvas.height = size;\n  const canvasCtx = existingContext?.canvasCtx || canvas.getContext('2d');\n\n  const xy: [number, number] = [0, 0];\n  const wh: [number, number] = [canvas.width, canvas.height];\n\n  canvasCtx.fillStyle = '#ff00ff';\n  canvasCtx.fillRect(...xy, ...wh);\n\n  const texture = new Texture(\n    Texture.from(canvas, { wrapMode: WRAP_MODES.CLAMP }).baseTexture,\n    null,\n    new Rectangle(0, 0, canvas.width, canvas.height),\n    null,\n    groupD8.MIRROR_HORIZONTAL,\n  );\n  return texture;\n};\n\nconst createPerforationCanvas = (\n  perfShape: ComplexRopeSegment,\n  options: PerforationOptions,\n): { canvas: HTMLCanvasElement; ctx: CanvasRenderingContext2D } => {\n  const canvas = document.createElement('canvas');\n  const perfShapeDiameter = perfShape.diameter;\n  const size = perfShapeDiameter * options.scalingFactor;\n  canvas.width = size / 2;\n  canvas.height = size;\n  const ctx = canvas.getContext('2d');\n\n  return { canvas, ctx };\n};\n\nconst createPerforationTexture = (canvas: HTMLCanvasElement) => {\n  const texture = new Texture(\n    Texture.from(canvas, { wrapMode: WRAP_MODES.CLAMP }).baseTexture,\n    null,\n    new Rectangle(0, 0, canvas.width, canvas.height),\n    null,\n    groupD8.MIRROR_HORIZONTAL,\n  );\n  return texture;\n};\n\n/**\n * @Perforation\n * If a perforation does not overlap with another perforations of type with gravel,\n * the perforation spikes are either red when open or grey when closed.\n * Open and closed refers to two fields on a perforation item referencing runs.\n *\n * If a perforation overlaps with another perforation of type with gravel and the perforation is open,\n * the perforation spikes should be yellow. If closed the perforation remains grey.\n *\n * Cased Hole Frac Pack:\n * Makes perforations of type \"Perforation\" yellow if overlapping and perforation are open.\n * If a perforation of type \"perforation\" is overlapping, the fracturation lines extends from the tip of the perforation spikes into formation.\n *\n * Cased Hole Gravel Pack:\n * Yellow gravel. Makes perforations of type \"Perforation\" yellow if overlapping and perforation are open.\n */\nconst createSubkindPerforationTexture = {\n  packing: () => errorTexture(),\n  fracLines: () => errorTexture(),\n  spikes: (\n    perforation: Perforation,\n    perfShape: ComplexRopeSegment,\n    otherPerforations: Perforation[],\n    perforationOptions: PerforationOptions,\n  ): Texture => {\n    const { canvas, ctx } = createPerforationCanvas(perfShape, perforationOptions);\n\n    const intersectionsWithCasedHoleGravel: boolean = otherPerforations.some(\n      (perf) => isSubkindCasedHoleGravelPack(perf) && intersect(perforation, perf),\n    );\n\n    const intersectionsWithCasedHoleFracPack: boolean = otherPerforations.some(\n      (perf) => isSubKindCasedHoleFracPack(perf) && intersect(perforation, perf),\n    );\n\n    const shouldDrawFracLines = intersectionsWithCasedHoleGravel || intersectionsWithCasedHoleFracPack;\n\n    if (shouldDrawFracLines) {\n      if (perforation.isOpen) {\n        ctx.fillStyle = perforationOptions.yellow;\n        ctx.strokeStyle = perforationOptions.yellow;\n      } else {\n        ctx.fillStyle = perforationOptions.grey;\n        ctx.strokeStyle = perforationOptions.grey;\n      }\n    } else {\n      if (perforation.isOpen) {\n        ctx.fillStyle = perforationOptions.red;\n        ctx.strokeStyle = perforationOptions.red;\n      } else {\n        ctx.fillStyle = perforationOptions.grey;\n        ctx.strokeStyle = perforationOptions.grey;\n      }\n    }\n\n    drawSpikes(canvas, ctx, perfShape.diameter, perforationOptions);\n\n    if (intersectionsWithCasedHoleFracPack) {\n      drawFracLines(canvas, ctx, perfShape.diameter, perforationOptions, 'spike');\n    }\n\n    return createPerforationTexture(canvas);\n  },\n};\n\n/**\n * @Cased_hole_fracturation\n * Yellow fracturation lines from casing OD into formation\n */\nconst createSubkindCasedHoleFracturationTexture = {\n  packing: () => errorTexture(),\n  fracLines: (perfShape: ComplexRopeSegment, perforationOptions: PerforationOptions): Texture => {\n    const { canvas, ctx } = createPerforationCanvas(perfShape, perforationOptions);\n    drawFracLines(canvas, ctx, perfShape.diameter, perforationOptions, 'diameter');\n    return createPerforationTexture(canvas);\n  },\n  spikes: () => errorTexture(),\n};\n\n/**\n * @Cased_hole_frac_pack\n * Yellow gravel and fracturation lines.\n * Makes perforations of type \"Perforation\" yellow if overlapping and perforation are open.\n * If no perforation of type \"perforation\" are overlapping, there are no fracturation lines and no spikes.\n * If a perforation of type \"perforation\" is overlapping, the fracturation lines extends from the tip of the perforation spikes into formation.\n */\nconst createSubkindCasedHoleFracPackTexture = {\n  packing: (perfShape: ComplexRopeSegment, perforationOptions: PerforationOptions): Texture => {\n    const { canvas, ctx } = createPerforationCanvas(perfShape, perforationOptions);\n    drawPacking(canvas, ctx, perforationOptions);\n    return createPerforationTexture(canvas);\n  },\n  fracLines: (perfShape: ComplexRopeSegment, perforationOptions: PerforationOptions) => {\n    const { canvas } = createPerforationCanvas(perfShape, perforationOptions);\n    return createPerforationTexture(canvas);\n  },\n  spikes: () => errorTexture(),\n};\n\n/**\n * @Cased_hole_gravel_pack\n * Yellow gravel. Makes perforations of type \"Perforation\" yellow if overlapping and perforation are open.\n */\nconst createSubkindCasedHoleGravelPackTexture = {\n  packing: (perfShape: ComplexRopeSegment, perforationOptions: PerforationOptions): Texture => {\n    const { canvas, ctx } = createPerforationCanvas(perfShape, perforationOptions);\n    drawPacking(canvas, ctx, perforationOptions);\n    return createPerforationTexture(canvas);\n  },\n  fracLines: () => errorTexture(),\n  spikes: () => errorTexture(),\n};\n\n/**\n * @Open_hole_gravel_pack\n * Yellow gravel\n */\nconst createSubkindOpenHoleGravelPackTexture = {\n  packing: (perfShape: ComplexRopeSegment, perforationOptions: PerforationOptions) => {\n    const { canvas, ctx } = createPerforationCanvas(perfShape, perforationOptions);\n    drawPacking(canvas, ctx, perforationOptions);\n    return createPerforationTexture(canvas);\n  },\n  fracLines: () => errorTexture(),\n  spikes: () => errorTexture(),\n};\n\n/**\n * @Open_hole_frac_pack\n * Yellow gravel. Yellow frac lines from hole OD into formation\n */\nconst createSubkindOpenHoleFracPackTexture = {\n  packing: (_perforation: Perforation, perfShape: ComplexRopeSegment, perforationOptions: PerforationOptions) => {\n    const { canvas, ctx } = createPerforationCanvas(perfShape, perforationOptions);\n    drawPacking(canvas, ctx, perforationOptions);\n    return createPerforationTexture(canvas);\n  },\n  fracLines: (perfShape: ComplexRopeSegment, perforationOptions: PerforationOptions): Texture => {\n    const { canvas, ctx } = createPerforationCanvas(perfShape, perforationOptions);\n    drawFracLines(canvas, ctx, perfShape.diameter, perforationOptions, 'diameter');\n    return createPerforationTexture(canvas);\n  },\n  spikes: () => errorTexture(),\n};\n\nexport const createPerforationPackingTexture = (\n  perforation: Perforation,\n  perfShape: ComplexRopeSegment,\n  perforationOptions: PerforationOptions,\n): Texture => {\n  return foldPerforationSubKind(\n    {\n      Perforation: () => createSubkindPerforationTexture.packing(),\n      CasedHoleFracturation: () => createSubkindCasedHoleFracPackTexture.packing(perfShape, perforationOptions),\n      CasedHoleFracPack: () => createSubkindCasedHoleFracPackTexture.packing(perfShape, perforationOptions),\n      OpenHoleGravelPack: () => createSubkindOpenHoleGravelPackTexture.packing(perfShape, perforationOptions),\n      OpenHoleFracPack: () => createSubkindOpenHoleFracPackTexture.packing(perforation, perfShape, perforationOptions),\n      CasedHoleGravelPack: () => createSubkindCasedHoleGravelPackTexture.packing(perfShape, perforationOptions),\n    },\n    perforation.subKind,\n  );\n};\n\nexport const createPerforationFracLineTexture = (\n  perforation: Perforation,\n  perfShape: ComplexRopeSegment,\n  perforationOptions: PerforationOptions,\n): Texture => {\n  return foldPerforationSubKind(\n    {\n      Perforation: () => createSubkindPerforationTexture.fracLines(),\n      OpenHoleGravelPack: () => createSubkindOpenHoleGravelPackTexture.fracLines(),\n      OpenHoleFracPack: () => createSubkindOpenHoleFracPackTexture.fracLines(perfShape, perforationOptions),\n      CasedHoleFracturation: () => createSubkindCasedHoleFracturationTexture.fracLines(perfShape, perforationOptions),\n      CasedHoleGravelPack: () => createSubkindCasedHoleGravelPackTexture.fracLines(),\n      CasedHoleFracPack: () => createSubkindCasedHoleFracPackTexture.fracLines(perfShape, perforationOptions),\n    },\n    perforation.subKind,\n  );\n};\n\nexport const createPerforationSpikeTexture = (\n  perforation: Perforation,\n  otherPerforations: Perforation[],\n  perfShape: ComplexRopeSegment,\n  perforationOptions: PerforationOptions,\n): Texture => {\n  return foldPerforationSubKind(\n    {\n      Perforation: () => createSubkindPerforationTexture.spikes(perforation, perfShape, otherPerforations, perforationOptions),\n      OpenHoleGravelPack: () => createSubkindOpenHoleGravelPackTexture.spikes(),\n      OpenHoleFracPack: () => createSubkindOpenHoleFracPackTexture.spikes(),\n      CasedHoleFracturation: () => createSubkindCasedHoleFracturationTexture.spikes(),\n      CasedHoleGravelPack: () => createSubkindCasedHoleGravelPackTexture.spikes(),\n      CasedHoleFracPack: () => createSubkindCasedHoleFracPackTexture.spikes(),\n    },\n    perforation.subKind,\n  );\n};\n","import { MeshGeometry } from 'pixi.js';\nimport { sum, max } from 'd3-array';\nimport { ComplexRopeSegment } from './ComplexRope';\n\n/**\n * RopeGeometry allows you to draw a geometry across several several segments of points and then manipulate these points.\n */\nexport class ComplexRopeGeometry extends MeshGeometry {\n  /** An array of segments with points and diameter that determine the rope. */\n  private segments: ComplexRopeSegment[];\n\n  /** Rope texture scale. */\n  private readonly textureScale: number; // TODO unused?\n\n  /**\n   * @param segments - An array of segments with points and diameter to construct this rope.\n   * @param textureScale - scaling factor for repeated texture. To create a tiling rope\n   *     set baseTexture.wrapMode to PIXI.WRAP_MODES.REPEAT and use a power of two texture.\n   */\n  constructor(segments: ComplexRopeSegment[], textureScale = 0) {\n    const pointCount = sum(segments, (segment) => segment.points.length);\n\n    // eslint-disable-next-line no-magic-numbers\n    super(new Float32Array(pointCount * 4), new Float32Array(pointCount * 4), new Uint16Array((pointCount - 1) * 6));\n\n    this.segments = segments;\n    this.textureScale = textureScale;\n\n    this.build();\n  }\n\n  /**\n   * The max width (i.e., thickness) of the rope.\n   * @readonly\n   */\n  get width(): number {\n    return max(this.segments, (segment) => segment.diameter);\n  }\n\n  /** Refreshes Rope indices and uvs */\n  private build(): void {\n    const segments = this.segments;\n\n    if (!segments) {\n      return;\n    }\n\n    const vertexBuffer = this.getBuffer('aVertexPosition');\n    const uvBuffer = this.getBuffer('aTextureCoord');\n    const indexBuffer = this.getIndex();\n\n    const pointCount = sum(segments, (segment) => segment.points.length);\n\n    // if too few points, or texture hasn't got UVs set yet just move on.\n    if (pointCount < 1) {\n      return;\n    }\n\n    // if the number of points has changed we will need to recreate the arraybuffers\n    if (vertexBuffer.data.length / 4 !== pointCount) {\n      vertexBuffer.data = new Float32Array(pointCount * 4);\n      uvBuffer.data = new Float32Array(pointCount * 4);\n      indexBuffer.data = new Uint16Array((pointCount - 1) * 6); // eslint-disable-line no-magic-numbers\n    }\n\n    const uvs = uvBuffer.data;\n    const indices = indexBuffer.data;\n\n    uvs[0] = 0;\n    uvs[1] = 0;\n    uvs[2] = 0;\n    uvs[3] = 1;\n\n    const segmentCount = segments.length;\n    const maxDiameter = max(segments, (segment) => segment.diameter);\n\n    let amount = 0;\n    let uvIndex = 0;\n    let indicesIndex = 0;\n    let indexCount = 0;\n\n    for (let i = 0; i < segmentCount; i++) {\n      let prev = segments[i].points[0];\n      const textureWidth = maxDiameter;\n      const radius = segments[i].diameter / maxDiameter / 2;\n\n      const total = segments[i].points.length; // - 1;\n\n      for (let j = 0; j < total; j++) {\n        // time to do some smart drawing!\n\n        // calculate pixel distance from previous point\n        const dx = prev.x - segments[i].points[j].x;\n        const dy = prev.y - segments[i].points[j].y;\n        const distance = Math.sqrt(dx * dx + dy * dy);\n\n        prev = segments[i].points[j];\n        amount += distance / textureWidth;\n\n        uvs[uvIndex] = amount;\n        uvs[uvIndex + 1] = 0.5 - radius;\n\n        uvs[uvIndex + 2] = amount;\n        uvs[uvIndex + 3] = 0.5 + radius;\n        uvIndex += 4;\n      }\n\n      for (let j = 0; j < total - 1; j++) {\n        indices[indexCount++] = indicesIndex;\n        indices[indexCount++] = indicesIndex + 1;\n        indices[indexCount++] = indicesIndex + 2;\n\n        indices[indexCount++] = indicesIndex + 2;\n        indices[indexCount++] = indicesIndex + 1;\n        indices[indexCount++] = indicesIndex + 3;\n        indicesIndex += 2;\n      }\n      indicesIndex += 2;\n    }\n\n    // ensure that the changes are uploaded\n    uvBuffer.update();\n    indexBuffer.update();\n\n    this.updateVertices();\n  }\n\n  /** refreshes vertices of Rope mesh */\n  public updateVertices(): void {\n    const segments = this.segments;\n    const pointCount = sum(segments, (segment) => segment.points.length);\n\n    if (pointCount < 1) {\n      return;\n    }\n\n    const segmentCount = segments.length;\n    let lastIndex = 0;\n    for (let i = 0; i < segmentCount; i++) {\n      let lastPoint = segments[i].points[0];\n      let nextPoint;\n      let perpX = 0;\n      let perpY = 0;\n\n      const vertices = this.buffers[0].data;\n      const total = segments[i].points.length;\n      let index = 0;\n      for (let j = 0; j < total; j++) {\n        const point = segments[i].points[j];\n        index = lastIndex + j * 4;\n\n        if (j < segments[i].points.length - 1) {\n          nextPoint = segments[i].points[j + 1];\n        } else {\n          nextPoint = point;\n        }\n\n        perpY = -(nextPoint.x - lastPoint.x);\n        perpX = nextPoint.y - lastPoint.y;\n\n        const perpLength = Math.sqrt(perpX * perpX + perpY * perpY);\n        const num = segments[i].diameter / 2;\n\n        perpX /= perpLength;\n        perpY /= perpLength;\n\n        perpX *= num;\n        perpY *= num;\n\n        vertices[index] = point.x + perpX;\n        vertices[index + 1] = point.y + perpY;\n        vertices[index + 2] = point.x - perpX;\n        vertices[index + 3] = point.y - perpY;\n        lastPoint = point;\n      }\n      lastIndex = index + 4;\n    }\n\n    this.buffers[0].update();\n  }\n\n  public update(): void {\n    // TODO: Possible optimiztion to be had here\n    // Figure out if/when it is enough to only update verticies with this.updateVertices()\n    // See PIXI.SimpleRope.update() for ideas\n\n    // build() sets indicies and uvs and then calls this.updateVertices()\n    this.build();\n  }\n}\n","import { Mesh, MeshMaterial, IPoint, Renderer, Texture, WRAP_MODES } from 'pixi.js';\nimport { ComplexRopeGeometry } from './ComplexRopeGeometry';\n\nexport type ComplexRopeSegment = {\n  points: IPoint[];\n  diameter: number;\n};\n\n/**\n * The ComplexRope allows you to draw a texture across several segments of points and then manipulate these points\n */\nexport class ComplexRope extends Mesh {\n  /**\n   * re-calculate vertices by rope segment-points each frame\n   * @member {boolean}\n   */\n  public autoUpdate: boolean;\n\n  /**\n   * @param texture - The texture to use on the rope.\n   * @param segments - An array of segments with points and diaeter to construct this rope.\n   * @param {number} textureScale - Optional. Adjust interval of repeated texture\n   */\n  constructor(texture: Texture, segments: ComplexRopeSegment[], textureScale = 0) {\n    const ropeGeometry = new ComplexRopeGeometry(segments, textureScale);\n    const meshMaterial = new MeshMaterial(texture);\n\n    // attempt to set UV wrapping, will fail on non-power of two textures\n    texture.baseTexture.wrapMode = WRAP_MODES.REPEAT;\n\n    super(ropeGeometry, meshMaterial);\n\n    this.autoUpdate = true;\n  }\n\n  _render(renderer: Renderer): void {\n    const geometry: ComplexRopeGeometry = this.geometry as ComplexRopeGeometry;\n\n    if (this.autoUpdate) {\n      geometry.update();\n    }\n\n    super._render(renderer);\n  }\n}\n","import { IPoint, MeshGeometry } from 'pixi.js';\n\nexport class FixedWidthSimpleRopeGeometry extends MeshGeometry {\n  public points: IPoint[];\n  _width: number;\n  /**\n   * @param {number} [width=200] - The width (i.e., thickness) of the rope.\n   * @param {PIXI.Point[]} [points] - An array of PIXI.Point objects to construct this rope.\n   */\n  constructor(points: IPoint[], width = 200) {\n    // eslint-disable-next-line no-magic-numbers\n    super(new Float32Array(points.length * 4), new Float32Array(points.length * 4), new Uint16Array((points.length - 1) * 6));\n    /**\n     * An array of points that determine the rope\n     * @member {PIXI.Point[]}\n     */\n    this.points = points;\n    /**\n     * The width (i.e., thickness) of the rope.\n     * @member {number}\n     * @readOnly\n     */\n    this._width = width;\n    /**\n     * Rope texture scale, if zero then the rope texture is stretched.\n     * @member {number}\n     * @readOnly\n     */\n    this.build();\n  }\n  /**\n   * The width (i.e., thickness) of the rope.\n   * @member {number}\n   * @readOnly\n   */\n  get width(): number {\n    return this._width;\n  }\n  /**\n   * Refreshes Rope indices and uvs\n   * @private\n   */\n  private build(): void {\n    const points = this.points;\n    if (!points) {\n      return;\n    }\n    const vertexBuffer = this.getBuffer('aVertexPosition');\n    const uvBuffer = this.getBuffer('aTextureCoord');\n    const indexBuffer = this.getIndex();\n    // if too little points, or texture hasn't got UVs set yet just move on.\n    if (points.length < 1) {\n      return;\n    }\n    // if the number of points has changed we will need to recreate the arraybuffers\n    if (vertexBuffer.data.length / 4 !== points.length) {\n      vertexBuffer.data = new Float32Array(points.length * 4);\n      uvBuffer.data = new Float32Array(points.length * 4);\n      // eslint-disable-next-line no-magic-numbers\n      indexBuffer.data = new Uint16Array((points.length - 1) * 6);\n    }\n    const uvs = uvBuffer.data;\n    const indices = indexBuffer.data;\n    uvs[0] = 0;\n    uvs[1] = 0;\n    uvs[2] = 0;\n    uvs[3] = 1;\n    let amount = 0;\n    let prev = points[0];\n    const total = points.length; // - 1;\n    for (let i = 0; i < total; i++) {\n      // time to do some smart drawing!\n      const index = i * 4;\n\n      // calculate pixel distance from previous point\n      const dx = prev.x - points[i].x;\n      const dy = prev.y - points[i].y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n      prev = points[i];\n      amount += distance / this._width;\n\n      uvs[index] = amount;\n      uvs[index + 1] = 0;\n      uvs[index + 2] = amount;\n      uvs[index + 3] = 1;\n    }\n    let indexCount = 0;\n    for (let i = 0; i < total - 1; i++) {\n      const index = i * 2;\n      indices[indexCount++] = index;\n      indices[indexCount++] = index + 1;\n      indices[indexCount++] = index + 2;\n      indices[indexCount++] = index + 2;\n      indices[indexCount++] = index + 1;\n      indices[indexCount++] = index + 3;\n    }\n    // ensure that the changes are uploaded\n    uvBuffer.update();\n    indexBuffer.update();\n    this.updateVertices();\n  }\n  /**\n   * refreshes vertices of Rope mesh\n   */\n  public updateVertices(): void {\n    const points = this.points;\n    if (points.length < 1) {\n      return;\n    }\n    let lastPoint = points[0];\n    let nextPoint;\n    let perpX = 0;\n    let perpY = 0;\n    const vertices = this.buffers[0].data;\n    const total = points.length;\n    for (let i = 0; i < total; i++) {\n      const point = points[i];\n      const index = i * 4;\n      if (i < points.length - 1) {\n        nextPoint = points[i + 1];\n      } else {\n        nextPoint = point;\n      }\n      perpY = -(nextPoint.x - lastPoint.x);\n      perpX = nextPoint.y - lastPoint.y;\n      // eslint-disable-next-line no-magic-numbers\n      let ratio = (1 - i / (total - 1)) * 10;\n      if (ratio > 1) {\n        ratio = 1;\n      }\n      const perpLength = Math.sqrt(perpX * perpX + perpY * perpY);\n      const num = this._width / 2;\n      perpX /= perpLength;\n      perpY /= perpLength;\n      perpX *= num;\n      perpY *= num;\n      vertices[index] = point.x + perpX;\n      vertices[index + 1] = point.y + perpY;\n      vertices[index + 2] = point.x - perpX;\n      vertices[index + 3] = point.y - perpY;\n      lastPoint = point;\n    }\n    this.buffers[0].update();\n  }\n\n  public update(): void {\n    this.build();\n  }\n}\n","import { IPoint, Mesh, MeshMaterial, Renderer, RopeGeometry, Texture, WRAP_MODES } from 'pixi.js';\nimport { FixedWidthSimpleRopeGeometry } from './FixedWidthSimpleRopeGeometry';\n\n/**\n * The rope allows you to draw a texture across several points and then manipulate these points\n * Width of rope is given in constructor\n */\nexport class FixedWidthSimpleRope extends Mesh {\n  /**\n   * re-calculate vertices by rope points each frame\n   * @member {boolean}\n   */\n  public autoUpdate: boolean;\n\n  /**\n   * Note: The wrap mode of the texture is set to REPEAT if `textureScale` is positive.\n   * @param texture - The texture to use on the rope. (attempt to set UV wrapping, will fail on non-power of two textures)\n   * @param points - An array of {@link PIXI.Point} objects to construct this rope.\n   * @param width - Width of rope\n   */\n  constructor(texture: Texture, points: IPoint[], width: number) {\n    const ropeGeometry = new FixedWidthSimpleRopeGeometry(points, width);\n    const meshMaterial = new MeshMaterial(texture);\n\n    texture.baseTexture.wrapMode = WRAP_MODES.REPEAT;\n\n    super(ropeGeometry, meshMaterial);\n\n    this.autoUpdate = true;\n  }\n\n  _render(renderer: Renderer): void {\n    const geometry: RopeGeometry = this.geometry as RopeGeometry;\n\n    if (this.autoUpdate) {\n      geometry.update();\n    }\n\n    super._render(renderer);\n  }\n}\n","import { MeshGeometry } from 'pixi.js';\nimport type { IPoint } from 'pixi.js';\n\n/**\n * UniformTextureStretchRopeGeometry allows you to draw a geometry across several points and then manipulate these points.\n */\nexport class UniformTextureStretchRopeGeometry extends MeshGeometry {\n  /** An array of points that determine the rope. */\n  public points: IPoint[];\n\n  /**\n   * The width (i.e., thickness) of the rope.\n   * @readonly\n   */\n  _width: number;\n\n  /**\n   * @param width - The width (i.e., thickness) of the rope.\n   * @param points - An array of PIXI.Point objects to construct this rope.\n   */\n  constructor(points: IPoint[], width = 200) {\n    // eslint-disable-next-line no-magic-numbers\n    super(new Float32Array(points.length * 4), new Float32Array(points.length * 4), new Uint16Array((points.length - 1) * 6));\n\n    this.points = points;\n    this._width = width;\n\n    this.build();\n  }\n\n  /** Refreshes Rope indices and uvs */\n  private build(): void {\n    const points = this.points;\n\n    if (!points) {\n      return;\n    }\n\n    const vertexBuffer = this.getBuffer('aVertexPosition');\n    const uvBuffer = this.getBuffer('aTextureCoord');\n    const indexBuffer = this.getIndex();\n\n    // if too few points, or texture hasn't got UVs set yet just move on.\n    if (points.length < 1) {\n      return;\n    }\n\n    // if the number of points has changed we will need to recreate the arraybuffers\n    if (vertexBuffer.data.length / 4 !== points.length) {\n      vertexBuffer.data = new Float32Array(points.length * 4);\n      uvBuffer.data = new Float32Array(points.length * 4);\n      indexBuffer.data = new Uint16Array((points.length - 1) * 6); // eslint-disable-line no-magic-numbers\n    }\n\n    const total = points.length; // - 1;\n\n    let totalLength = 0;\n    let prevPoint = points[0];\n\n    for (let i = 0; i < total; i++) {\n      const dx = prevPoint.x - points[i].x;\n      const dy = prevPoint.y - points[i].y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      prevPoint = points[i];\n      totalLength += distance;\n    }\n\n    const uvs = uvBuffer.data;\n    const indices = indexBuffer.data;\n\n    uvs[0] = 0;\n    uvs[1] = 0;\n    uvs[2] = 0;\n    uvs[3] = 1;\n\n    let amount = 0;\n    let prev = points[0];\n\n    for (let i = 0; i < total; i++) {\n      // time to do some smart drawing!\n      const index = i * 4;\n\n      // calculate pixel distance from previous point\n      const dx = prev.x - points[i].x;\n      const dy = prev.y - points[i].y;\n      const distance = Math.sqrt(dx * dx + dy * dy);\n\n      prev = points[i];\n\n      // strech texture on distance/length instead of point/points.length to get a more correct strech\n      amount += distance / totalLength;\n\n      uvs[index] = amount;\n      uvs[index + 1] = 0;\n\n      uvs[index + 2] = amount;\n      uvs[index + 3] = 1;\n    }\n\n    let indexCount = 0;\n\n    for (let i = 0; i < total - 1; i++) {\n      const index = i * 2;\n\n      indices[indexCount++] = index;\n      indices[indexCount++] = index + 1;\n      indices[indexCount++] = index + 2;\n\n      indices[indexCount++] = index + 2;\n      indices[indexCount++] = index + 1;\n      indices[indexCount++] = index + 3;\n    }\n\n    // ensure that the changes are uploaded\n    uvBuffer.update();\n    indexBuffer.update();\n\n    this.updateVertices();\n  }\n\n  /** refreshes vertices of Rope mesh */\n  public updateVertices(): void {\n    const points = this.points;\n\n    if (points.length < 1) {\n      return;\n    }\n\n    let lastPoint = points[0];\n    let nextPoint;\n    let perpX = 0;\n    let perpY = 0;\n\n    const vertices = this.buffers[0].data;\n    const total = points.length;\n\n    for (let i = 0; i < total; i++) {\n      const point = points[i];\n      const index = i * 4;\n\n      if (i < points.length - 1) {\n        nextPoint = points[i + 1];\n      } else {\n        nextPoint = point;\n      }\n\n      perpY = -(nextPoint.x - lastPoint.x);\n      perpX = nextPoint.y - lastPoint.y;\n\n      const perpLength = Math.sqrt(perpX * perpX + perpY * perpY);\n      const num = this._width / 2;\n\n      perpX /= perpLength;\n      perpY /= perpLength;\n\n      perpX *= num;\n      perpY *= num;\n\n      vertices[index] = point.x + perpX;\n      vertices[index + 1] = point.y + perpY;\n      vertices[index + 2] = point.x - perpX;\n      vertices[index + 3] = point.y - perpY;\n\n      lastPoint = point;\n    }\n\n    this.buffers[0].update();\n  }\n\n  public update(): void {\n    this.updateVertices();\n  }\n}\n","import { IPoint, Mesh, MeshMaterial, Renderer, Texture } from 'pixi.js';\nimport { UniformTextureStretchRopeGeometry } from './UniformTextureStretchRopeGeometry';\n\n/**\n * The UniformTextureStretchRope allows you to draw a texture across several points and then manipulate these points\n */\nexport class UniformTextureStretchRope extends Mesh {\n  /**\n   * re-calculate vertices by rope points each frame\n   * @member {boolean}\n   */\n  public autoUpdate: boolean;\n\n  /**\n   * @param texture - The texture to use on the rope.\n   * @param points - An array of {@link PIXI.Point} objects to construct this rope.\n   */\n  constructor(texture: Texture, points: IPoint[]) {\n    const ropeGeometry = new UniformTextureStretchRopeGeometry(points, texture.height);\n    const meshMaterial = new MeshMaterial(texture);\n\n    super(ropeGeometry, meshMaterial);\n\n    this.autoUpdate = true;\n  }\n\n  _render(renderer: Renderer): void {\n    const geometry: UniformTextureStretchRopeGeometry = this.geometry as UniformTextureStretchRopeGeometry;\n\n    // TODO: Possible optimiztion here\n    // Find correct check for when to update geometry\n    if (this.autoUpdate || geometry._width !== this.shader.texture.height) {\n      geometry._width = this.shader.texture.height;\n      geometry.update();\n    }\n\n    super._render(renderer);\n  }\n}\n","import { max } from 'd3-array';\nimport { scaleLinear, ScaleLinear } from 'd3-scale';\nimport { Graphics, groupD8, IPoint, Point, Rectangle, RENDERER_TYPE, SimpleRope, Texture } from 'pixi.js';\nimport { DashLine } from 'pixi-dashed-line';\nimport { LayerOptions, PixiLayer, PixiRenderApplication } from '.';\nimport { DEFAULT_TEXTURE_SIZE, EXAGGERATED_DIAMETER, HOLE_OUTLINE, SCREEN_OUTLINE } from '../constants';\nimport {\n  assertNever,\n  Casing,\n  CasingOptions,\n  Cement,\n  CementOptions,\n  CementPlugOptions,\n  CementSqueeze,\n  CementSqueezeOptions,\n  foldCompletion,\n  HoleOptions,\n  HoleSize,\n  isCementSqueeze,\n  PAndA,\n  SchematicData,\n  ScreenOptions,\n  TubingOptions,\n  Screen,\n  Tubing,\n  CompletionSymbol,\n  isPAndASymbol,\n  isCementPlug,\n  CementPlug,\n  PAndASymbol,\n  InternalLayerOptions,\n  defaultHoleOptions,\n  defaultCasingOptions,\n  defaultCementOptions,\n  defaultCementSqueezeOptions,\n  defaultCementPlugOptions,\n  defaultScreenOptions,\n  defaultTubingOptions,\n  defaultInternalLayerOptions,\n  Perforation,\n  PerforationOptions,\n  defaultPerforationOptions,\n  Completion,\n  OutlineClosure,\n  hasPacking,\n  hasFracLines,\n  hasSpikes,\n} from './schematicInterfaces';\nimport {\n  CasingRenderObject,\n  createCementTexture,\n  createComplexRopeSegmentsForCement,\n  createComplexRopeSegmentsForCementSqueeze,\n  createComplexRopeSegmentsForCementPlug,\n  createHoleBaseTexture,\n  createScreenTexture,\n  createTubingTexture,\n  createTubularRenderingObject,\n  makeTubularPolygon,\n  prepareCasingRenderObject,\n  createCementPlugTexture,\n  createComplexRopeSegmentsForPerforation,\n  createPerforationPackingTexture,\n  PerforationShape,\n  createCementSqueezeTexture,\n  createPerforationFracLineTexture,\n  createPerforationSpikeTexture,\n} from '../datautils/schematicShapeGenerator';\nimport { OnUpdateEvent, OnRescaleEvent, OnUnmountEvent } from '../interfaces';\nimport { convertColor } from '../utils/color';\nimport { createNormals, offsetPoint, offsetPoints } from '../utils/vectorUtils';\nimport { ComplexRope, ComplexRopeSegment } from './CustomDisplayObjects/ComplexRope';\nimport { FixedWidthSimpleRope } from './CustomDisplayObjects/FixedWidthSimpleRope';\nimport { UniformTextureStretchRope } from './CustomDisplayObjects/UniformTextureStretchRope';\n\ninterface ScalingFactors {\n  height: number;\n  zFactor: number;\n  yScale: ScaleLinear<number, number, never>;\n}\n\ninterface SymbolRenderObject {\n  pathPoints: Point[];\n  referenceDiameter: number;\n  symbolKey: string;\n}\n\ninterface CementRenderObject {\n  kind: 'cement';\n  segments: ComplexRopeSegment[];\n  casingIds: string[];\n  zIndex?: number;\n}\n\ninterface CementSqueezeRenderObject {\n  kind: 'cementSqueeze';\n  segments: ComplexRopeSegment[];\n  casingIds: string[];\n  zIndex?: number;\n}\n\ntype InterlacedRenderObjects = CasingRenderObject | CementRenderObject | CementSqueezeRenderObject;\n\nconst foldInterlacedRenderObjects =\n  <T>(fCasing: (obj: CasingRenderObject) => T, fCement: (obj: CementRenderObject) => T, fCementSqueeze: (obj: CementSqueezeRenderObject) => T) =>\n  (renderObject: InterlacedRenderObjects): T => {\n    switch (renderObject.kind) {\n      case 'casing':\n        return fCasing(renderObject);\n      case 'cement':\n        return fCement(renderObject);\n      case 'cementSqueeze':\n        return fCementSqueeze(renderObject);\n      default:\n        return assertNever(renderObject);\n    }\n  };\n\nexport interface SchematicLayerOptions<T extends SchematicData> extends LayerOptions<T> {\n  exaggerationFactor?: number;\n  internalLayerOptions?: InternalLayerOptions;\n  holeOptions?: HoleOptions;\n  casingOptions?: CasingOptions;\n  cementOptions?: CementOptions;\n  cementSqueezeOptions?: CementSqueezeOptions;\n  screenOptions?: ScreenOptions;\n  tubingOptions?: TubingOptions;\n  cementPlugOptions?: CementPlugOptions;\n  perforationOptions?: PerforationOptions;\n}\n\nconst defaultSchematicLayerOptions = (layerId: string): SchematicLayerOptions<SchematicData> => ({\n  exaggerationFactor: 2,\n  internalLayerOptions: defaultInternalLayerOptions(layerId),\n  holeOptions: defaultHoleOptions,\n  casingOptions: defaultCasingOptions,\n  cementOptions: defaultCementOptions,\n  cementSqueezeOptions: defaultCementSqueezeOptions,\n  screenOptions: defaultScreenOptions,\n  tubingOptions: defaultTubingOptions,\n  cementPlugOptions: defaultCementPlugOptions,\n  perforationOptions: defaultPerforationOptions,\n});\n\ntype InternalLayerVisibility = { [K in keyof InternalLayerOptions]: boolean };\n\nexport class SchematicLayer<T extends SchematicData> extends PixiLayer<T> {\n  private internalLayerVisibility: InternalLayerVisibility = {\n    holeLayerId: true,\n    casingLayerId: true,\n    completionLayerId: true,\n    cementLayerId: true,\n    pAndALayerId: true,\n    perforationLayerId: true,\n  };\n\n  private cementTextureCache: Texture;\n  private cementSqueezeTextureCache: Texture;\n  private cementPlugTextureCache: Texture;\n  private holeTextureCache: Texture;\n  private screenTextureCache: Texture;\n  private tubingTextureCache: Texture;\n  private textureSymbolCacheArray: { [key: string]: Texture };\n\n  protected scalingFactors: ScalingFactors = {\n    height: 600,\n    zFactor: 1,\n    yScale: scaleLinear(),\n  };\n\n  constructor(ctx: PixiRenderApplication, id?: string, options?: SchematicLayerOptions<T>) {\n    super(ctx, id, options);\n    this.options = <SchematicLayerOptions<T>>{\n      ...this.options,\n      ...defaultSchematicLayerOptions(this.id),\n      ...options,\n    };\n  }\n\n  public onUnmount(event?: OnUnmountEvent): void {\n    super.onUnmount(event);\n    this.scalingFactors = null;\n    this.cementTextureCache = null;\n    this.cementSqueezeTextureCache = null;\n    this.holeTextureCache = null;\n    this.screenTextureCache = null;\n    this.tubingTextureCache = null;\n    this.textureSymbolCacheArray = null;\n    this.internalLayerVisibility = null;\n  }\n\n  public onUpdate(event: OnUpdateEvent<T>): void {\n    super.onUpdate(event);\n    this.clearLayer();\n    this.preRender();\n    this.render();\n  }\n\n  public override onRescale(event: OnRescaleEvent): void {\n    const shouldRecalculate = this.scalingFactors.zFactor !== event.zFactor;\n\n    this.scalingFactors = { height: event.height, zFactor: event.zFactor, yScale: event.yScale };\n    super.optionsRescale(event);\n    const yRatio = this.yRatio();\n    const flippedX = event.xBounds[0] > event.xBounds[1];\n    const flippedY = event.yBounds[0] > event.yBounds[1];\n    this.setContainerPosition(event.xScale(0), event.yScale(0));\n    this.setContainerScale(event.xRatio * (flippedX ? -1 : 1), yRatio * (flippedY ? -1 : 1));\n    if (shouldRecalculate) {\n      this.clearLayer();\n      this.preRender();\n    }\n\n    this.render();\n  }\n\n  public override setVisibility(isVisible: boolean, layerId: string) {\n    if (layerId === this.id) {\n      super.setVisibility(isVisible, layerId);\n      return;\n    }\n\n    const { internalLayerOptions } = this.options as SchematicLayerOptions<T>;\n\n    const [keyFound] = Object.entries(internalLayerOptions).find(([_key, id]: [string, string]) => id === layerId);\n    if (keyFound) {\n      this.internalLayerVisibility[keyFound as keyof InternalLayerVisibility] = isVisible;\n      this.clearLayer();\n      this.preRender();\n      this.render();\n    }\n  }\n\n  public override getInternalLayerIds(): string[] {\n    const { internalLayerOptions } = this.options as SchematicLayerOptions<T>;\n    return Object.values(internalLayerOptions);\n  }\n\n  /**\n   * Calculate yRatio without zFactor\n   * TODO consider to move this into ZoomPanHandler\n   */\n  protected yRatio(): number {\n    const domain = this.scalingFactors.yScale.domain();\n    const ySpan = domain[1] - domain[0];\n    const baseYSpan = ySpan * this.scalingFactors.zFactor;\n    const baseDomain = [domain[0], domain[0] + baseYSpan];\n    return Math.abs(this.scalingFactors.height / (baseDomain[1] - baseDomain[0]));\n  }\n\n  protected getZFactorScaledPathForPoints = (start: number, end: number): Point[] => {\n    const y = (y: number): number => y * this.scalingFactors.zFactor;\n\n    const path = this.referenceSystem.getCurtainPath(start, end, true);\n    return path.map((p) => new Point(p.point[0], y(p.point[1])));\n  };\n\n  protected drawBigPolygon = (coords: IPoint[], color = 0x000000) => {\n    const polygon = new Graphics();\n    polygon.beginFill(color);\n    polygon.drawPolygon(coords);\n    polygon.endFill();\n\n    this.addChild(polygon);\n  };\n\n  protected drawBigTexturedPolygon = (coords: Point[], t: Texture): Graphics => {\n    const polygon = new Graphics().beginTextureFill({ texture: t }).drawPolygon(coords).endFill();\n    this.addChild(polygon);\n    return polygon;\n  };\n\n  protected drawRope(path: Point[], texture: Texture, tint?: number): void {\n    if (path.length === 0) {\n      return null;\n    }\n\n    const rope: SimpleRope = new SimpleRope(texture, path, 1);\n\n    rope.tint = tint || rope.tint;\n\n    this.addChild(rope);\n  }\n\n  /**\n   *\n   * @param leftPath Points for line on left side\n   * @param rightPath Points for line on right side\n   * @param lineColor Color of line\n   * @param lineWidth Width of line\n   * @param outlineClosure If line should be drawn at top and/or bottom of the paths\n   * @param lineAlignment alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outer).\n   */\n  protected drawOutline(\n    leftPath: Point[],\n    rightPath: Point[],\n    lineColor: number,\n    lineWidth = 1,\n    outlineClosure: OutlineClosure = 'None',\n    lineAlignment = 1,\n  ): void {\n    const leftPathReverse = leftPath.map<Point>((d) => d.clone()).reverse();\n\n    const startPointRight = rightPath[0];\n    const startPointLeft = leftPathReverse[0];\n\n    const line = new Graphics();\n    line.lineStyle(lineWidth, lineColor, undefined, lineAlignment);\n    line.moveTo(startPointRight.x, startPointRight.y);\n    rightPath.forEach((p: Point) => line.lineTo(p.x, p.y));\n\n    if (outlineClosure === 'None' || outlineClosure === 'Top') {\n      line.moveTo(startPointLeft.x, startPointLeft.y);\n    }\n\n    leftPathReverse.forEach((p: Point) => line.lineTo(p.x, p.y));\n\n    if (outlineClosure === 'TopAndBottom' || outlineClosure === 'Top') {\n      line.lineTo(startPointRight.x, startPointRight.y);\n    }\n\n    this.addChild(line);\n  }\n\n  /**\n   * Uses a dashed outline on one side to represent casing window\n   * The casing window should be visualized at the upper side of the wellbore path\n   * @param leftPath Points for line on left side\n   * @param pointPath Points for line on right side\n   * @param lineColor Color of line\n   * @param lineWidth Width of line\n   * @param lineAlignment alignment of the line to draw, (0 = inner, 0.5 = middle, 1 = outer).\n   */\n  protected drawCasingWindowOutline(leftPath: Point[], rightPath: Point[], { lineColor, windowOptions }: CasingOptions, lineWidth = 1): void {\n    // Correct the dashed path. Should always be displayed on the upper side of the wellbore path.\n    const flippedPaths = !!this.referenceSystem?.options?.calculateDisplacementFromBottom;\n    const [linePath, dashedPath] = flippedPaths ? [leftPath, rightPath] : [rightPath, leftPath];\n    const [dashedAlignment, solidAlignment] = flippedPaths ? [1, 0] : [0, 1];\n\n    const graphics = new Graphics();\n    graphics.lineStyle(lineWidth, convertColor(lineColor), undefined, solidAlignment);\n\n    const startPointLinePath = linePath[0];\n    graphics.moveTo(startPointLinePath.x, startPointLinePath.y);\n    linePath.forEach((p: Point) => graphics.lineTo(p.x, p.y));\n\n    const dashedLine = new DashLine(graphics, {\n      dash: [windowOptions.dashLength, windowOptions.spaceLength],\n      color: convertColor(windowOptions.dashColor),\n      width: lineWidth,\n      alignment: dashedAlignment,\n    });\n\n    const startPointDashedPath = dashedPath[0];\n    dashedLine.moveTo(startPointDashedPath.x, startPointDashedPath.y);\n    dashedPath.forEach((currentPoint: Point) => {\n      dashedLine.lineTo(currentPoint.x, currentPoint.y);\n    });\n\n    this.addChild(graphics);\n  }\n\n  private perforationRopeAndTextureReferences: { rope: ComplexRope; texture: Texture }[] = [];\n\n  public preRender(): void {\n    if (!this.data || !this.referenceSystem) {\n      return;\n    }\n\n    const { exaggerationFactor } = this.options as SchematicLayerOptions<T>;\n    const { holeSizes, casings, cements, completion, symbols, pAndA, perforations } = this.data;\n\n    this.updateSymbolCache(symbols);\n\n    holeSizes.sort((a: HoleSize, b: HoleSize) => b.diameter - a.diameter);\n    const maxHoleDiameter = holeSizes.length > 0 ? max(holeSizes, (d) => d.diameter) * exaggerationFactor : EXAGGERATED_DIAMETER * exaggerationFactor;\n    if (this.internalLayerVisibility.holeLayerId) {\n      holeSizes.forEach((hole: HoleSize) => this.drawHoleSize(maxHoleDiameter, hole));\n    }\n\n    casings.sort((a: Casing, b: Casing) => b.diameter - a.diameter);\n    const casingRenderObjects: CasingRenderObject[] = casings.map((casing: Casing) => this.createCasingRenderObject(casing));\n\n    const cementShapes: CementRenderObject[] = cements.map(\n      (cement: Cement): CementRenderObject => ({\n        kind: 'cement',\n        segments: createComplexRopeSegmentsForCement(cement, casings, completion, holeSizes, exaggerationFactor, this.getZFactorScaledPathForPoints),\n        casingIds: (cement.referenceIds || []).filter((id) => id),\n      }),\n    );\n\n    const [cementSqueezes, remainingPAndA] = pAndA.reduce<[CementSqueeze[], Exclude<PAndA, CementSqueeze>[]]>(\n      ([squeezes, remaining], current: PAndA) =>\n        isCementSqueeze(current) ? [[current, ...squeezes], remaining] : [squeezes, [current, ...remaining]],\n      [[], []],\n    );\n\n    const cementSqueezesShape: CementSqueezeRenderObject[] = cementSqueezes.map((squeeze) => ({\n      kind: 'cementSqueeze',\n      segments: this.createCementSqueezeShape(squeeze, casings, completion, holeSizes),\n      casingIds: squeeze.referenceIds,\n    }));\n\n    this.sortCementAndCasingRenderObjects(casingRenderObjects, cementShapes, cementSqueezesShape).forEach(\n      foldInterlacedRenderObjects(\n        (casingRO: CasingRenderObject) => {\n          if (this.internalLayerVisibility.casingLayerId) {\n            this.drawCasing(casingRO);\n\n            if (casingRO.hasShoe) {\n              this.drawShoe(casingRO.bottom, casingRO.referenceRadius);\n            }\n          }\n        },\n        (cementRO: CementRenderObject) => {\n          if (this.internalLayerVisibility.cementLayerId) {\n            this.drawComplexRope(cementRO.segments, this.getCementTexture());\n          }\n        },\n        (cementSqueezesRO: CementSqueezeRenderObject) => {\n          if (this.internalLayerVisibility.pAndALayerId) {\n            this.drawComplexRope(cementSqueezesRO.segments, this.getCementSqueezeTexture());\n          }\n        },\n      ),\n    );\n\n    this.perforationRopeAndTextureReferences.forEach(({ rope, texture }) => {\n      rope.destroy({\n        children: true,\n        texture: true,\n        baseTexture: true,\n      });\n      texture.destroy(true);\n    });\n    this.perforationRopeAndTextureReferences = [];\n\n    if (this.internalLayerVisibility.perforationLayerId) {\n      const { perforationOptions } = this.options as SchematicLayerOptions<T>;\n      const packings = perforations.filter(hasPacking);\n      const fracLines = perforations.filter(hasFracLines);\n      const spikes = perforations.filter(hasSpikes);\n      packings.forEach((perforation) => {\n        const perfShapes = this.createPerforationShape(perforation, casings, holeSizes);\n        const perfShapesByDiameter: { [key: number]: ComplexRopeSegment[] } = perfShapes.reduce(\n          (dict: { [key: number]: ComplexRopeSegment[] }, ps) => {\n            if (!dict[ps.diameter]) {\n              dict[ps.diameter] = [];\n            }\n            dict[ps.diameter] = [...dict[ps.diameter], ps];\n            return dict;\n          },\n          {},\n        );\n        Object.values(perfShapesByDiameter).forEach((perfShapesWithSameDiameter) => {\n          const texture = createPerforationPackingTexture(perforation, perfShapesWithSameDiameter[0], perforationOptions);\n          const rope = this.drawComplexRope(perfShapesWithSameDiameter, texture);\n          this.perforationRopeAndTextureReferences.push({ rope, texture });\n        });\n      });\n\n      fracLines.forEach((perforation) => {\n        const perfShapes = this.createPerforationShape(perforation, casings, holeSizes);\n        const thiccPerfShapes = perfShapes.map((ps) => ({ ...ps, diameter: ps.diameter * 3 }));\n        const perfShapesByDiameter: { [key: number]: ComplexRopeSegment[] } = thiccPerfShapes.reduce(\n          (dict: { [key: number]: ComplexRopeSegment[] }, ps) => {\n            if (!dict[ps.diameter]) {\n              dict[ps.diameter] = [];\n            }\n            dict[ps.diameter] = [...dict[ps.diameter], ps];\n            return dict;\n          },\n          {},\n        );\n        Object.values(perfShapesByDiameter).forEach((perfShapesWithSameDiameter) => {\n          perfShapesWithSameDiameter.forEach((perfShape) => {\n            const texture = createPerforationFracLineTexture(perforation, perfShape, perforationOptions);\n            const rope = this.drawComplexRope([perfShape], texture);\n            this.perforationRopeAndTextureReferences.push({ rope, texture });\n          });\n        });\n      });\n      spikes.forEach((perforation) => {\n        const perfShapes = this.createPerforationShape(perforation, casings, holeSizes);\n        const thiccPerfShapes = perfShapes.map((ps) => ({ ...ps, diameter: ps.diameter * 3 }));\n        const perfShapesByDiameter: { [key: number]: ComplexRopeSegment[] } = thiccPerfShapes.reduce(\n          (dict: { [key: number]: ComplexRopeSegment[] }, ps) => {\n            if (!dict[ps.diameter]) {\n              dict[ps.diameter] = [];\n            }\n            dict[ps.diameter] = [...dict[ps.diameter], ps];\n            return dict;\n          },\n          {},\n        );\n        Object.values(perfShapesByDiameter).forEach((perfShapesWithSameDiameter) => {\n          perfShapesWithSameDiameter.forEach((perfShape) => {\n            const texture = createPerforationSpikeTexture(perforation, perforations, perfShape, perforationOptions);\n            const rope = this.drawComplexRope([perfShape], texture);\n            this.perforationRopeAndTextureReferences.push({ rope, texture });\n          });\n        });\n      });\n    }\n\n    if (this.internalLayerVisibility.completionLayerId) {\n      completion.forEach(\n        foldCompletion(\n          (obj: Screen) => this.drawScreen(obj),\n          (obj: Tubing) => this.drawTubing(obj),\n          (obj: CompletionSymbol) => {\n            const symbolRenderObject = this.prepareSymbolRenderObject(obj);\n            this.drawSymbolComponent(symbolRenderObject);\n          },\n        ),\n      );\n    }\n\n    if (this.internalLayerVisibility.pAndALayerId) {\n      remainingPAndA.forEach((obj) => {\n        if (isPAndASymbol(obj)) {\n          const symbolRenderObject = this.prepareSymbolRenderObject(obj);\n          this.drawSymbolComponent(symbolRenderObject);\n        }\n        if (isCementPlug(obj)) {\n          this.drawCementPlug(obj, casings, completion, holeSizes);\n        }\n      });\n    }\n  }\n\n  private updateSymbolCache(symbols: { [key: string]: string }) {\n    if (!this.textureSymbolCacheArray) {\n      this.textureSymbolCacheArray = {};\n    }\n    if (!symbols) {\n      return;\n    }\n\n    const existingKeys = Object.keys(this.textureSymbolCacheArray);\n    Object.entries(symbols).forEach(([key, symbol]: [string, string]) => {\n      if (!existingKeys.includes(key)) {\n        this.textureSymbolCacheArray[key] = Texture.from(symbol);\n      }\n    });\n  }\n\n  private drawCementPlug(cementPlug: CementPlug, casings: Casing[], completion: Completion[], holes: HoleSize[]) {\n    const { exaggerationFactor, cementPlugOptions } = this.options as SchematicLayerOptions<T>;\n\n    const cementPlugSegments = createComplexRopeSegmentsForCementPlug(\n      cementPlug,\n      casings,\n      completion,\n      holes,\n      exaggerationFactor,\n      this.getZFactorScaledPathForPoints,\n    );\n    this.drawComplexRope(cementPlugSegments, this.getCementPlugTexture(cementPlugOptions));\n\n    const { rightPath, leftPath } = cementPlugSegments.reduce<{ rightPath: Point[]; leftPath: Point[] }>(\n      (acc, current) => {\n        const { leftPath, rightPath } = createTubularRenderingObject(current.diameter / 2, current.points);\n\n        return {\n          rightPath: [...acc.rightPath, ...rightPath],\n          leftPath: [...acc.leftPath, ...leftPath],\n        };\n      },\n      { rightPath: [], leftPath: [] },\n    );\n    // eslint-disable-next-line no-magic-numbers\n    this.drawOutline(leftPath, rightPath, convertColor('black'), 0.25, 'TopAndBottom');\n  }\n\n  private createCasingRenderObject(casing: Casing): CasingRenderObject {\n    const { exaggerationFactor } = this.options as SchematicLayerOptions<T>;\n    return prepareCasingRenderObject(exaggerationFactor, casing, this.getZFactorScaledPathForPoints);\n  }\n\n  private getCementPlugTexture(cementPlugOptions: CementPlugOptions): Texture {\n    if (!this.cementPlugTextureCache) {\n      this.cementPlugTextureCache = createCementPlugTexture(cementPlugOptions);\n    }\n    return this.cementPlugTextureCache;\n  }\n\n  private prepareSymbolRenderObject = (component: CompletionSymbol | PAndASymbol): SymbolRenderObject => {\n    const { exaggerationFactor } = this.options as SchematicLayerOptions<T>;\n\n    const exaggeratedDiameter = component.diameter * exaggerationFactor;\n\n    const pathPoints = this.getZFactorScaledPathForPoints(component.start, component.end);\n\n    return {\n      pathPoints,\n      referenceDiameter: exaggeratedDiameter,\n      symbolKey: component.symbolKey,\n    };\n  };\n\n  private drawSymbolComponent = ({ pathPoints, referenceDiameter, symbolKey }: SymbolRenderObject): void => {\n    const texture = this.getSymbolTexture(symbolKey, referenceDiameter);\n    // The rope renders fine in CANVAS/fallback mode\n    this.drawSVGRope(pathPoints, texture);\n  };\n\n  private drawSVGRope(path: Point[], texture: Texture): void {\n    if (path.length === 0) {\n      return null;\n    }\n\n    const rope: UniformTextureStretchRope = new UniformTextureStretchRope(texture, path);\n\n    this.addChild(rope);\n  }\n\n  private getSymbolTexture(symbolKey: string, diameter: number): Texture {\n    return new Texture(this.textureSymbolCacheArray[symbolKey].baseTexture, null, new Rectangle(0, 0, 0, diameter), null, groupD8.MAIN_DIAGONAL);\n  }\n\n  private drawHoleSize = (maxHoleDiameter: number, holeObject: HoleSize): void => {\n    if (holeObject == null) {\n      return;\n    }\n\n    const pathPoints = this.getZFactorScaledPathForPoints(holeObject.start, holeObject.end);\n    if (pathPoints.length === 0) {\n      return;\n    }\n\n    const { exaggerationFactor, holeOptions } = this.options as SchematicLayerOptions<T>;\n    const exaggeratedDiameter = holeObject.diameter * exaggerationFactor;\n    const { rightPath, leftPath } = createTubularRenderingObject(exaggeratedDiameter / 2, pathPoints);\n\n    if (this.renderType() === RENDERER_TYPE.CANVAS) {\n      const polygonCoords = makeTubularPolygon(leftPath, rightPath);\n      this.drawBigPolygon(polygonCoords, convertColor(holeOptions.firstColor));\n    } else {\n      const texture = this.getHoleTexture(holeOptions, exaggeratedDiameter, maxHoleDiameter);\n      this.drawHoleRope(pathPoints, texture, maxHoleDiameter);\n    }\n\n    this.drawOutline(leftPath, rightPath, convertColor(holeOptions.lineColor), HOLE_OUTLINE * exaggerationFactor, 'TopAndBottom', 0);\n  };\n\n  private drawHoleRope(path: Point[], texture: Texture, maxHoleDiameter: number): void {\n    if (path.length === 0) {\n      return null;\n    }\n\n    const rope: SimpleRope = new SimpleRope(texture, path, maxHoleDiameter / DEFAULT_TEXTURE_SIZE);\n\n    this.addChild(rope);\n  }\n\n  private getHoleTexture(holeOptions: HoleOptions, diameter: number, maxHoleDiameter: number): Texture {\n    const size = DEFAULT_TEXTURE_SIZE;\n    const height = size;\n    const width = size;\n\n    const textureDiameter = (diameter / maxHoleDiameter) * size;\n\n    if (!this.holeTextureCache) {\n      this.holeTextureCache = createHoleBaseTexture(holeOptions, width, height);\n    }\n\n    const baseTexture = this.holeTextureCache.baseTexture;\n    const sidePadding = (height - textureDiameter) / 2;\n    const frame = new Rectangle(0, sidePadding, width, textureDiameter);\n    const texture = new Texture(baseTexture, frame);\n\n    return texture;\n  }\n\n  /**\n   * The rendering order of these components needs to be aligned\n   * @param casingRenderObjects\n   * @param cementRenderObject\n   * @param cementSqueezes\n   * @returns ordered rendering list\n   */\n  private sortCementAndCasingRenderObjects(\n    casingRenderObjects: CasingRenderObject[],\n    cementRenderObject: CementRenderObject[],\n    cementSqueezes: CementSqueezeRenderObject[],\n  ): InterlacedRenderObjects[] {\n    type InterlaceReducerAcc = {\n      result: InterlacedRenderObjects[];\n      remainingCement: CementRenderObject[];\n      remainingCementSqueezes: CementSqueezeRenderObject[];\n    };\n\n    let zIndex = 0;\n\n    const { result } = casingRenderObjects.reduce(\n      (acc: InterlaceReducerAcc, casingRenderObject: CasingRenderObject): InterlaceReducerAcc => {\n        const foundCementShape = acc.remainingCement.find((cement) => cement.casingIds.includes(casingRenderObject.id));\n        const foundCementSqueezes = acc.remainingCementSqueezes.filter((squeeze) => squeeze.casingIds.includes(casingRenderObject.id));\n\n        if (foundCementShape) {\n          foundCementShape.zIndex = zIndex++;\n        }\n        foundCementSqueezes.forEach((item) => (item.zIndex = zIndex++));\n        casingRenderObject.zIndex = zIndex++;\n\n        return {\n          result: [...acc.result, foundCementShape, casingRenderObject, ...foundCementSqueezes],\n          remainingCement: acc.remainingCement.filter((c) => c !== foundCementShape),\n          remainingCementSqueezes: acc.remainingCementSqueezes.filter((squeeze) => !foundCementSqueezes.includes(squeeze)),\n        };\n      },\n      { result: [], remainingCement: cementRenderObject, remainingCementSqueezes: cementSqueezes },\n    );\n\n    return result.filter((item) => item !== undefined).sort((a, b) => a.zIndex - b.zIndex);\n  }\n\n  /**\n   *\n   * @param intervals\n   * @param texture\n   * optionally fetch the exaggerationFactor from a different options prop\n   * options.perforationOptions for example\n   * @param getExaggerationFactor\n   * @returns\n   */\n  private drawComplexRope(intervals: ComplexRopeSegment[], texture: Texture): ComplexRope {\n    if (intervals.length === 0) {\n      return null;\n    }\n    const { exaggerationFactor } = this.options as SchematicLayerOptions<T>;\n\n    const rope = new ComplexRope(texture, intervals, exaggerationFactor);\n\n    this.addChild(rope);\n\n    return rope;\n  }\n\n  private static getOutlineClosureType = (index: number, maxIndex: number): OutlineClosure => {\n    if (index === 0) {\n      if (index === maxIndex) {\n        return 'TopAndBottom';\n      }\n      return 'Top';\n    }\n    if (index === maxIndex) {\n      return 'Bottom';\n    }\n\n    return 'None';\n  };\n\n  private drawCasing = (casingRenderObject: CasingRenderObject): void => {\n    const { casingOptions } = this.options as SchematicLayerOptions<T>;\n    const casingSolidColorNumber = convertColor(casingOptions.solidColor);\n    const casingLineColorNumber = convertColor(casingOptions.lineColor);\n\n    casingRenderObject.sections.forEach((section, index, list) => {\n      const outlineClosureType = SchematicLayer.getOutlineClosureType(index, list.length - 1);\n      // Pixi.js-legacy handles SimpleRope and advanced render methods poorly\n      if (this.renderType() === RENDERER_TYPE.CANVAS) {\n        this.drawBigPolygon(section.polygon, casingSolidColorNumber);\n      } else {\n        const texture = this.createCasingTexture(casingRenderObject.referenceDiameter);\n        this.drawRope(section.pathPoints, texture, casingSolidColorNumber);\n      }\n      if (section.kind === 'casing-window') {\n        this.drawCasingWindowOutline(section.leftPath, section.rightPath, casingOptions, casingRenderObject.casingWallWidth);\n      } else {\n        this.drawOutline(section.leftPath, section.rightPath, casingLineColorNumber, casingRenderObject.casingWallWidth, outlineClosureType);\n      }\n    });\n  };\n\n  private createCasingTexture(diameter: number): Texture {\n    const textureWidthPO2 = 16;\n    return new Texture(Texture.WHITE.baseTexture, null, new Rectangle(0, 0, textureWidthPO2, diameter));\n  }\n\n  private drawShoe(casingEnd: number, casingRadius: number): void {\n    const { exaggerationFactor, casingOptions } = this.options as SchematicLayerOptions<T>;\n    const shoeWidth = casingOptions.shoeSize.width * exaggerationFactor;\n    const shoeLength = casingOptions.shoeSize.length * exaggerationFactor;\n\n    const shoeCoords = this.generateShoe(casingEnd, casingRadius, shoeLength, shoeWidth);\n    const shoeCoords2 = this.generateShoe(casingEnd, casingRadius, shoeLength, -shoeWidth);\n    this.drawBigPolygon(shoeCoords2);\n    this.drawBigPolygon(shoeCoords);\n  }\n\n  private generateShoe = (casingEnd: number, casingRadius: number, length: number, width: number): Point[] => {\n    const start = casingEnd - length;\n    const end = casingEnd;\n\n    const points = this.getZFactorScaledPathForPoints(start, end);\n\n    const normal = createNormals(points);\n    const shoeEdge: Point[] = offsetPoints(points, normal, casingRadius * (width < 0 ? -1 : 1));\n\n    const shoeTipPoint = points[points.length - 1];\n    const shoeTipNormal = normal[normal.length - 1];\n    const shoeTip: Point = offsetPoint(shoeTipPoint, shoeTipNormal, width + casingRadius * (width < 0 ? -1 : 1));\n\n    return [...shoeEdge, shoeTip];\n  };\n\n  private createCementSqueezeShape = (\n    squeeze: CementSqueeze,\n    casings: Casing[],\n    completion: Completion[],\n    holes: HoleSize[],\n  ): ComplexRopeSegment[] => {\n    const { exaggerationFactor } = this.options as SchematicLayerOptions<T>;\n    return createComplexRopeSegmentsForCementSqueeze(squeeze, casings, completion, holes, exaggerationFactor, this.getZFactorScaledPathForPoints);\n  };\n\n  private getCementTexture(): Texture {\n    if (!this.cementTextureCache) {\n      const { cementOptions } = this.options as SchematicLayerOptions<T>;\n      this.cementTextureCache = createCementTexture(cementOptions);\n    }\n    return this.cementTextureCache;\n  }\n\n  private createPerforationShape = (perforation: Perforation, casings: Casing[], holes: HoleSize[]): PerforationShape[] => {\n    const { exaggerationFactor } = this.options as SchematicLayerOptions<T>;\n    return createComplexRopeSegmentsForPerforation(perforation, casings, holes, exaggerationFactor, this.getZFactorScaledPathForPoints);\n  };\n\n  private getCementSqueezeTexture(): Texture {\n    if (!this.cementSqueezeTextureCache) {\n      const { cementSqueezeOptions } = this.options as SchematicLayerOptions<T>;\n      this.cementSqueezeTextureCache = createCementSqueezeTexture(cementSqueezeOptions);\n    }\n    return this.cementSqueezeTextureCache;\n  }\n\n  private drawScreen({ start, end, diameter }: Screen): void {\n    const { exaggerationFactor, screenOptions } = this.options as SchematicLayerOptions<T>;\n    const exaggeratedDiameter = exaggerationFactor * diameter;\n\n    const pathPoints = this.getZFactorScaledPathForPoints(start, end);\n    const { leftPath, rightPath } = createTubularRenderingObject(exaggeratedDiameter / 2, pathPoints);\n    const polygon = makeTubularPolygon(leftPath, rightPath);\n\n    const texture = this.getScreenTexture();\n    if (this.renderType() === RENDERER_TYPE.CANVAS) {\n      this.drawBigTexturedPolygon(polygon, texture);\n    } else {\n      this.drawCompletionRope(pathPoints, texture, exaggeratedDiameter);\n    }\n    this.drawOutline(leftPath, rightPath, convertColor(screenOptions.lineColor), SCREEN_OUTLINE * exaggerationFactor, 'TopAndBottom');\n  }\n\n  private drawTubing({ diameter, start, end }: Tubing): void {\n    const { exaggerationFactor, tubingOptions } = this.options as SchematicLayerOptions<T>;\n    const exaggeratedDiameter = exaggerationFactor * diameter;\n\n    const pathPoints = this.getZFactorScaledPathForPoints(start, end);\n    const { leftPath, rightPath } = createTubularRenderingObject(exaggeratedDiameter / 2, pathPoints);\n    const polygon = makeTubularPolygon(leftPath, rightPath);\n\n    const texture = this.getTubingTexture(tubingOptions);\n    if (this.renderType() === RENDERER_TYPE.CANVAS) {\n      this.drawBigTexturedPolygon(polygon, texture);\n    } else {\n      this.drawCompletionRope(pathPoints, texture, exaggeratedDiameter);\n    }\n  }\n\n  private getTubingTexture(tubingOptions: TubingOptions): Texture {\n    if (!this.tubingTextureCache) {\n      this.tubingTextureCache = createTubingTexture(tubingOptions);\n    }\n    return this.tubingTextureCache;\n  }\n\n  private getScreenTexture(): Texture {\n    if (!this.screenTextureCache) {\n      const { screenOptions } = this.options as SchematicLayerOptions<T>;\n      this.screenTextureCache = createScreenTexture(screenOptions);\n    }\n    return this.screenTextureCache;\n  }\n\n  private drawCompletionRope(path: Point[], texture: Texture, diameter: number): void {\n    if (path.length === 0) {\n      return;\n    }\n\n    const rope: FixedWidthSimpleRope = new FixedWidthSimpleRope(texture, path, diameter);\n    this.addChild(rope);\n  }\n}\n"],"names":["max","values","valueof","value","index","sum","assertNever","x","isPAndASymbol","item","isCementSqueeze","isCementPlug","foldCompletion","fScreen","fTubing","fSymbol","completion","foldPerforationSubKind","options","subKind","hasPacking","perf","hasFracLines","hasSpikes","isSubkindCasedHoleGravelPack","isSubKindCasedHoleFracPack","intersect","a","b","defaultInternalLayerOptions","layerId","defaultHoleOptions","defaultCasingOptions","SHOE_WIDTH","SHOE_LENGTH","defaultPerforationOptions","defaultCementOptions","defaultCementSqueezeOptions","defaultScreenOptions","defaultTubingOptions","defaultCementPlugOptions","pointToVector","p","Vector2","vectorToPoint","v","Point","createNormals","points","n","_coord","i","list","offsetPoint","point","vector","offset","offsetPoints","vectors","makeTubularPolygon","rightPath","leftPath","d","overlaps","top1","bottom1","top2","bottom2","strictlyOverlaps","uniq","arr","findIntersectingItems","start","end","otherStrings","holes","overlappingHoles","hole","overlappingOuterStrings","casing","getUniqueDiameterChangeDepths","intervalStart","intervalEnd","diameterIntervals","trimmedChangedDepths","getInnerStringDiameter","stringType","findCementOuterDiameterAtDepth","attachedStrings","nonAttachedStrings","depth","attachedStringAtDepth","casingOrCompletion","attachedOuterDiameter","outerCasingAtDepth","holeAtDepth","findPerforationOuterDiameterAtDepth","perforationSubKind","findCementPlugInnerDiameterAtDepth","minimumDiameter","c","nonAttachedStringAtDepth","createComplexRopeSegmentsForCement","cement","casings","exaggerationFactor","getPoints","splitByReferencedStrings","bottomOfCement","outerDiameterIntervals","nextDepth","diameterAtChangeDepth","interval","referenceIds","acc","current","createComplexRopeSegmentsForCementSqueeze","squeeze","diameterAtDepth","createComplexRopeSegmentsForCementPlug","plug","innerDiameterIntervals","createGradientFill","canvas","canvasCtx","firstColor","secondColor","startPctOffset","gradient","createHoleBaseTexture","width","height","Texture","createScreenTexture","scalingFactor","size","DEFAULT_TEXTURE_SIZE","baseLineWidth","distanceBetweenLines","createTubingTexture","innerColor","outerColor","innerColorStart","innerColorEnd","createCementTexture","lineWidth","createCementPlugTexture","createCementSqueezeTexture","createTubularRenderingObject","radius","pathPoints","normals","createCasingInterval","createCasingWindowInterval","getCasingIntervalsWithWindows","result","cw","intervals","lastBottom","currentWindow","startCasingInterval","updatedLastBottom","windowStart","windowEnd","windowInterval","nextLastBottom","endCasingInterval","newIntervals","prepareCasingRenderObject","getPathPoints","exaggeratedDiameter","exaggeratedRadius","exaggeratedInnerRadius","casingWallWidth","sections","casingInterval","createComplexRopeSegmentsForPerforation","perforation","drawPacking","ctx","perforationOptions","packingOpacity","yellow","xy","wh","drawFracLines","extendedPerfShapeDiameter","startAt","fracLineCurve","amountOfSpikes","spikeWidth","diameter","fracLineLength","spikeLength","offsetX","offsetY","fracLines","bottom","controlPoint1","middle","controlPoint2","drawSpikes","left","right","errorTexture","errorMessage","existingContext","WRAP_MODES","Rectangle","groupD8","createPerforationCanvas","perfShape","createPerforationTexture","createSubkindPerforationTexture","otherPerforations","intersectionsWithCasedHoleGravel","intersectionsWithCasedHoleFracPack","createSubkindCasedHoleFracturationTexture","createSubkindCasedHoleFracPackTexture","createSubkindCasedHoleGravelPackTexture","createSubkindOpenHoleGravelPackTexture","createSubkindOpenHoleFracPackTexture","_perforation","createPerforationPackingTexture","createPerforationFracLineTexture","createPerforationSpikeTexture","ComplexRopeGeometry","MeshGeometry","segments","textureScale","pointCount","segment","__publicField","vertexBuffer","uvBuffer","indexBuffer","uvs","indices","segmentCount","maxDiameter","amount","uvIndex","indicesIndex","indexCount","prev","textureWidth","total","j","dx","dy","distance","lastIndex","lastPoint","nextPoint","perpX","perpY","vertices","perpLength","num","ComplexRope","Mesh","texture","ropeGeometry","meshMaterial","MeshMaterial","renderer","geometry","FixedWidthSimpleRopeGeometry","FixedWidthSimpleRope","UniformTextureStretchRopeGeometry","totalLength","prevPoint","UniformTextureStretchRope","foldInterlacedRenderObjects","fCasing","fCement","fCementSqueeze","renderObject","defaultSchematicLayerOptions","_SchematicLayer","PixiLayer","id","scaleLinear","y","coords","color","polygon","Graphics","component","referenceDiameter","symbolKey","maxHoleDiameter","holeObject","holeOptions","RENDERER_TYPE","polygonCoords","convertColor","HOLE_OUTLINE","casingRenderObject","casingOptions","casingSolidColorNumber","casingLineColorNumber","section","outlineClosureType","casingEnd","casingRadius","length","normal","shoeEdge","shoeTipPoint","shoeTipNormal","shoeTip","event","shouldRecalculate","yRatio","flippedX","flippedY","isVisible","internalLayerOptions","keyFound","_key","domain","baseYSpan","baseDomain","path","tint","rope","SimpleRope","lineColor","outlineClosure","lineAlignment","leftPathReverse","startPointRight","startPointLeft","line","windowOptions","flippedPaths","_b","_a","linePath","dashedPath","dashedAlignment","solidAlignment","graphics","startPointLinePath","dashedLine","DashLine","startPointDashedPath","currentPoint","holeSizes","cements","symbols","pAndA","perforations","EXAGGERATED_DIAMETER","casingRenderObjects","cementShapes","cementSqueezes","remainingPAndA","squeezes","remaining","cementSqueezesShape","casingRO","cementRO","cementSqueezesRO","packings","spikes","perfShapesByDiameter","dict","ps","perfShapesWithSameDiameter","obj","symbolRenderObject","existingKeys","key","symbol","cementPlug","cementPlugOptions","cementPlugSegments","textureDiameter","baseTexture","sidePadding","frame","cementRenderObject","zIndex","foundCementShape","foundCementSqueezes","shoeWidth","shoeLength","shoeCoords","shoeCoords2","cementOptions","cementSqueezeOptions","screenOptions","SCREEN_OUTLINE","tubingOptions","SchematicLayer","maxIndex"],"mappings":"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"}