{"version":3,"file":"seismic.stories-5edd3edf.js","sources":["../../../../src/datautils/trajectory.ts"],"sourcesContent":["import Vector2 from '@equinor/videx-vector2';\nimport { seqI } from '@equinor/videx-math';\nimport { CurveInterpolator } from 'curve-interpolator';\nimport { SurveySample } from './interfaces';\n\nconst stepSize = 0.1;\nconst extensionLength = 1000;\nconst thresholdRelativeDist = 150;\nconst thresholdDirectionDist = 30;\n\nconst pathSteps = 10;\n\n/**\n * Generate projected wellbore path for drawing using wellbore path layer\n * Code originally developed for REP\n * @param {[]} poslog Position log from SMDA\n */\nexport function generateProjectedWellborePath(poslog: SurveySample[]): [number, number][] {\n  if (!poslog || poslog.length === 0) {\n    return [];\n  }\n\n  const points: [number, number, number, number][] = poslog ? poslog.map((p: SurveySample) => [p.easting, p.northing, p.tvd, p.md]) : [];\n\n  const projection = simplify(projectCurtain(points));\n  const offset = projection[projection.length - 1]?.[0];\n\n  if (offset != null) {\n    projection.forEach((p, i) => {\n      projection[i]![0] = offset - p[0];\n    });\n  }\n\n  return projection;\n}\n\n/**\n * Generate Trajectory\n * Code originally developed for REP\n * @param {[]} poslog Position log from SMDA\n * @param {number} defaultIntersectionAngle Default intersection angle for the field\n */\nexport function generateProjectedTrajectory(poslog: SurveySample[], defaultIntersectionAngle: number): number[][] {\n  if (!poslog || poslog.length === 0) {\n    return [];\n  }\n\n  const points: [number, number, number, number][] = poslog ? poslog.map((p) => [p.easting, p.northing, p.tvd, p.md]) : [];\n\n  const interpolator: CurveInterpolator = new CurveInterpolator(points, { tension: 0.75, arcDivisions: 5000 });\n  const displacement: number = interpolator.length;\n\n  const nPoints: number = Math.round(displacement * pathSteps);\n  let path: [number, number][];\n  if (nPoints > 0) {\n    const maxOffset = 0.0005;\n    const maxDistance = 10;\n    path = simplify(interpolator.getPoints(nPoints), maxOffset, maxDistance);\n  } else {\n    path = [[points[0]![0], points[0]![1]]];\n  }\n\n  const first = path[0]!;\n  const last = path[path.length - 1]!;\n  const relativeDist: number = Vector2.distance(first, last);\n  let v: Vector2;\n\n  if (relativeDist < thresholdRelativeDist) {\n    const oneEighty = 180;\n    const radCurtainDirection = (defaultIntersectionAngle / oneEighty) * Math.PI;\n    v = new Vector2(Math.cos(radCurtainDirection), Math.sin(radCurtainDirection)).mutable;\n  } else {\n    v = getDirectionVector(path, thresholdDirectionDist);\n  }\n  const extensionLengthStart: number = Math.max(0, extensionLength - displacement);\n  const offset: number = extensionLengthStart + displacement;\n  const trajectory: [number, number][] = [];\n\n  let firstPoints: [number, number][] = [];\n\n  // Reference to initial vector\n  const initial: number[] = v.toArray();\n\n  if (extensionLengthStart > 0) {\n    // extend from start\n    firstPoints = seqI(Math.ceil(extensionLengthStart * stepSize)).map((t) =>\n      v\n        .set(initial)\n        .scale(extensionLengthStart * (1 - t))\n        .subFrom(first)\n        .toArray(),\n    );\n    firstPoints.pop();\n    trajectory.push(...firstPoints);\n  }\n  trajectory.push(...path);\n\n  const endPoints = seqI(Math.ceil(extensionLength * stepSize))\n    .map((t) =>\n      v\n        .set(initial)\n        .scale(extensionLength * t)\n        .add(last)\n        .toArray(),\n    )\n    .splice(1);\n\n  trajectory.push(...endPoints);\n\n  const projectedTrajectory: number[][] = projectCurtain(trajectory, undefined, offset);\n\n  return projectedTrajectory;\n}\n\n/**\n * Get direction vector\n * Code originally developed for REP\n * @param {[]} path\n * @param {number} threshold\n * @returns {Vector2}\n */\nfunction getDirectionVector(path: number[][], threshold: number): Vector2 {\n  const res: Vector2 = Vector2.zero.mutable;\n  let len = 0;\n  const temp: Vector2 = Vector2.zero.mutable;\n\n  for (let i = 0; i < path.length - 1; i++) {\n    const index = path.length - 1 - i;\n    temp.set(path[index]!).sub(path[index - 1]!);\n    res.add(temp);\n\n    len = res.magnitude;\n    if (len > threshold) {\n      break;\n    }\n  }\n\n  if (len === 0) {\n    return new Vector2([0, 0]);\n  }\n  return res.scale(1 / len);\n}\n\n/**\n * Simplify array\n *\n * Simplifies an array using given parameters.\n * Code originally developed for REP\n * @access public\n *\n * @param {Number[]}      inputArr           Array to simplify\n * @param {Number}        [maxOffset=0.001]  Max offset (Default = 0.001)\n * @param {Number}        [maxDistance=10]   Max distance (Default = 10)\n *\n * @return {Number[]}    Simplified array\n */\nfunction simplify(inputArr: [number, number][], maxOffset = 0.001, maxDistance = 10): [number, number][] {\n  if (inputArr.length <= 4) {\n    return inputArr;\n  }\n  const [o0, o1] = inputArr[0]!;\n  const arr = inputArr.map<[number, number]>((d) => [d[0]! - o0, d[1]! - o1]);\n  let [a0, a1] = arr[0]!;\n  const sim = [inputArr[0]!];\n\n  for (let i = 1; i + 1 < arr.length; i++) {\n    const [t0, t1] = arr[i] ?? [];\n    const [b0, b1] = arr[i + 1] ?? [];\n\n    // If t->b vector is NOT [0, 0]\n    if (t0 != null && t1 != null && b0 != null && b1 != null && (b0 - t0 !== 0 || b1 - t1 !== 0)) {\n      // Proximity check\n      const proximity: number = Math.abs(a0 * b1 - a1 * b0 + b0 * t1 - b1 * t0 + a1 * t0 - a0 * t1) / Math.sqrt((b0 - a0) ** 2 + (b1 - a1) ** 2);\n\n      const dir: [number, number] = [a0 - t0, a1 - t1];\n      const len: number = Math.sqrt(dir[0] ** 2 + dir[1] ** 2);\n\n      if (proximity > maxOffset || len >= maxDistance) {\n        sim.push([t0 + o0, t1 + o1]);\n        [a0, a1] = [t0, t1];\n      }\n    }\n  }\n  const last = arr[arr.length - 1]!;\n  sim.push([last[0] + o0, last[1] + o1]);\n\n  return sim;\n}\n\n/**\n * Perform a curtain projection on a set of points in 3D\n * @param points\n * @param origin\n * @param offset\n * @returns {array}\n */\nfunction projectCurtain(points: [number, number, ...number[]][], origin?: [number, number, number, number], offset = 0): [number, number][] {\n  let p0 = origin || points[0]!;\n  let l = 0;\n  const projected = points.map<[number, number]>((p1) => {\n    const dx = p1[0] - p0[0];\n    const dy = p1[1] - p0[1];\n    l += Math.sqrt(dx ** 2 + dy ** 2);\n    p0 = p1;\n    return [offset > 0 ? offset - l : l, p1[2] ?? 0];\n  });\n  return projected;\n}\n"],"names":["stepSize","extensionLength","thresholdRelativeDist","thresholdDirectionDist","pathSteps","generateProjectedTrajectory","poslog","defaultIntersectionAngle","points","p","interpolator","CurveInterpolator","displacement","nPoints","path","simplify","first","last","relativeDist","Vector2","v","radCurtainDirection","getDirectionVector","extensionLengthStart","offset","trajectory","firstPoints","initial","seqI","t","endPoints","projectCurtain","threshold","res","len","temp","i","index","inputArr","maxOffset","maxDistance","o0","o1","arr","d","a0","a1","sim","t0","t1","b0","b1","proximity","dir","origin","p0","l","p1","dx","dy"],"mappings":"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"}