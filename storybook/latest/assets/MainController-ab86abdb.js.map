{"version":3,"file":"MainController-ab86abdb.js","sources":["../../../../src/utils/root-finder.ts","../../../../src/utils/arc-length.ts","../../../../src/utils/binary-search.ts","../../../../src/control/ExtendedCurveInterpolator.ts","../../../../src/control/IntersectionReferenceSystem.ts","../../../../src/control/LayerManager.ts","../../../../src/control/overlay.ts","../../../../src/control/MainController.ts"],"sourcesContent":["import { clamp } from '@equinor/videx-math';\n\ntype fx = (n: number) => number;\n\n/*\n * Methods for finding root of a function\n */\nexport class RootFinder {\n  /**\n   * Find root using newthons method\n   * @param {Number} func f(x)\n   * @param {Number} precision Accuracy of result\n   * @param {Number} maxIterations Max number of iterations to use\n   * @param {Number} start Starting position\n   * @param {Number} minLimit Min limit of result\n   * @param {Number} maxLimit Max limit of result\n   */\n  static newton(func: fx, precision: number = 0.01, maxIterations: number = 1000, start = 0.5, minLimit = 0, maxLimit = 1): number {\n    const h = 0.0001;\n    let t = start;\n    for (let i = 0; i < maxIterations; i++) {\n      const v = func(t);\n      if (Math.abs(v) < precision) {\n        return clamp(t, minLimit, maxLimit);\n      }\n      const d = (func(t + h) - v) / h;\n      t = t - v / d;\n    }\n    return null;\n  }\n\n  /**\n   * Find root using bisect method\n   * @param {Number} func f(x)\n   * @param {Number} precision Accuracy of result\n   * @param {Number} maxIterations Max number of iterations to use\n   * @param {Number} start Starting position\n   * @param {Number} minLimit Min limit of result\n   * @param {Number} maxLimit Max limit of result\n   */\n  static bisect(func: fx, precision: number = 0.01, maxIterations: number = 1000, start = 0.5, minLimit = 0, maxLimit = 1): number {\n    let tl = minLimit;\n    let th = maxLimit;\n    let t = start;\n    let v;\n    let i;\n    for (i = 0; i < maxIterations; i++) {\n      v = func(t);\n      if (Math.abs(v) < precision) {\n        return t;\n      }\n      if (v < 0) {\n        th = t;\n      } else {\n        tl = t;\n      }\n      t = (th + tl) / 2;\n    }\n    return t;\n  }\n\n  /**\n   * Find root by trying available methods\n   * @param {Number} func f(x)\n   * @param {Number} precision Accuracy of result\n   * @param {Number} maxIterations Max number of iterations to use\n   * @param {Number} start Starting position\n   * @param {Number} minLimit Min limit of result\n   * @param {Number} maxLimit Max limit of result\n   */\n  static findRoot(func: fx, precision: number = 0.01, maxIterations: number = 1000, start = 0.5, minLimit = 0, maxLimit = 1): number {\n    let t = RootFinder.newton(func, precision, maxIterations, start);\n    if (t == null) {\n      t = RootFinder.bisect(func, precision, maxIterations, start, minLimit, maxLimit);\n    }\n    return t;\n  }\n}\n","import Vector2 from '@equinor/videx-vector2';\nimport { Vector } from 'curve-interpolator/dist/src/interfaces';\n\ntype fx = (n: number) => Vector;\n\n/*\n * Methods for calculating length of a curve\n */\nexport class ArcLength {\n  /**\n   * Calculate using an adaptive bisect method\n   * @param {Number} func Curve function returning [x,y]\n   * @param {Number} minLimit Min limit\n   * @param {Number} maxLimit Max limit\n   * @param {Number} tolerance Result tolerance\n   * @param {Number} minDepth Min recursive depth before accepting solution\n   * @param {Number} maxDepth Max recursive depth\n   */\n  static bisect(\n    func: fx,\n    minLimit: number = 0,\n    maxLimit: number = 1,\n    tolerance: number = 0.005,\n    minDepth: number = 4,\n    maxDepth: number = 10,\n  ): number {\n    const calcRec = (a: number, b: number, aVal: number[], bVal: number[], span: number, tolerance: number, depth: number = 0): number => {\n      const mid = (a + b) / 2;\n      const midVal = func(mid) as number[];\n      const spanA = Vector2.distance(aVal, midVal);\n      const spanB = Vector2.distance(midVal, bVal);\n      const length = spanA + spanB;\n      if ((depth >= minDepth && Math.abs(length - span) < tolerance) || depth >= maxDepth) {\n        return length;\n      }\n      const tol = tolerance / 2;\n      const d = depth + 1;\n      return calcRec(a, mid, aVal, midVal, spanA, tol, d) + calcRec(mid, b, midVal, bVal, spanB, tol, d);\n    };\n    const aVal = func(minLimit) as number[];\n    const bVal = func(maxLimit) as number[];\n    const span = Vector2.distance(aVal, bVal);\n    const res = calcRec(minLimit, maxLimit, aVal, bVal, span, tolerance);\n    return res;\n  }\n\n  /**\n   * Calculate using trapezoid method\n   * @param {Number} func Curve function returning [x,y]\n   * @param {Number} minLimit Min limit\n   * @param {Number} maxLimit Max limit\n   * @param {Number} segments Number of segments\n   */\n  static trapezoid(func: fx, minLimit: number = 0, maxLimit: number = 1, segments: number = 1000): number {\n    let length = 0;\n    let lastPos = func(minLimit) as number[];\n    const step = (maxLimit - minLimit) / (segments - 1);\n    for (let i = 1; i < segments; i++) {\n      const pos = func(minLimit + i * step) as number[];\n      const delta = Vector2.distance(lastPos, pos);\n      length += delta;\n      lastPos = pos;\n    }\n    return length;\n  }\n}\n","/**\n * Find index where value[index] =< searchValue and value[index+1] >= searchValue using binary search\n * @param {Number} values Array of sorted values\n * @param {Number} searchValue Value to search for\n */\nexport class BinarySearch {\n  static search(values: number[], searchValue: number): number {\n    let il = 0;\n    let ih = values.length - 1;\n    let i = Math.floor(il + ih / 2);\n    while (i > il && i < ih) {\n      const v = values[i];\n      const v1 = values[i + 1];\n      if (v <= searchValue && v1 >= searchValue) {\n        return i;\n      }\n      if (searchValue < v) {\n        ih = i;\n      } else {\n        il = i;\n      }\n      i = Math.floor(il + ih / 2);\n    }\n    return i;\n  }\n}\n","import Vector2 from '@equinor/videx-vector2';\nimport { clamp } from '@equinor/videx-math';\nimport { CurveInterpolator } from 'curve-interpolator';\nimport { Vector } from 'curve-interpolator/dist/src/interfaces';\nimport { CurveInterpolatorOptions } from 'curve-interpolator/dist/src/curve-interpolator';\n\nimport { RootFinder } from '../utils/root-finder';\nimport { ArcLength } from '../utils/arc-length';\nimport { BinarySearch } from '../utils/binary-search';\n\nexport class ExtendedCurveInterpolator extends CurveInterpolator {\n  arcLengthLookup: number[] = [];\n\n  constructor(points: Vector[], options?: CurveInterpolatorOptions) {\n    super(points, options);\n    this.findTForArcLength = this.findTForArcLength.bind(this);\n    this.findTByRootForArcLength = this.findTByRootForArcLength.bind(this);\n    this.findApproxTForArcLength = this.findApproxTForArcLength.bind(this);\n    this.findTQuickForArcLength = this.findTQuickForArcLength.bind(this);\n    this.generateArcLengthLookup = this.generateArcLengthLookup.bind(this);\n    this.getArcLength = this.getArcLength.bind(this);\n    this.getQuickArcLength = this.getQuickArcLength.bind(this);\n    this.getPointAtArcLength = this.getPointAtArcLength.bind(this);\n    this.getPointAt = this.getPointAt.bind(this);\n  }\n\n  /**\n   * Function which finds t value for arc length\n   * @param {Number} arcLength Target arc length\n   * @param {Number} tolerance Tolerance for result\n   * @param {Number} iterations Max number of iterations to use\n   */\n  findTForArcLength(arcLength: number, options?: { approxT?: boolean; quickT?: boolean; normalizedLength?: number }): number {\n    // TODO: Ideally the CurveInterpolator should be able to provide t for curve length\n    let t;\n    if (options?.approxT) {\n      t = this.findApproxTForArcLength(arcLength, options?.normalizedLength);\n    } else if (options?.quickT) {\n      t = this.findTQuickForArcLength(arcLength);\n    } else {\n      t = this.findTByRootForArcLength(arcLength);\n    }\n    return t;\n  }\n\n  /**\n   * Function which finds t value for arc length by finding root\n   * @param {Number} arcLength Target arc length\n   * @param {Number} tolerance Tolerance for result\n   * @param {Number} iterations Max number of iterations to use\n   */\n  findTByRootForArcLength(arcLength: number, tolerance = 0.01, iterations = 100): number {\n    if (arcLength <= 0) {\n      return 0.0;\n    }\n    if (arcLength >= this.length) {\n      return 1.0;\n    }\n    const t = RootFinder.findRoot((x) => arcLength - this.getQuickArcLength(0, x), tolerance, iterations, arcLength / this.length);\n    return t;\n  }\n\n  /**\n   * Function which finds t value for arc length by simple approximation\n   * @param {Number} arcLength Target arclength\n   */\n  findApproxTForArcLength(arcLength: number, normalizedLength?: number): number {\n    const t = arcLength / (normalizedLength || this.length);\n    return t;\n  }\n\n  /**\n   * Function which finds t value for arc length using lookup table\n   * @param {Number} arcLength Target arclength\n   */\n  findTQuickForArcLength(arcLength: number): number {\n    if (this.arcLengthLookup.length === 0) {\n      this.generateArcLengthLookup();\n    }\n    const index = BinarySearch.search(this.arcLengthLookup, arcLength);\n    const v1 = this.arcLengthLookup[index];\n    const v2 = this.arcLengthLookup[index + 1];\n    const t = (index + (arcLength - v1) / (v2 - v1)) / this.arcLengthLookup.length;\n    return t;\n  }\n\n  generateArcLengthLookup(segments: number = 1000): void {\n    let lastPos = this.getPointAt(0);\n    let length = 0;\n    for (let i = 0; i < segments; i++) {\n      const pos = this.getPointAt(i / (segments - 1));\n      const delta = Vector2.distance(lastPos as number[], pos as number[]);\n      length += delta;\n      this.arcLengthLookup.push(length);\n      lastPos = pos;\n    }\n  }\n\n  /**\n   * Function calculating length along curve using interpolator.\n   * @param {Number} from t at start (default = 0)\n   * @param {Number} to t at end (default = 1)\n   */\n  getArcLength(from = 0, to = 1): number {\n    if (from === 0 && to === 1) {\n      return this.length;\n    }\n    const tolerance = 0.002;\n    return ArcLength.bisect((t: number) => this.getPointAt(t), from, to, tolerance);\n  }\n\n  /**\n   * Function calculating length along curve using interpolator.\n   * @param {Number} from t at start (default = 0)\n   * @param {Number} to t at end (default = 1)\n   */\n  getQuickArcLength(from = 0, to = 1): number {\n    let fromLength = 0;\n    let toLength = this.length;\n    if (this.arcLengthLookup.length === 0) {\n      this.generateArcLengthLookup();\n    }\n\n    if (from !== 0) {\n      const fromIndex = Math.floor(from * this.arcLengthLookup.length);\n      const fromLl = this.arcLengthLookup[fromIndex];\n      const fromLh = this.arcLengthLookup[fromIndex + 1];\n      fromLength = fromLl + ((from * this.arcLengthLookup.length) % this.arcLengthLookup.length) * (fromLh - fromLl);\n    }\n\n    if (to !== 1) {\n      const toIndex = Math.floor(to * this.arcLengthLookup.length);\n      const toLl = this.arcLengthLookup[toIndex];\n      const toLh = this.arcLengthLookup[toIndex + 1];\n      toLength = toLl + ((from * this.arcLengthLookup.length) % this.arcLengthLookup.length) * (toLh - toLl);\n    }\n\n    const totalLength = toLength - fromLength;\n    return totalLength;\n  }\n\n  /**\n   * Function getting a point at curve length.\n   * @param {Number} arcLength\n   */\n  getPointAtArcLength(arcLength: number, options?: { approxT?: boolean; quickT?: boolean; normalizedLength?: number }): Vector {\n    const t = this.findTForArcLength(arcLength, options);\n    return this.getPointAt(t);\n  }\n\n  getPointAt(t: number): Vector {\n    const tl = clamp(t, 0, 1);\n    return super.getPointAt(tl);\n  }\n}\n","import Vector2 from '@equinor/videx-vector2';\nimport { clamp, radians } from '@equinor/videx-math';\nimport { CurveInterpolator, normalize } from 'curve-interpolator';\n\nimport { Interpolators, Trajectory, MDPoint } from '../interfaces';\nimport { ExtendedCurveInterpolator } from './ExtendedCurveInterpolator';\n\n// determines how curvy the curve is\nconst TENSION = 0.75;\n// determines how many segments to split the curve into\nconst ARC_DIVISIONS = 5000;\n// specifies amount of steps (in the range [0,1]) to work back from the end of the curve\nconst THRESHOLD_DIRECTION_DISTANCE = 0.001;\n\nconst DEFAULT_START_EXTEND_LENGTH = 1000.0;\nconst DEFAULT_END_EXTEND_LENGTH = 1000.0;\n\nconst CURTAIN_SAMPLING_ANGLE_THRESHOLD = 0.0005;\nconst CURTAIN_SAMPLING_INTERVAL = 0.1;\n\nconst defaultOptions = {\n  approxT: true,\n};\n\nexport interface ReferenceSystemOptions {\n  normalizedLength?: number;\n  arcDivisions?: number;\n  tension?: number;\n  trajectoryAngle?: number;\n  calculateDisplacementFromBottom?: boolean;\n  curveInterpolator?: ExtendedCurveInterpolator;\n  trajectoryInterpolator?: ExtendedCurveInterpolator;\n  curtainInterpolator?: ExtendedCurveInterpolator;\n  approxT?: boolean;\n  quickT?: boolean;\n}\n\nexport class IntersectionReferenceSystem {\n  options: ReferenceSystemOptions;\n\n  path: number[][] = [];\n\n  projectedPath: number[][] = [];\n\n  projectedTrajectory: number[][];\n\n  private _offset: number = 0;\n\n  displacement: number;\n\n  depthReference: number;\n\n  wellboreId: number;\n\n  trajectoryOffset: number;\n\n  interpolators: Interpolators;\n\n  startVector: number[];\n\n  endVector: number[];\n\n  _curtainPathCache: MDPoint[];\n\n  /**\n   * Creates a common reference system that layers and other components can use\n   * @param path (required) array of 3d coordinates: [x, y, z]\n   * @param options (optional)\n   * @param options.trajectoryAngle (optional) - trajectory angle in degrees, overrides the calculated value\n   * @param options.calculateDisplacementFromBottom - (optional) specify if the path is passed from bottom up\n   */\n  constructor(path: number[][], options?: ReferenceSystemOptions) {\n    if (path.length < 1) {\n      throw new Error('Missing coordinates');\n    }\n    if (path[0] && path[0].length !== 3) {\n      throw new Error('Coordinates should be in 3d');\n    }\n    this.setPath(path, options);\n\n    this.project = this.project.bind(this);\n    this.unproject = this.unproject.bind(this);\n    this.getPosition = this.getPosition.bind(this);\n    this.getProjectedLength = this.getProjectedLength.bind(this);\n    this.getTrajectory = this.getTrajectory.bind(this);\n  }\n\n  private setPath(path: number[][], options: ReferenceSystemOptions = {}): void {\n    this.options = { ...defaultOptions, ...options };\n    const { arcDivisions, tension, calculateDisplacementFromBottom } = this.options;\n\n    this.path = path;\n\n    this.projectedPath = IntersectionReferenceSystem.toDisplacement(path);\n\n    const [displacement] = this.projectedPath[this.projectedPath.length - 1];\n    this.displacement = displacement;\n\n    this.interpolators = {\n      curve: options.curveInterpolator || new ExtendedCurveInterpolator(path),\n      trajectory:\n        options.trajectoryInterpolator ||\n        new ExtendedCurveInterpolator(\n          path.map((d: number[]) => [d[0], d[1]]),\n          { tension: tension || TENSION, arcDivisions: arcDivisions || ARC_DIVISIONS },\n        ),\n      curtain:\n        options.curtainInterpolator ||\n        new ExtendedCurveInterpolator(this.projectedPath, { tension: tension || TENSION, arcDivisions: arcDivisions || ARC_DIVISIONS }),\n    };\n\n    const trajVector = this.getTrajectoryVector();\n    const negativeTrajVector = trajVector.map((d: number) => d * -1);\n\n    if (calculateDisplacementFromBottom) {\n      this.endVector = negativeTrajVector;\n      this.startVector = trajVector;\n    } else {\n      this.endVector = trajVector;\n      this.startVector = negativeTrajVector;\n    }\n\n    this._curtainPathCache = undefined;\n  }\n\n  /**\n   * Map a length along the curve to intersection coordinates\n   * @param length length along the curve\n   */\n  project(length: number): number[] {\n    const { curtain } = this.interpolators;\n    const { calculateDisplacementFromBottom } = this.options;\n    const cl = clamp(calculateDisplacementFromBottom ? this.length - (length - this._offset) : length - this._offset, 0, this.length);\n    const p = curtain.getPointAtArcLength(cl, this.options);\n    return p as number[];\n  }\n\n  curtainTangent(length: number): number[] {\n    const { curtain } = this.interpolators;\n    const l = length - this._offset;\n    const t = curtain.findTForArcLength(l, this.options);\n    const tangent = t && curtain.getTangentAt(t);\n    return tangent as number[];\n  }\n\n  /**\n   * Returns as resampled version of the projected path between start and end\n   * Samples are picked from the beginning of the path at every CURTAIN_SAMPLING_INTERVAL meters\n   * If the angle between two consecutive segments is close to 180 degrees depending on CURTAIN_SAMPLING_ANGLE_THRESHOLD,\n   * a sample in between is discarded.\n   *\n   * The start and the end are not guaranteed to be part of the returned set of points\n   * @param startMd in MD\n   * @param endMd in MD\n   * @param includeStartEnd guarantee to include the starting and end points\n   */\n  getCurtainPath(startMd: number, endMd: number, includeStartEnd = false): MDPoint[] {\n    if (!this._curtainPathCache) {\n      const points: MDPoint[] = [];\n      let prevAngle = Math.PI * 2; // Always add first point\n      for (let i = this._offset; i <= this.length + this._offset; i += CURTAIN_SAMPLING_INTERVAL) {\n        const point = this.project(i);\n        const angle = Math.atan2(point[1], point[0]);\n\n        // Reduce number of points on a straight line by angle since last point\n        if (Math.abs(angle - prevAngle) > CURTAIN_SAMPLING_ANGLE_THRESHOLD) {\n          points.push({ point, md: i });\n          prevAngle = angle;\n        }\n      }\n      this._curtainPathCache = points;\n    }\n\n    if (includeStartEnd) {\n      const startPoint = { point: this.project(startMd), md: startMd };\n      const pointsBetween = this._curtainPathCache.filter((p) => p.md > startMd && p.md < endMd);\n      const endPoint = { point: this.project(endMd), md: endMd };\n      return [startPoint, ...pointsBetween, endPoint];\n    }\n    return this._curtainPathCache.filter((p) => p.md >= startMd && p.md <= endMd);\n  }\n\n  /**\n   * Map a displacement back to length along the curve\n   */\n  unproject(displacement: number): number {\n    const { normalizedLength, calculateDisplacementFromBottom } = this.options;\n    const displacementFromStart = calculateDisplacementFromBottom ? this.displacement - displacement : displacement;\n    const length = normalizedLength || this.length;\n\n    if (displacementFromStart < 0) {\n      return displacementFromStart;\n    }\n    if (displacementFromStart > this.displacement) {\n      return length + (displacementFromStart - this.displacement);\n    }\n\n    const ls = this.interpolators.curtain.lookupPositions(displacementFromStart, 0, 1);\n    if (ls && ls.length) {\n      return ls[0] * length + this._offset;\n    }\n    return null;\n  }\n\n  /**\n   * Get the normalized displacement [0 - 1] of a specific length along the curve\n   */\n  getProjectedLength(length: number): number {\n    const { curtain } = this.interpolators;\n    const pl = this.project(length);\n    const l = pl[0] / curtain.maxX;\n    return Number.isFinite(l) ? clamp(l, 0, 1) : 0;\n  }\n\n  /**\n   * Get the trajectory position at a length along the curve\n   */\n  getPosition(length: number): number[] {\n    const { trajectory } = this.interpolators;\n    const t = this.getProjectedLength(length);\n    const p = trajectory.getPointAt(t) as number[];\n    return p;\n  }\n\n  /**\n   * Generate a set of coordinates along the trajectory of the curve\n   */\n  getTrajectory(steps: number, from = 0, to = 1): Trajectory {\n    const extensionStart = from < 0 ? -from : 0;\n    const extensionEnd = to > 1 ? to - 1 : 0;\n\n    const refStart = this.interpolators.trajectory.getPointAt(0) as number[];\n    const refEnd = this.interpolators.trajectory.getPointAt(1) as number[];\n\n    let p0;\n    let p3;\n    let offset = 0;\n    const t0 = Math.max(0, from);\n    const t1 = Math.min(1, to);\n    const p1 = this.interpolators.trajectory.getPointAt(t0) as number[];\n    const p2 = this.interpolators.trajectory.getPointAt(t1) as number[];\n\n    if (extensionStart) {\n      p0 = [\n        refStart[0] + this.startVector[0] * extensionStart * this.displacement,\n        refStart[1] + this.startVector[1] * extensionStart * this.displacement,\n      ];\n      offset = -Vector2.distance(p0, refStart);\n    } else if (from > 0) {\n      offset = Vector2.distance(p1, refStart);\n    }\n\n    if (extensionEnd) {\n      p3 = [refEnd[0] + this.endVector[0] * extensionEnd * this.displacement, refEnd[1] + this.endVector[1] * extensionEnd * this.displacement];\n    }\n    const points = [];\n    const tl = to - from;\n    const preSteps = Math.floor((extensionStart / tl) * steps);\n    const curveSteps = Math.ceil(((t1 - t0) / tl) * steps);\n    const postSteps = steps - curveSteps - preSteps;\n\n    if (p0) {\n      points.push(p0);\n      for (let i = 1; i < preSteps; i++) {\n        const f = (i / preSteps) * extensionStart * this.displacement;\n        points.push([p0[0] - this.startVector[0] * f, p0[1] - this.startVector[1] * f]);\n      }\n    }\n    const curvePoints = this.interpolators.trajectory.getPoints(curveSteps - 1, null, t0, t1) as number[][]; // returns steps + 1 points\n    points.push(...curvePoints);\n    if (p3) {\n      for (let i = 1; i < postSteps - 1; i++) {\n        const f = (i / postSteps) * extensionEnd * this.displacement;\n        points.push([p2[0] + this.endVector[0] * f, p2[1] + this.endVector[1] * f]);\n      }\n      points.push(p3);\n    }\n    return { points, offset };\n  }\n\n  /**\n   * Generate a set of coordinates along the trajectory of the curve\n   */\n  getExtendedTrajectory(\n    numPoints: number,\n    startExtensionLength = DEFAULT_START_EXTEND_LENGTH,\n    endExtensionLength = DEFAULT_END_EXTEND_LENGTH,\n  ): Trajectory {\n    if (!isFinite(startExtensionLength) || startExtensionLength < 0.0) {\n      throw new Error('Invalid parameter, getExtendedTrajectory() must be called with a valid and positive startExtensionLength parameter');\n    }\n    if (!isFinite(endExtensionLength) || endExtensionLength < 0.0) {\n      throw new Error('Invalid parameter, getExtendedTrajectory() must be called with a valid and positive endExtensionLength parameter');\n    }\n\n    const totalLength = this.displacement + startExtensionLength + endExtensionLength;\n    const startExtensionNumPoints = Math.floor((startExtensionLength / totalLength) * numPoints);\n    const curveSteps = Math.max(Math.ceil((this.displacement / totalLength) * numPoints), 1);\n    const endExtensionNumPoints = numPoints - curveSteps - startExtensionNumPoints;\n\n    const points = [];\n\n    const refStart = new Vector2(this.interpolators.trajectory.getPointAt(0.0) as number[]);\n    const startVec = new Vector2(this.startVector);\n    const startExtensionStepLength = startExtensionLength / startExtensionNumPoints;\n    for (let i = startExtensionNumPoints; i > 0; i--) {\n      const f = i * startExtensionStepLength;\n      const point = refStart.add(startVec.scale(f));\n      points.push(point.toArray());\n    }\n\n    const curveStepPoints = this.interpolators.trajectory.getPoints(curveSteps, null, 0.0, 1.0) as number[][];\n    points.push(...curveStepPoints);\n\n    const refEnd = new Vector2(this.interpolators.trajectory.getPointAt(1.0) as number[]);\n    const endVec = new Vector2(this.endVector);\n    const endExtensionStepLength = endExtensionLength / (endExtensionNumPoints - 1); // -1 so last point is at end of extension\n    for (let i = 1; i < endExtensionNumPoints; i++) {\n      const f = i * endExtensionStepLength;\n      const point = refEnd.add(endVec.scale(f));\n      points.push(point.toArray());\n    }\n\n    const offset = -startExtensionLength;\n\n    const trajectory = { points, offset };\n    return trajectory;\n  }\n\n  getTrajectoryVector(): number[] {\n    const { trajectoryAngle, calculateDisplacementFromBottom } = this.options;\n\n    if (isFinite(trajectoryAngle)) {\n      const angleInRad = radians(trajectoryAngle);\n      return new Vector2(Math.cos(angleInRad), Math.sin(angleInRad)).toArray();\n    }\n\n    const trajectoryVec = IntersectionReferenceSystem.getDirectionVector(\n      this.interpolators.trajectory,\n      calculateDisplacementFromBottom ? THRESHOLD_DIRECTION_DISTANCE : 1 - THRESHOLD_DIRECTION_DISTANCE,\n      calculateDisplacementFromBottom ? 0 : 1,\n    );\n    return trajectoryVec;\n  }\n\n  /**\n   * Perform a curtain projection on a set of points in 3D\n   * @param points\n   * @param origin\n   * @param offset\n   * @returns {array}\n   */\n  static toDisplacement(points: number[][], offset = 0): number[][] {\n    let p0: number[] = points[0];\n    let l = 0;\n    const projected = points.map((p1: number[]) => {\n      const dx = p1[0] - p0[0];\n      const dy = p1[1] - p0[1];\n      l += Math.sqrt(dx ** 2 + dy ** 2);\n      p0 = p1;\n      return [offset > 0 ? offset - l : l, p1[2] || 0];\n    });\n    return projected;\n  }\n\n  /**\n   * returns a normalized vector\n   * @param interpolator interpolated curve\n   * @param from number between 0 and 1\n   * @param to number between 0 and 1\n   */\n  static getDirectionVector(interpolator: CurveInterpolator, from: number, to: number): number[] {\n    const p1 = interpolator.getPointAt(to);\n    const p2 = interpolator.getPointAt(from);\n\n    return normalize([p1[0] - p2[0], p1[1] - p2[1]]) as number[];\n  }\n\n  get length(): number {\n    return this.interpolators.curve.length;\n  }\n\n  get offset(): number {\n    return this._offset;\n  }\n\n  set offset(offset: number) {\n    this._curtainPathCache = undefined;\n    this._offset = offset;\n  }\n}\n","import { select, Selection } from 'd3-selection';\nimport { ZoomPanHandler } from './ZoomPanHandler';\nimport { Layer, GridLayer, LayerOptions } from '../layers';\nimport { ScaleOptions, OnMountEvent, OnRescaleEvent } from '../interfaces';\nimport { Axis } from '../components';\nimport { IntersectionReferenceSystem } from './IntersectionReferenceSystem';\nimport { HORIZONTAL_AXIS_MARGIN, VERTICAL_AXIS_MARGIN } from '../constants';\nimport { AxisOptions } from './interfaces';\n\nexport class LayerManager {\n  private container: HTMLElement;\n\n  private layerContainer: HTMLElement;\n\n  private _zoomPanHandler: ZoomPanHandler;\n\n  private layers: Layer<unknown>[] = [];\n\n  private _axis: Axis;\n  private _svgContainer: Selection<HTMLElement, unknown, null, undefined>;\n\n  /**\n   * Handles layers and axis also holds a zoom and pan handler object\n   * @param container root container\n   * @param scaleOptions\n   * @param axisOptions\n   */\n  constructor(container: HTMLElement, scaleOptions?: ScaleOptions, axisOptions?: AxisOptions) {\n    this.container = container;\n    this.layerContainer = document.createElement('div');\n    this.layerContainer.className = 'layer-container';\n    this.container.appendChild(this.layerContainer);\n    this.adjustToSize(+this.container.getAttribute('width'), +this.container.getAttribute('height'));\n    this._zoomPanHandler = new ZoomPanHandler(container, (event) => this.rescale(event));\n    if (scaleOptions) {\n      const { xMin, xMax, yMin, yMax, xBounds, yBounds } = scaleOptions;\n      if (xMin !== undefined && xMax !== undefined && yMin !== undefined && yMax !== undefined) {\n        this._zoomPanHandler.setBounds([xMin, xMax], [yMin, yMax]);\n      }\n      if (xBounds && yBounds) {\n        this._zoomPanHandler.setBounds(xBounds, yBounds);\n      }\n    } else {\n      this._zoomPanHandler.setBounds([0, 1], [0, 1]);\n    }\n\n    if (axisOptions) {\n      this._axis = this.createAxis(axisOptions);\n    }\n\n    this.rescale = this.rescale.bind(this);\n  }\n\n  /**\n   * Adds and mounts an array of layers\n   * @param layers array of layers\n   */\n  addLayers(layers: Layer<unknown>[]): LayerManager {\n    layers.forEach((layer) => this.addLayer(layer));\n    return this;\n  }\n\n  /**\n   * Gets all layers currently mounted\n   */\n  getLayers(): Layer<unknown>[] {\n    return this.layers;\n  }\n\n  /**\n   * Clears data from all mounted layers\n   * @param includeReferenceSystem - (optional) if true also removes reference system, default is true\n   */\n  clearAllData(includeReferenceSystem: boolean = true): LayerManager {\n    this.layers.forEach((l) => l.clearData(includeReferenceSystem));\n    return this;\n  }\n\n  /**\n   * Adds the layer to the manager, and mounts it\n   * @param layer Layer\n   * @param params extra params to pass to the onUpdate method\n   */\n  addLayer(layer: Layer<unknown>, params?: LayerOptions<unknown>): LayerManager {\n    this.layers.push(layer);\n    this.initLayer(layer, params);\n\n    return this;\n  }\n\n  /**\n   * Remove and unmount layer from manager\n   * @param layerId name of layer\n   */\n  removeLayer(layerId: string): LayerManager {\n    const layer = this.layers.find((l) => l.id === layerId);\n    if (layer) {\n      layer.onUnmount();\n      this.layers = this.layers.filter((l) => l.id !== layerId);\n    }\n\n    return this;\n  }\n\n  /**\n   * Remove and unmount all layers from manager\n   */\n  removeAllLayers(): LayerManager {\n    const { layers } = this;\n    layers.forEach((layer) => {\n      this.removeLayer(layer.id);\n    });\n    return this;\n  }\n\n  getLayer(layerId: string): Layer<unknown> {\n    return this.layers.find((l) => l.id === layerId || l.getInternalLayerIds().includes(layerId));\n  }\n\n  initLayer(layer: Layer<unknown>, params?: LayerOptions<unknown>): LayerManager {\n    const event: OnMountEvent = {\n      elm: this.layerContainer,\n    };\n    layer.onMount(event);\n    const rescaleEvent = this.zoomPanHandler.currentStateAsEvent();\n    layer.onUpdate({ ...rescaleEvent, ...params });\n    layer.onRescale(rescaleEvent);\n\n    if (this._svgContainer) {\n      const highestZIndex = this.layers.length > 0 ? this.layers.reduce((max, layers) => (max.order > layers.order ? max : layers)).order : 1;\n      this._svgContainer.style('z-index', `${highestZIndex + 1}`);\n    }\n\n    return this;\n  }\n\n  showLayer(layerId: string): LayerManager {\n    const layer = this.getLayer(layerId);\n    if (!layer) {\n      return this;\n    }\n    layer.setVisibility(true, layerId);\n    layer.onRescale(this.zoomPanHandler.currentStateAsEvent());\n    return this;\n  }\n\n  hideLayer(layerId: string): LayerManager {\n    const layer = this.getLayer(layerId);\n    if (!layer) {\n      return this;\n    }\n    layer.setVisibility(false, layerId);\n    layer.onRescale(this.zoomPanHandler.currentStateAsEvent());\n    return this;\n  }\n\n  /**\n   * Adjust layers, axis, and zoom according to inputted dimensions\n   * @param width (required)\n   * @param height (required)\n   */\n  adjustToSize(width: number, height: number): void {\n    const layersWidth = Math.max(this._axis ? width - HORIZONTAL_AXIS_MARGIN : width, 0);\n    const layersHeight = Math.max(this._axis ? height - VERTICAL_AXIS_MARGIN : height, 0);\n\n    if (this._axis) {\n      const resizeEvent = { width, height };\n      this._axis.onResize(resizeEvent);\n    }\n    if (this.layers) {\n      const resizeEvent = { width: layersWidth, height: layersHeight };\n      this.layers.forEach((layer) => layer.onResize(resizeEvent));\n    }\n    if (this._zoomPanHandler) {\n      this._zoomPanHandler.adjustToSize(layersWidth, layersHeight, true);\n    }\n  }\n\n  setReferenceSystem(irs: IntersectionReferenceSystem): void {\n    this.layers.forEach((layer) => (layer.referenceSystem = irs));\n  }\n\n  showAxis(): LayerManager {\n    this._axis.show();\n    return this;\n  }\n\n  hideAxis(): LayerManager {\n    this._axis.hide();\n    return this;\n  }\n\n  showAxisLabels(): LayerManager {\n    this._axis.showLabels();\n    return this;\n  }\n\n  hideAxisLabels(): LayerManager {\n    this._axis.hideLabels();\n    return this;\n  }\n\n  setAxisOffset(x: number, y: number): LayerManager {\n    this._axis.offsetX = x;\n    this._axis.offsetY = y;\n    const gridLayers = this.layers.filter((l: Layer<unknown>) => l instanceof GridLayer<unknown>);\n    gridLayers.forEach((l: GridLayer<unknown>) => {\n      l.offsetX = x;\n      l.offsetY = y;\n    });\n    return this;\n  }\n\n  setXAxisOffset(x: number): LayerManager {\n    this._axis.offsetX = x;\n    const gridLayers = this.layers.filter((l: Layer<unknown>) => l instanceof GridLayer<unknown>);\n    gridLayers.forEach((l: GridLayer<unknown>) => {\n      l.offsetX = x;\n    });\n    return this;\n  }\n\n  setYAxisOffset(y: number): LayerManager {\n    this._axis.offsetY = y;\n    const gridLayers = this.layers.filter((l: Layer<unknown>) => l instanceof GridLayer<unknown>);\n    gridLayers.forEach((l: GridLayer<unknown>) => {\n      l.offsetY = y;\n    });\n    return this;\n  }\n\n  setZoomLevelBoundary(zoomlevels: [number, number]): LayerManager {\n    this._zoomPanHandler.setZoomLevelBoundary(zoomlevels);\n    return this;\n  }\n\n  setMaxZoomLevel(zoomlevel: number): LayerManager {\n    this._zoomPanHandler.setMaxZoomLevel(zoomlevel);\n    return this;\n  }\n\n  setMinZoomLevel(zoomlevel: number): LayerManager {\n    this._zoomPanHandler.setMinZoomLevel(zoomlevel);\n    return this;\n  }\n\n  destroy(): LayerManager {\n    this.removeAllLayers();\n    this.layerContainer.remove();\n    this.layerContainer = undefined;\n    this.container = undefined;\n    this.layers = undefined;\n    this._zoomPanHandler = undefined;\n    this._axis = undefined;\n    this._svgContainer = undefined;\n\n    return this;\n  }\n\n  get zoomPanHandler(): ZoomPanHandler {\n    return this._zoomPanHandler;\n  }\n\n  get axis(): Axis {\n    return this._axis;\n  }\n\n  private rescale(event: OnRescaleEvent): void {\n    if (this._axis) {\n      this._axis.onRescale(event);\n    }\n    if (this.layers) {\n      this.layers.forEach((layer) => (layer.isVisible === true ? layer.onRescale(event) : {}));\n    }\n  }\n\n  private createAxis = (options: AxisOptions): Axis => {\n    const { container } = this;\n    this._svgContainer = select(container)\n      .append('div')\n      .attr('class', 'axis')\n      .style('position', 'absolute')\n      .style('z-index', '10')\n      .style('pointer-events', 'none');\n\n    const svg = this._svgContainer.append('svg').attr('height', `${container.offsetHeight}px`).attr('width', `${container.offsetWidth}px`);\n\n    const showLabels = true;\n\n    const axis = new Axis(svg, showLabels, options.xLabel, options.yLabel, options.unitOfMeasure);\n\n    return axis;\n  };\n}\n","import { select, Selection, pointer, ContainerElement } from 'd3-selection';\nimport { OverlayCallbacks } from './interfaces';\n\nexport class Overlay<T> {\n  elm: Selection<Element, unknown, null, undefined>;\n  source: Element;\n  elements: { [propName: string]: Element } = {};\n  listeners: { [propName: string]: OverlayCallbacks<T> } = {};\n  enabled = true;\n\n  constructor(caller: T, container: HTMLElement) {\n    const con = select(container);\n    this.elm = con.append('div').attr('id', 'overlay').style('z-index', '11').style('position', 'absolute');\n\n    this.source = this.elm.node();\n\n    const { elm } = this;\n    elm.on('resize', (event) => {\n      const { width, height } = event.detail;\n      elm.style('width', `${width}px`).style('height', `${height}px`);\n\n      if (!this.enabled) {\n        return;\n      }\n\n      Object.keys(this.listeners).forEach((key: string) => {\n        const target = this.elements[key] || null;\n        const ops = this.listeners[key];\n        if (ops && ops.onResize) {\n          requestAnimationFrame(() =>\n            ops.onResize({\n              target,\n              source: this.source,\n              caller,\n              width,\n              height,\n            }),\n          );\n        }\n      });\n    });\n\n    elm.on('mousemove', (event) => {\n      if (!this.enabled) {\n        return;\n      }\n\n      const [mx, my] = pointer(event, this.elm.node() as ContainerElement);\n      Object.keys(this.listeners).forEach((key: string) => {\n        const target = this.elements[key] || null;\n        const ops = this.listeners[key];\n\n        if (ops && ops.onMouseMove) {\n          requestAnimationFrame(() =>\n            ops.onMouseMove({\n              x: mx,\n              y: my,\n              target,\n              source: this.source,\n              caller,\n            }),\n          );\n        }\n      });\n    });\n\n    elm.on('mouseout', () => {\n      if (!this.enabled) {\n        return;\n      }\n      Object.keys(this.listeners).forEach((key: string) => {\n        const target = this.elements[key] || null;\n        const ops = this.listeners[key];\n        if (ops && ops.onMouseExit) {\n          requestAnimationFrame(() =>\n            ops.onMouseExit({\n              target,\n              source: this.source,\n              caller,\n            }),\n          );\n        }\n      });\n    });\n  }\n\n  create(key: string, callbacks?: OverlayCallbacks<T>): HTMLElement {\n    const newElm = this.elm.append('div').style('position', 'relative').style('pointer-events', 'none').node();\n    this.elements[key] = newElm;\n    if (callbacks) {\n      this.listeners[key] = callbacks;\n    }\n    return newElm;\n  }\n\n  register(key: string, callbacks: OverlayCallbacks<T>): void {\n    this.listeners[key] = callbacks;\n  }\n\n  remove(key: string): void {\n    const el = this.elements[key];\n    if (el) {\n      select(el).remove();\n      delete this.elements[key];\n    }\n    delete this.listeners[key];\n  }\n\n  setZIndex(zIndex: number): void {\n    this.elm.style('z-index', zIndex);\n  }\n\n  destroy(): void {\n    this.source.remove();\n  }\n}\n\nexport const overlay = <T>(caller: T, container: HTMLElement): Overlay<T> => new Overlay<T>(caller, container);\n","import { IntersectionReferenceSystem } from './IntersectionReferenceSystem';\nimport { LayerManager } from './LayerManager';\nimport { Layer } from '../layers';\nimport { ControllerOptions } from './interfaces';\nimport { ZoomPanHandler } from './ZoomPanHandler';\nimport { LayerOptions, OnRescaleEvent, ReferenceSystemOptions } from '..';\nimport { Axis } from '../components';\nimport { overlay, Overlay } from './overlay';\nimport { HORIZONTAL_AXIS_MARGIN, VERTICAL_AXIS_MARGIN } from '../constants';\n\n/**\n * API for controlling data and layers\n */\nexport class Controller {\n  private _referenceSystem: IntersectionReferenceSystem;\n\n  private layerManager: LayerManager;\n  private _overlay: Overlay<Controller>;\n\n  /**\n   * Interface to control layers, reference system, axis and overlay. overlay is created on instantiation, does not currently support opt-out.\n   * @param options\n   * @param options.container (required) Currently only supports HTMLElement\n   * @param options.scaleOptions (optional) currently supports formats listed in examples below\n   * @example scaleOptions = { xMin: 0, xMax: 100, yMin: 0, yMax: 100 }\n   * @example scaleOptions = { xBounds: [0 , 100], yBounds: [0, 100] }\n   * @param options.axisOptions (optional) creates axis with supplied labels, currently only supports creating axis on instantiation\n   * @param options.layers (optional) list of layers\n   * @param options.path (optional) creates a reference system based on an array of 3d coordinates\n   * @param options.referenceSystem (optional) sets reference system, takes priority over path if both are supplied\n   */\n  constructor(options: ControllerOptions) {\n    const { container, axisOptions, scaleOptions, referenceSystem, layers, path } = options;\n\n    this._referenceSystem = referenceSystem || (path && new IntersectionReferenceSystem(path));\n\n    this._overlay = overlay(this, container);\n\n    this.layerManager = new LayerManager(this._overlay.elm.node() as HTMLElement, scaleOptions, axisOptions);\n    if (layers) {\n      this.layerManager.addLayers(layers);\n      this.setOverlayZIndex(layers);\n    }\n  }\n\n  /**\n   * Sets reference system, overrides any existing reference systems in place\n   * @param referenceSystem IntersectionReferenceSystem\n   */\n  setReferenceSystem(referenceSystem: IntersectionReferenceSystem): Controller {\n    this._referenceSystem = referenceSystem;\n    this.layerManager.setReferenceSystem(referenceSystem);\n    return this;\n  }\n\n  /**\n   * Creates new reference system based on path, overrides any existing reference systems in place\n   * @param path array of coords\n   * @param options optional\n   * @param options.trajectoryAngle (optional) angle in degrees\n   */\n  updatePath(path: number[][], options?: ReferenceSystemOptions): Controller {\n    this.setReferenceSystem(new IntersectionReferenceSystem(path, options));\n\n    return this;\n  }\n\n  /**\n   * Clears data from all mounted layers\n   * @param includeReferenceSystem - (optional) if true also removes reference system, default is true\n   */\n  clearAllData(includeReferenceSystem: boolean = true): Controller {\n    this.layerManager.clearAllData(includeReferenceSystem);\n    return this;\n  }\n\n  /**\n   * Adds layer to list, and initializes it\n   * @param layer layer object\n   * @param params (optional) adds additional parameters to the onUpdateEvent\n   */\n  addLayer(layer: Layer<unknown>, params?: LayerOptions<unknown>): Controller {\n    this.layerManager.addLayer(layer, params);\n    this.setOverlayZIndex(this.layerManager.getLayers());\n    return this;\n  }\n\n  /**\n   * Remove and unmount layer from list\n   * @param layerId string id\n   */\n  removeLayer(layerId: string): Controller {\n    this.layerManager.removeLayer(layerId);\n    return this;\n  }\n\n  /**\n   * Remove and unmount all layers from list\n   */\n  removeAllLayers(): Controller {\n    this.layerManager.removeAllLayers();\n    return this;\n  }\n\n  /**\n   * Find first layer with given id, returns undefined if none are found\n   * @param layerId string id\n   */\n  getLayer(layerId: string): Layer<unknown> {\n    return this.layerManager.getLayer(layerId);\n  }\n\n  /**\n   * Sets visibility to true and rescales the layer\n   * @param layerId string id\n   */\n  showLayer(layerId: string): Controller {\n    this.layerManager.showLayer(layerId);\n    return this;\n  }\n\n  /**\n   * Sets visibility to false\n   * @param layerId string id\n   */\n  hideLayer(layerId: string): Controller {\n    this.layerManager.hideLayer(layerId);\n    return this;\n  }\n\n  /**\n   * Adjust layers, axis, overlay, and zoom according to inputted dimensions\n   * @param width (required)\n   * @param height (required)\n   */\n  adjustToSize(width: number, height: number): Controller {\n    this.layerManager.adjustToSize(width, height);\n\n    const dimensions = { width: Math.max(width - HORIZONTAL_AXIS_MARGIN, 0), height: Math.max(height - VERTICAL_AXIS_MARGIN, 0) };\n    this.overlay.elm.dispatch('resize', { detail: dimensions, bubbles: true, cancelable: true });\n\n    return this;\n  }\n\n  /**\n   * Set new viewport\n   * @param  cx - center X pos\n   * @param  cy - center Y pos\n   * @param  displ - displacement\n   * @param  duration - duration of transition\n   */\n  setViewport(cx?: number, cy?: number, displacement?: number, duration?: number): Controller {\n    this.zoomPanHandler.setViewport(cx, cy, displacement, duration);\n    return this;\n  }\n\n  /**\n   * Sets bounds for zoom and pan handler\n   * @param xBounds - domain in x-direction\n   * @param yBounds - domain in y-direction\n   */\n  setBounds(xBounds: [number, number], yBounds: [number, number]): Controller {\n    this.zoomPanHandler.setBounds(xBounds, yBounds);\n    return this;\n  }\n\n  /**\n   * Display both axes\n   */\n  showAxis(): Controller {\n    this.layerManager.showAxis();\n    return this;\n  }\n\n  /**\n   * Hide both axes\n   */\n  hideAxis(): Controller {\n    this.layerManager.hideAxis();\n    return this;\n  }\n\n  /**\n   * Shows labels in x and y\n   */\n  showAxisLabels(): Controller {\n    this.layerManager.showAxisLabels();\n    return this;\n  }\n\n  /**\n   * Hide labels in x and y\n   */\n  hideAxisLabels(): Controller {\n    this.layerManager.hideAxisLabels();\n    return this;\n  }\n\n  /**\n   * Sets domain offset, offset is subtracted from domain\n   * @param x\n   * @param y\n   */\n  setAxisOffset(x: number, y: number): Controller {\n    this.layerManager.setAxisOffset(x, y);\n    return this;\n  }\n\n  /**\n   * Sets domain offset in x-direction, offset is subtracted from domain\n   * @param x\n   */\n  setXAxisOffset(x: number): Controller {\n    this.layerManager.setXAxisOffset(x);\n    return this;\n  }\n\n  /**\n   * Sets domain offset in y-direction, offset is subtracted from domain\n   * @param y\n   */\n  setYAxisOffset(y: number): Controller {\n    this.layerManager.setYAxisOffset(y);\n    return this;\n  }\n\n  /**\n   * Defines min and max of how much one can zoom\n   * @param zoomlevels\n   */\n  setZoomLevelBoundary(zoomlevels: [number, number]): Controller {\n    this.zoomPanHandler.setZoomLevelBoundary(zoomlevels);\n    return this;\n  }\n\n  /**\n   * Defines how far in one can zoom\n   * @param zoomlevel\n   */\n  setMaxZoomLevel(zoomlevel: number): Controller {\n    this.zoomPanHandler.setMaxZoomLevel(zoomlevel);\n    return this;\n  }\n\n  /**\n   * Defines how far out one can zoom\n   * @param zoomlevel\n   */\n  setMinZoomLevel(zoomlevel: number): Controller {\n    this.zoomPanHandler.setMinZoomLevel(zoomlevel);\n    return this;\n  }\n\n  /**\n   * Destroy Controller\n   * Convenience method for removing from DOM and clearing references\n   */\n  destroy(): Controller {\n    this.layerManager.destroy();\n    this._overlay.destroy();\n    this._referenceSystem = undefined;\n    this.layerManager = undefined;\n    this._overlay = undefined;\n    return this;\n  }\n\n  private getHighestZIndex(layers: Layer<unknown>[]): number {\n    const highestZIndex = layers.length > 0 ? layers.reduce((max, layers) => (max.order > layers.order ? max : layers)).order : 1;\n    return highestZIndex;\n  }\n\n  private setOverlayZIndex(layers: Layer<unknown>[]): void {\n    const highestZIndex = this.getHighestZIndex(layers);\n    this.overlay.setZIndex(highestZIndex + 2);\n  }\n\n  get overlay(): Overlay<Controller> {\n    return this._overlay;\n  }\n\n  get referenceSystem(): IntersectionReferenceSystem {\n    return this._referenceSystem;\n  }\n\n  get zoomPanHandler(): ZoomPanHandler {\n    return this.layerManager.zoomPanHandler;\n  }\n\n  get axis(): Axis {\n    return this.layerManager.axis;\n  }\n\n  get currentStateAsEvent(): OnRescaleEvent {\n    return this.zoomPanHandler.currentStateAsEvent();\n  }\n}\n"],"names":["RootFinder","func","precision","maxIterations","start","minLimit","maxLimit","t","i","v","clamp","tl","th","ArcLength","tolerance","minDepth","maxDepth","calcRec","a","b","aVal","bVal","span","depth","mid","midVal","spanA","Vector2","spanB","length","tol","d","segments","lastPos","step","pos","delta","BinarySearch","values","searchValue","il","ih","v1","ExtendedCurveInterpolator","CurveInterpolator","points","options","arcLength","iterations","x","normalizedLength","index","v2","from","to","fromLength","toLength","fromIndex","fromLl","fromLh","toIndex","toLl","toLh","TENSION","ARC_DIVISIONS","THRESHOLD_DIRECTION_DISTANCE","DEFAULT_START_EXTEND_LENGTH","DEFAULT_END_EXTEND_LENGTH","CURTAIN_SAMPLING_ANGLE_THRESHOLD","CURTAIN_SAMPLING_INTERVAL","defaultOptions","IntersectionReferenceSystem","path","arcDivisions","tension","calculateDisplacementFromBottom","displacement","trajVector","negativeTrajVector","curtain","cl","l","startMd","endMd","includeStartEnd","prevAngle","point","angle","startPoint","pointsBetween","p","endPoint","displacementFromStart","ls","trajectory","steps","extensionStart","extensionEnd","refStart","refEnd","p0","p3","offset","t0","t1","p1","p2","preSteps","curveSteps","postSteps","f","curvePoints","numPoints","startExtensionLength","endExtensionLength","totalLength","startExtensionNumPoints","endExtensionNumPoints","startVec","startExtensionStepLength","curveStepPoints","endVec","endExtensionStepLength","trajectoryAngle","angleInRad","radians","dx","dy","interpolator","normalize","LayerManager","container","scaleOptions","axisOptions","select","svg","showLabels","Axis","ZoomPanHandler","event","xMin","xMax","yMin","yMax","xBounds","yBounds","layers","layer","includeReferenceSystem","params","layerId","rescaleEvent","highestZIndex","max","width","height","layersWidth","HORIZONTAL_AXIS_MARGIN","layersHeight","VERTICAL_AXIS_MARGIN","resizeEvent","irs","y","GridLayer","zoomlevels","zoomlevel","Overlay","caller","con","elm","key","target","ops","mx","my","pointer","callbacks","newElm","el","zIndex","overlay","Controller","referenceSystem","dimensions","cx","cy","duration"],"mappings":"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"}