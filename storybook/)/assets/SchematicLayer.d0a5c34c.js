var Pe=Object.defineProperty;var Se=(n,r,e)=>r in n?Pe(n,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[r]=e;var C=(n,r,e)=>(Se(n,typeof r!="symbol"?r+"":r,e),e);import{q as we,t as Te,V as me,P as fe,T,u as L,W as _,v as B,w as Q,M as ee,x as te,y as ne,o as ke,G as W,z as de,A,B as be,E as Fe,m as G,F as ve,I as Ae}from"./elements.87f68392.js";import{a as Le}from"./PixiLayer.a52855e3.js";function Y(n,r){let e;if(r===void 0)for(const t of n)t!=null&&(e<t||e===void 0&&t>=t)&&(e=t);else{let t=-1;for(let s of n)(s=r(s,++t,n))!=null&&(e<s||e===void 0&&s>=s)&&(e=s)}return e}function $(n,r){let e=0;if(r===void 0)for(let t of n)(t=+t)&&(e+=t);else{let t=-1;for(let s of n)(s=+r(s,++t,n))&&(e+=s)}return e}function re(n){throw new Error(`Unexpected object: ${JSON.stringify(n)}`)}const Re=n=>n.kind==="pAndASymbol",De=n=>n.kind==="cementSqueeze",He=n=>n.kind==="cementPlug",Ie=(n,r,e)=>t=>{switch(t.kind){case"screen":return n(t);case"tubing":return r(t);case"completionSymbol":return e(t);default:return re(t)}},H=(n,r)=>{switch(r){case"Perforation":return n.Perforation(r);case"Open hole gravel pack":return n.OpenHoleGravelPack(r);case"Open hole frac pack":return n.OpenHoleFracPack(r);case"Cased hole fracturation":return n.CasedHoleFracturation(r);case"Cased hole frac pack":return n.CasedHoleFracPack(r);case"Cased hole gravel pack":return n.CasedHoleGravelPack(r);default:return re(r)}},Oe=n=>H({Perforation:()=>!1,OpenHoleGravelPack:()=>!0,OpenHoleFracPack:()=>!0,CasedHoleFracturation:()=>!1,CasedHoleGravelPack:()=>!0,CasedHoleFracPack:()=>!0},n.subKind);function Ee(n){return H({Perforation:()=>!1,OpenHoleGravelPack:()=>!1,OpenHoleFracPack:()=>!0,CasedHoleFracturation:()=>!0,CasedHoleGravelPack:()=>!1,CasedHoleFracPack:()=>!0},n.subKind)}function ze(n){return H({Perforation:()=>!0,OpenHoleGravelPack:()=>!1,OpenHoleFracPack:()=>!1,CasedHoleFracturation:()=>!1,CasedHoleGravelPack:()=>!1,CasedHoleFracPack:()=>!1},n.subKind)}function Be(n){return H({Perforation:()=>!1,OpenHoleGravelPack:()=>!1,OpenHoleFracPack:()=>!1,CasedHoleFracturation:()=>!1,CasedHoleGravelPack:()=>!0,CasedHoleFracPack:()=>!1},n.subKind)}function We(n){return H({Perforation:()=>!1,OpenHoleGravelPack:()=>!1,OpenHoleFracPack:()=>!1,CasedHoleFracturation:()=>!1,CasedHoleGravelPack:()=>!1,CasedHoleFracPack:()=>!0},n.subKind)}const ue=(n,r)=>n.start<r.end&&n.end>r.start,Ge=n=>({holeLayerId:`${n}-hole`,casingLayerId:`${n}-casing`,completionLayerId:`${n}-completion`,cementLayerId:`${n}-cement`,pAndALayerId:`${n}-pAndA`,perforationLayerId:`${n}-perforation`}),Me={firstColor:"#8c541d",secondColor:"#eee3d8",lineColor:"#8b4513"},qe={solidColor:"#dcdcdc",lineColor:"#575757",shoeSize:{width:we,length:Te},windowOptions:{dashColor:"#dc0000",dashLength:5,spaceLength:3}},_e={stroke:"rgba(0, 0, 0, 0.25)",yellow:"#FFFC00",grey:"gray",red:"#FF5050",outline:"black",transparent:"rgba(255, 255, 255, 0)",spikeWidth:50,spikeLength:50,packingOpacity:.5,fracLineCurve:10,fracLineLength:25,scalingFactor:25},Ve={firstColor:"#c7b9ab",secondColor:"#5b5b5b",scalingFactor:4},Ue={firstColor:"#8b6713",secondColor:"#000000",scalingFactor:4},Ne={scalingFactor:4,lineColor:"#63666a"},Ze={scalingFactor:1,innerColor:"#eeeeff",outerColor:"#777788"},$e={firstColor:"#c7b9ab",secondColor:"#000000",scalingFactor:4},K=n=>new me(n.x,n.y),je=n=>new fe(n[0],n[1]),pe=n=>{if(n.length<2)return[new me(0)];let r;return n.map((e,t,s)=>{if(t<s.length-1){const o=K(s[t]);return r=K(s[t+1]).sub(o).rotate90().normalized(),r}return r})},ye=(n,r,e)=>{const t=K(n);return je(t.add(r.scale(e)))},J=(n,r,e)=>{if(n.length!==r.length)throw new Error("Number of vectors does not match number of points");return n.map((t,s)=>{const o=r[s];return ye(t,o,e)})},M=(n,r)=>[...r,...n.map(e=>e.clone()).reverse()],ge=(n,r,e,t)=>n<=t&&e<=r,Xe=(n,r,e,t)=>n<t&&e<r,Ye=n=>Array.from(new Set(n)),V=(n,r,e,t)=>{const s=t.filter(a=>ge(n,r,a.start,a.end)),o=e.filter(a=>ge(n,r,a.start,a.end));return{overlappingHoles:s,overlappingOuterStrings:o}},U=([n,r],e)=>{const o=e.flatMap(c=>[c.start-1e-4,c.start,c.end,c.end+1e-4]).filter(c=>c>=n&&c<=r);return o.push(n),o.push(r),Ye(o).sort((c,l)=>c-l)},b=n=>n.kind==="casing"?n.innerDiameter:n.diameter,Ce=(n,r,e,t)=>{const o=n.find(i=>i.start<=t&&i.end>=t),a=o?o.diameter:0,c=r.filter(i=>b(i)>a).sort((i,h)=>b(i)-b(h)).find(i=>i.start<=t&&i.end>=t),l=e.find(i=>i.start<=t&&i.end>=t&&i.diameter>a);return c?b(c):l?l.diameter:100},Ke=(n,r,e,t)=>{const o=n.sort((c,l)=>l.diameter-c.diameter).find(c=>c.start<=e&&c.end>=e),a=r.find(c=>c.start<=e&&c.end>=e);return o&&t!=="Open hole frac pack"&&t!=="Open hole gravel pack"?b(o):a?a.diameter:100},Je=(n,r,e,t)=>{const o=n.sort((i,h)=>b(i)-b(h)).find(i=>i.start<=t&&i.end>=t);if(o)return b(o);const a=n.length?Math.min(...n.map(i=>b(i))):0,c=r.sort((i,h)=>b(i)-b(h)).find(i=>i.start<=t&&i.end>=t&&a<=b(i));if(c)return b(c);const l=e.find(i=>i.start<=t&&i.end>=t&&i.diameter);return l?l.diameter:100},Qe=(n,r,e,t,s,o)=>{const{attachedStrings:a,nonAttachedStrings:c}=se(n.referenceIds,r,e);if(a.length===0)throw new Error(`Invalid cement data, can't find referenced casing/completion string for cement with id '${n.id}'`);a.sort((u,g)=>u.end-g.end);const l=a[a.length-1].end,{overlappingOuterStrings:i,overlappingHoles:h}=V(n.toc,l,c,t),d=[...i,...h].map(u=>({start:u.start,end:u.end}));return U([n.toc,l],d).flatMap((u,g,y)=>{if(g===y.length-1)return[];const P=y[g+1],F=Ce(a,i,h,u);return[{top:u,bottom:P,diameter:F*s}]}).map(u=>({diameter:u.diameter,points:o(u.top,u.bottom)}))},se=(n,r,e)=>[...r,...e].reduce((t,s)=>n.includes(s.id)?{...t,attachedStrings:[...t.attachedStrings,s]}:{...t,nonAttachedStrings:[...t.nonAttachedStrings,s]},{attachedStrings:[],nonAttachedStrings:[]}),et=(n,r,e,t,s,o)=>{const{attachedStrings:a,nonAttachedStrings:c}=se(n.referenceIds,r,e);if(a.length===0)throw new Error(`Invalid cement squeeze data, can't find referenced casing/completion for squeeze with id '${n.id}'`);const{overlappingOuterStrings:l,overlappingHoles:i}=V(n.start,n.end,c,t),h=[...l,...i].map(f=>({start:f.start,end:f.end}));return U([n.start,n.end],h).flatMap((f,u,g)=>{if(u===g.length-1)return[];const y=g[u+1],P=Ce(a,l,i,f);return[{top:f,bottom:y,diameter:P*s}]}).map(f=>({diameter:f.diameter,points:o(f.top,f.bottom)}))},tt=(n,r,e,t,s,o)=>{const{attachedStrings:a,nonAttachedStrings:c}=se(n.referenceIds,r,e),{overlappingHoles:l,overlappingOuterStrings:i}=V(n.start,n.end,c,t),h=[...a,...l,...i].map(f=>({start:f.start,end:f.end}));return U([n.start,n.end],h).flatMap((f,u,g)=>{if(u===g.length-1)return[];const y=g[u+1],P=Je(a,i,l,f);return[{top:f,bottom:y,diameter:P*s}]}).map(f=>({diameter:f.diameter,points:o(f.top,f.bottom)}))},nt=(n,r,e,t,s)=>{const a=r.createLinearGradient(0,0,0,n.height);return a.addColorStop(0,e),a.addColorStop(.5-s,t),a.addColorStop(.5+s,t),a.addColorStop(1,e),a},rt=({firstColor:n,secondColor:r},e,t)=>{const s=document.createElement("canvas");s.width=e,s.height=t;const o=s.getContext("2d");return o.fillStyle=nt(s,o,n,r,0),o.fillRect(0,0,s.width,s.height),T.from(s)},st=({scalingFactor:n})=>{const r=document.createElement("canvas"),e=L*n;r.width=e,r.height=e;const t=r.getContext("2d");t.fillStyle="white",t.fillRect(0,0,r.width,r.height);const s=e/10;t.strokeStyle="#AAAAAA",t.lineWidth=s,t.beginPath();const o=e/3;for(let a=-r.width;a<r.width;a++)t.moveTo(-r.width+o*a,-r.height),t.lineTo(r.width+o*a,r.height*2);return t.stroke(),T.from(r)},ot=({innerColor:n,outerColor:r,scalingFactor:e})=>{const t=L*e,s=document.createElement("canvas");s.width=t,s.height=t;const o=s.getContext("2d"),a=o.createLinearGradient(0,0,0,t),c=.3,l=.7;return a.addColorStop(0,r),a.addColorStop(c,n),a.addColorStop(l,n),a.addColorStop(1,r),o.fillStyle=a,o.fillRect(0,0,s.width,s.height),T.from(s)},at=({firstColor:n,secondColor:r,scalingFactor:e})=>{const t=document.createElement("canvas"),s=L*e,o=e;t.width=s,t.height=s;const a=t.getContext("2d");a.fillStyle=n,a.fillRect(0,0,t.width,t.height),a.lineWidth=o,a.fillStyle=r,a.beginPath();const c=s/12;for(let l=-t.width;l<t.width;l++)a.moveTo(-t.width+c*l,-t.height),a.lineTo(t.width+c*l,t.height);return a.stroke(),T.from(t)},it=({firstColor:n,secondColor:r,scalingFactor:e})=>{const t=document.createElement("canvas"),s=L*e;t.width=s,t.height=s;const o=t.getContext("2d");o.fillStyle=n,o.fillRect(0,0,t.width,t.height),o.lineWidth=e,o.strokeStyle=r,o.beginPath(),o.setLineDash([20,10]);const a=s/12;for(let c=-t.width;c<t.width;c++)o.moveTo(-t.width+a*c,-t.height),o.lineTo(t.width+a*c,t.height*2);return o.stroke(),T.from(t)},ct=({firstColor:n,secondColor:r,scalingFactor:e})=>{const t=document.createElement("canvas"),s=L*e,o=e;t.width=s,t.height=s;const a=t.getContext("2d");a.lineWidth=o,a.fillStyle=n,a.strokeStyle=r,a.fillRect(0,0,t.width,t.height),a.beginPath(),a.setLineDash([20,10]);const c=s/12;for(let l=-t.width;l<t.width;l++)a.moveTo(-t.width+c*l,-t.height),a.lineTo(t.width+c*l,t.height*2);return a.stroke(),T.from(t)},z=(n,r)=>{const e=pe(r),t=J(r,e,n);return{leftPath:J(r,e,-n),rightPath:t}},j=(n,r)=>({kind:"casing",start:n,end:r}),lt=(n,r)=>({kind:"casing-window",start:n,end:r}),ht=n=>{const r=(n.windows||[]).filter(e=>Xe(n.start,n.end,e.start,e.end)).reduce(({intervals:e,lastBottom:t},s,o,a)=>{const c=t<s.start?j(t,s.start):null,l=c?c.end:t,i=Math.max(l,s.start),h=Math.min(n.end,s.end),d=lt(i,h),m=h,f=o===a.length-1&&m<n.end?j(m,n.end):null,u=[c,d,f].filter(g=>g);return{intervals:[...e,...u],lastBottom:m}},{intervals:[],lastBottom:n.start});return r.intervals.length?r.intervals:[j(n.start,n.end)]},dt=(n,r,e)=>{const t=r.diameter*n,s=t/2,a=r.innerDiameter*n/2,c=s-a,l=ht(r).map(i=>{const h=e(i.start,i.end),{leftPath:d,rightPath:m}=z(s,h);return{kind:i.kind,leftPath:d,rightPath:m,pathPoints:h,polygon:M(d,m)}});return{kind:"casing",id:r.id,referenceDiameter:t,referenceRadius:s,sections:l,casingWallWidth:c,hasShoe:r.hasShoe,bottom:r.end}},ut=(n,r,e,t,s)=>{const{overlappingOuterStrings:o,overlappingHoles:a}=V(n.start,n.end,r,e),c=[...o,...a].map(d=>({start:d.start,end:d.end}));return U([n.start,n.end],c).flatMap((d,m,p)=>{if(m===p.length-1)return[];const f=p[m+1],u=Ke(o,a,d,n.subKind);return[{top:d,bottom:f,diameter:u*t}]}).map(d=>{const m=s(d.top,d.bottom);return{diameter:d.diameter,points:m}})},N=(n,r,e)=>{const{packingOpacity:t,yellow:s}=e;r.fillStyle=s,r.strokeStyle=s;const o=[0,0],a=[n.width,n.height];r.save(),r.globalAlpha=t,r.fillRect(...o,...a),r.restore()},oe=(n,r,e,t,s)=>{const{fracLineCurve:o}=t,a=10,c=n.width/a,l=e/3*t.scalingFactor,i=l/4,h=l/2,d=0,m=s==="diameter"?0:h,p=()=>{for(let f=-1;f<a;f++){const u=[f*c+d+c/2,n.height/2-i-m-i];r.beginPath();const g=[...u],y=[u[0]-o*2,u[1]-i/4],P=[u[0],u[1]-i/2],F=[u[0]+o*2,u[1]-i/2-i/4],S=[u[0],u[1]-i];r.bezierCurveTo(...g,...y,...P),r.bezierCurveTo(...P,...F,...S),r.stroke()}for(let f=-1;f<a;f++){const u=[f*c+c+d+c/2,n.height/2+l/2+m];r.beginPath();const g=[...u],y=[u[0]-o*2,u[1]+i/4],P=[u[0],u[1]+i/2],F=[u[0]+o*2,u[1]+i/2+i/4],S=[u[0],u[1]+i];r.bezierCurveTo(...g,...y,...P),r.bezierCurveTo(...P,...F,...S),r.stroke()}};r.strokeStyle=t.yellow,r.lineWidth=6,r.save(),r.globalAlpha=t.packingOpacity,p(),r.restore(),r.lineWidth=1,r.strokeStyle=t.outline,p(),r.closePath()},gt=(n,r,e,t)=>{const o=n.width/10;r.strokeStyle=t.outline;const a=e/3*t.scalingFactor;r.lineWidth=1;const c=a/2,l=0;for(let i=0;i<=10;i++){const h=[i*o+l,n.height/2-a/2],d=[h[0]-o/2,h[1]-c],m=[h[0]-o,h[1]];r.beginPath(),r.moveTo(...h),r.lineTo(...d),r.lineTo(...m),r.fill(),r.lineWidth=1,r.stroke()}for(let i=0;i<=10;i++){const h=[i*o+l,n.height/2+a/2],d=[h[0]-o/2,h[1]+c],m=[h[0]-o,h[1]];r.beginPath(),r.moveTo(...h),r.lineTo(...d),r.lineTo(...m),r.fill(),r.lineWidth=1,r.stroke()}r.closePath()},v=(n="Error!",r)=>{console.error(`${n}`);const e=(r==null?void 0:r.canvas)||document.createElement("canvas"),t=L;e.width=t/2,e.height=t;const s=(r==null?void 0:r.canvasCtx)||e.getContext("2d"),o=[0,0],a=[e.width,e.height];return s.fillStyle="#ff00ff",s.fillRect(...o,...a),new T(T.from(e,{wrapMode:_.CLAMP}).baseTexture,null,new B(0,0,e.width,e.height),null,Q.MIRROR_HORIZONTAL)},R=(n,r)=>{const e=document.createElement("canvas"),s=n.diameter*r.scalingFactor;e.width=s/2,e.height=s;const o=e.getContext("2d");return{canvas:e,ctx:o}},D=n=>new T(T.from(n,{wrapMode:_.CLAMP}).baseTexture,null,new B(0,0,n.width,n.height),null,Q.MIRROR_HORIZONTAL),ae={packing:()=>v(),fracLines:()=>v(),spikes:(n,r,e,t)=>{const{canvas:s,ctx:o}=R(r,t),a=e.some(i=>Be(i)&&ue(n,i)),c=e.some(i=>We(i)&&ue(n,i));return a||c?n.isOpen?(o.fillStyle=t.yellow,o.strokeStyle=t.yellow):(o.fillStyle=t.grey,o.strokeStyle=t.grey):n.isOpen?(o.fillStyle=t.red,o.strokeStyle=t.red):(o.fillStyle=t.grey,o.strokeStyle=t.grey),gt(s,o,r.diameter,t),c&&oe(s,o,r.diameter,t,"spike"),D(s)}},xe={packing:()=>v(),fracLines:(n,r)=>{const{canvas:e,ctx:t}=R(n,r);return oe(e,t,n.diameter,r,"diameter"),D(e)},spikes:()=>v()},q={packing:(n,r)=>{const{canvas:e,ctx:t}=R(n,r);return N(e,t,r),D(e)},fracLines:(n,r)=>{const{canvas:e}=R(n,r);return D(e)},spikes:()=>v()},ie={packing:(n,r)=>{const{canvas:e,ctx:t}=R(n,r);return N(e,t,r),D(e)},fracLines:()=>v(),spikes:()=>v()},ce={packing:(n,r)=>{const{canvas:e,ctx:t}=R(n,r);return N(e,t,r),D(e)},fracLines:()=>v(),spikes:()=>v()},le={packing:(n,r,e)=>{const{canvas:t,ctx:s}=R(r,e);return N(t,s,e),D(t)},fracLines:(n,r)=>{const{canvas:e,ctx:t}=R(n,r);return oe(e,t,n.diameter,r,"diameter"),D(e)},spikes:()=>v()},mt=(n,r,e)=>H({Perforation:()=>ae.packing(),CasedHoleFracturation:()=>q.packing(r,e),CasedHoleFracPack:()=>q.packing(r,e),OpenHoleGravelPack:()=>ce.packing(r,e),OpenHoleFracPack:()=>le.packing(n,r,e),CasedHoleGravelPack:()=>ie.packing(r,e)},n.subKind),ft=(n,r,e)=>H({Perforation:()=>ae.fracLines(),OpenHoleGravelPack:()=>ce.fracLines(),OpenHoleFracPack:()=>le.fracLines(r,e),CasedHoleFracturation:()=>xe.fracLines(r,e),CasedHoleGravelPack:()=>ie.fracLines(),CasedHoleFracPack:()=>q.fracLines(r,e)},n.subKind),pt=(n,r,e,t)=>H({Perforation:()=>ae.spikes(n,e,r,t),OpenHoleGravelPack:()=>ce.spikes(),OpenHoleFracPack:()=>le.spikes(),CasedHoleFracturation:()=>xe.spikes(),CasedHoleGravelPack:()=>ie.spikes(),CasedHoleFracPack:()=>q.spikes()},n.subKind);class yt extends ee{constructor(e,t=0){const s=$(e,o=>o.points.length);super(new Float32Array(s*4),new Float32Array(s*4),new Uint16Array((s-1)*6));C(this,"segments");C(this,"textureScale");this.segments=e,this.textureScale=t,this.build()}get width(){return Y(this.segments,e=>e.diameter)}build(){const e=this.segments;if(!e)return;const t=this.getBuffer("aVertexPosition"),s=this.getBuffer("aTextureCoord"),o=this.getIndex(),a=$(e,u=>u.points.length);if(a<1)return;t.data.length/4!==a&&(t.data=new Float32Array(a*4),s.data=new Float32Array(a*4),o.data=new Uint16Array((a-1)*6));const c=s.data,l=o.data;c[0]=0,c[1]=0,c[2]=0,c[3]=1;const i=e.length,h=Y(e,u=>u.diameter);let d=0,m=0,p=0,f=0;for(let u=0;u<i;u++){let g=e[u].points[0];const y=h,P=e[u].diameter/h/2,F=e[u].points.length;for(let S=0;S<F;S++){const O=g.x-e[u].points[S].x,I=g.y-e[u].points[S].y,k=Math.sqrt(O*O+I*I);g=e[u].points[S],d+=k/y,c[m]=d,c[m+1]=.5-P,c[m+2]=d,c[m+3]=.5+P,m+=4}for(let S=0;S<F-1;S++)l[f++]=p,l[f++]=p+1,l[f++]=p+2,l[f++]=p+2,l[f++]=p+1,l[f++]=p+3,p+=2;p+=2}s.update(),o.update(),this.updateVertices()}updateVertices(){const e=this.segments;if($(e,a=>a.points.length)<1)return;const s=e.length;let o=0;for(let a=0;a<s;a++){let c=e[a].points[0],l,i=0,h=0;const d=this.buffers[0].data,m=e[a].points.length;let p=0;for(let f=0;f<m;f++){const u=e[a].points[f];p=o+f*4,f<e[a].points.length-1?l=e[a].points[f+1]:l=u,h=-(l.x-c.x),i=l.y-c.y;const g=Math.sqrt(i*i+h*h),y=e[a].diameter/2;i/=g,h/=g,i*=y,h*=y,d[p]=u.x+i,d[p+1]=u.y+h,d[p+2]=u.x-i,d[p+3]=u.y-h,c=u}o=p+4}this.buffers[0].update()}update(){this.build()}}class Ct extends te{constructor(e,t,s=0){const o=new yt(t,s),a=new ne(e);e.baseTexture.wrapMode=_.REPEAT;super(o,a);C(this,"autoUpdate");this.autoUpdate=!0}_render(e){const t=this.geometry;this.autoUpdate&&t.update(),super._render(e)}}class xt extends ee{constructor(e,t=200){super(new Float32Array(e.length*4),new Float32Array(e.length*4),new Uint16Array((e.length-1)*6));C(this,"points");C(this,"_width");this.points=e,this._width=t,this.build()}get width(){return this._width}build(){const e=this.points;if(!e)return;const t=this.getBuffer("aVertexPosition"),s=this.getBuffer("aTextureCoord"),o=this.getIndex();if(e.length<1)return;t.data.length/4!==e.length&&(t.data=new Float32Array(e.length*4),s.data=new Float32Array(e.length*4),o.data=new Uint16Array((e.length-1)*6));const a=s.data,c=o.data;a[0]=0,a[1]=0,a[2]=0,a[3]=1;let l=0,i=e[0];const h=e.length;for(let m=0;m<h;m++){const p=m*4,f=i.x-e[m].x,u=i.y-e[m].y,g=Math.sqrt(f*f+u*u);i=e[m],l+=g/this._width,a[p]=l,a[p+1]=0,a[p+2]=l,a[p+3]=1}let d=0;for(let m=0;m<h-1;m++){const p=m*2;c[d++]=p,c[d++]=p+1,c[d++]=p+2,c[d++]=p+2,c[d++]=p+1,c[d++]=p+3}s.update(),o.update(),this.updateVertices()}updateVertices(){const e=this.points;if(e.length<1)return;let t=e[0],s,o=0,a=0;const c=this.buffers[0].data,l=e.length;for(let i=0;i<l;i++){const h=e[i],d=i*4;i<e.length-1?s=e[i+1]:s=h,a=-(s.x-t.x),o=s.y-t.y;const m=Math.sqrt(o*o+a*a),p=this._width/2;o/=m,a/=m,o*=p,a*=p,c[d]=h.x+o,c[d+1]=h.y+a,c[d+2]=h.x-o,c[d+3]=h.y-a,t=h}this.buffers[0].update()}update(){this.build()}}class Pt extends te{constructor(e,t,s){const o=new xt(t,s),a=new ne(e);e.baseTexture.wrapMode=_.REPEAT;super(o,a);C(this,"autoUpdate");this.autoUpdate=!0}_render(e){const t=this.geometry;this.autoUpdate&&t.update(),super._render(e)}}class St extends ee{constructor(e,t=200){super(new Float32Array(e.length*4),new Float32Array(e.length*4),new Uint16Array((e.length-1)*6));C(this,"points");C(this,"_width");this.points=e,this._width=t,this.build()}build(){const e=this.points;if(!e)return;const t=this.getBuffer("aVertexPosition"),s=this.getBuffer("aTextureCoord"),o=this.getIndex();if(e.length<1)return;t.data.length/4!==e.length&&(t.data=new Float32Array(e.length*4),s.data=new Float32Array(e.length*4),o.data=new Uint16Array((e.length-1)*6));const a=e.length;let c=0,l=e[0];for(let f=0;f<a;f++){const u=l.x-e[f].x,g=l.y-e[f].y,y=Math.sqrt(u*u+g*g);l=e[f],c+=y}const i=s.data,h=o.data;i[0]=0,i[1]=0,i[2]=0,i[3]=1;let d=0,m=e[0];for(let f=0;f<a;f++){const u=f*4,g=m.x-e[f].x,y=m.y-e[f].y,P=Math.sqrt(g*g+y*y);m=e[f],d+=P/c,i[u]=d,i[u+1]=0,i[u+2]=d,i[u+3]=1}let p=0;for(let f=0;f<a-1;f++){const u=f*2;h[p++]=u,h[p++]=u+1,h[p++]=u+2,h[p++]=u+2,h[p++]=u+1,h[p++]=u+3}s.update(),o.update(),this.updateVertices()}updateVertices(){const e=this.points;if(e.length<1)return;let t=e[0],s,o=0,a=0;const c=this.buffers[0].data,l=e.length;for(let i=0;i<l;i++){const h=e[i],d=i*4;i<e.length-1?s=e[i+1]:s=h,a=-(s.x-t.x),o=s.y-t.y;const m=Math.sqrt(o*o+a*a),p=this._width/2;o/=m,a/=m,o*=p,a*=p,c[d]=h.x+o,c[d+1]=h.y+a,c[d+2]=h.x-o,c[d+3]=h.y-a,t=h}this.buffers[0].update()}update(){this.updateVertices()}}class wt extends te{constructor(e,t){const s=new St(t,e.height),o=new ne(e);super(s,o);C(this,"autoUpdate");this.autoUpdate=!0}_render(e){const t=this.geometry;(this.autoUpdate||t._width!==this.shader.texture.height)&&(t._width=this.shader.texture.height,t.update()),super._render(e)}}const Tt=(n,r,e)=>t=>{switch(t.kind){case"casing":return n(t);case"cement":return r(t);case"cementSqueeze":return e(t);default:return re(t)}},kt=n=>({exaggerationFactor:2,internalLayerOptions:Ge(n),holeOptions:Me,casingOptions:qe,cementOptions:Ve,cementSqueezeOptions:Ue,screenOptions:Ne,tubingOptions:Ze,cementPlugOptions:$e,perforationOptions:_e}),he=class extends Le{constructor(e,t,s){super(e,t,s);C(this,"internalLayerVisibility",{holeLayerId:!0,casingLayerId:!0,completionLayerId:!0,cementLayerId:!0,pAndALayerId:!0,perforationLayerId:!0});C(this,"cementTextureCache");C(this,"cementSqueezeTextureCache");C(this,"cementPlugTextureCache");C(this,"holeTextureCache");C(this,"screenTextureCache");C(this,"tubingTextureCache");C(this,"textureSymbolCacheArray");C(this,"scalingFactors",{height:600,zFactor:1,yScale:ke()});C(this,"getZFactorScaledPathForPoints",(e,t)=>{const s=a=>a*this.scalingFactors.zFactor;return this.referenceSystem.getCurtainPath(e,t,!0).map(a=>new fe(a.point[0],s(a.point[1])))});C(this,"drawBigPolygon",(e,t=0)=>{const s=new W;s.beginFill(t),s.drawPolygon(e),s.endFill(),this.addChild(s)});C(this,"drawBigTexturedPolygon",(e,t)=>{const s=new W().beginTextureFill({texture:t}).drawPolygon(e).endFill();return this.addChild(s),s});C(this,"perforationRopeAndTextureReferences",[]);C(this,"prepareSymbolRenderObject",e=>{const{exaggerationFactor:t}=this.options,s=e.diameter*t;return{pathPoints:this.getZFactorScaledPathForPoints(e.start,e.end),referenceDiameter:s,symbolKey:e.symbolKey}});C(this,"drawSymbolComponent",({pathPoints:e,referenceDiameter:t,symbolKey:s})=>{const o=this.getSymbolTexture(s,t);this.drawSVGRope(e,o)});C(this,"drawHoleSize",(e,t)=>{if(t==null)return;const s=this.getZFactorScaledPathForPoints(t.start,t.end);if(s.length===0)return;const{exaggerationFactor:o,holeOptions:a}=this.options,c=t.diameter*o,{rightPath:l,leftPath:i}=z(c/2,s);if(this.renderType()===G.CANVAS){const h=M(i,l);this.drawBigPolygon(h,A(a.firstColor))}else{const h=this.getHoleTexture(a,c,e);this.drawHoleRope(s,h,e)}this.drawOutline(i,l,A(a.lineColor),ve*o,"TopAndBottom",0)});C(this,"drawCasing",e=>{const{casingOptions:t}=this.options,s=A(t.solidColor),o=A(t.lineColor);e.sections.forEach((a,c,l)=>{const i=he.getOutlineClosureType(c,l.length-1);if(this.renderType()===G.CANVAS)this.drawBigPolygon(a.polygon,s);else{const h=this.createCasingTexture(e.referenceDiameter);this.drawRope(a.pathPoints,h,s)}a.kind==="casing-window"?this.drawCasingWindowOutline(a.leftPath,a.rightPath,t,e.casingWallWidth):this.drawOutline(a.leftPath,a.rightPath,o,e.casingWallWidth,i)})});C(this,"generateShoe",(e,t,s,o)=>{const a=e-s,c=e,l=this.getZFactorScaledPathForPoints(a,c),i=pe(l),h=J(l,i,t*(o<0?-1:1)),d=l[l.length-1],m=i[i.length-1],p=ye(d,m,o+t*(o<0?-1:1));return[...h,p]});C(this,"createCementSqueezeShape",(e,t,s,o)=>{const{exaggerationFactor:a}=this.options;return et(e,t,s,o,a,this.getZFactorScaledPathForPoints)});C(this,"createPerforationShape",(e,t,s)=>{const{exaggerationFactor:o}=this.options;return ut(e,t,s,o,this.getZFactorScaledPathForPoints)});this.options={...this.options,...kt(this.id),...s}}onUnmount(e){super.onUnmount(e),this.scalingFactors=null,this.cementTextureCache=null,this.cementSqueezeTextureCache=null,this.holeTextureCache=null,this.screenTextureCache=null,this.tubingTextureCache=null,this.textureSymbolCacheArray=null,this.internalLayerVisibility=null}onUpdate(e){super.onUpdate(e),this.clearLayer(),this.preRender(),this.render()}onRescale(e){const t=this.scalingFactors.zFactor!==e.zFactor;this.scalingFactors={height:e.height,zFactor:e.zFactor,yScale:e.yScale},super.optionsRescale(e);const s=this.yRatio(),o=e.xBounds[0]>e.xBounds[1],a=e.yBounds[0]>e.yBounds[1];this.setContainerPosition(e.xScale(0),e.yScale(0)),this.setContainerScale(e.xRatio*(o?-1:1),s*(a?-1:1)),t&&(this.clearLayer(),this.preRender()),this.render()}setVisibility(e,t){if(t===this.id){super.setVisibility(e,t);return}const{internalLayerOptions:s}=this.options,[o]=Object.entries(s).find(([a,c])=>c===t);o&&(this.internalLayerVisibility[o]=e,this.clearLayer(),this.preRender(),this.render())}getInternalLayerIds(){const{internalLayerOptions:e}=this.options;return Object.values(e)}yRatio(){const e=this.scalingFactors.yScale.domain(),s=(e[1]-e[0])*this.scalingFactors.zFactor,o=[e[0],e[0]+s];return Math.abs(this.scalingFactors.height/(o[1]-o[0]))}drawRope(e,t,s){if(e.length===0)return null;const o=new de(t,e,1);o.tint=s||o.tint,this.addChild(o)}drawOutline(e,t,s,o=1,a="None",c=1){const l=e.map(m=>m.clone()).reverse(),i=t[0],h=l[0],d=new W;d.lineStyle(o,s,void 0,c),d.moveTo(i.x,i.y),t.forEach(m=>d.lineTo(m.x,m.y)),(a==="None"||a==="Top")&&d.moveTo(h.x,h.y),l.forEach(m=>d.lineTo(m.x,m.y)),(a==="TopAndBottom"||a==="Top")&&d.lineTo(i.x,i.y),this.addChild(d)}drawCasingWindowOutline(e,t,{lineColor:s,windowOptions:o},a=1){var g,y;const c=!!((y=(g=this.referenceSystem)==null?void 0:g.options)!=null&&y.calculateDisplacementFromBottom),[l,i]=c?[e,t]:[t,e],[h,d]=c?[1,0]:[0,1],m=new W;m.lineStyle(a,A(s),void 0,d);const p=l[0];m.moveTo(p.x,p.y),l.forEach(P=>m.lineTo(P.x,P.y));const f=new be(m,{dash:[o.dashLength,o.spaceLength],color:A(o.dashColor),width:a,alignment:h}),u=i[0];f.moveTo(u.x,u.y),i.forEach(P=>{f.lineTo(P.x,P.y)}),this.addChild(m)}preRender(){if(!this.data||!this.referenceSystem)return;const{exaggerationFactor:e}=this.options,{holeSizes:t,casings:s,cements:o,completion:a,symbols:c,pAndA:l,perforations:i}=this.data;this.updateSymbolCache(c),t.sort((g,y)=>y.diameter-g.diameter);const h=t.length>0?Y(t,g=>g.diameter)*e:Fe*e;this.internalLayerVisibility.holeLayerId&&t.forEach(g=>this.drawHoleSize(h,g)),s.sort((g,y)=>y.diameter-g.diameter);const d=s.map(g=>this.createCasingRenderObject(g)),m=o.map(g=>({kind:"cement",segments:Qe(g,s,a,t,e,this.getZFactorScaledPathForPoints),casingIds:(g.referenceIds||[]).filter(y=>y)})),[p,f]=l.reduce(([g,y],P)=>De(P)?[[P,...g],y]:[g,[P,...y]],[[],[]]),u=p.map(g=>({kind:"cementSqueeze",segments:this.createCementSqueezeShape(g,s,a,t),casingIds:g.referenceIds}));if(this.sortCementAndCasingRenderObjects(d,m,u).forEach(Tt(g=>{this.internalLayerVisibility.casingLayerId&&(this.drawCasing(g),g.hasShoe&&this.drawShoe(g.bottom,g.referenceRadius))},g=>{this.internalLayerVisibility.cementLayerId&&this.drawComplexRope(g.segments,this.getCementTexture())},g=>{this.internalLayerVisibility.pAndALayerId&&this.drawComplexRope(g.segments,this.getCementSqueezeTexture())})),this.perforationRopeAndTextureReferences.forEach(({rope:g,texture:y})=>{g.destroy({children:!0,texture:!0,baseTexture:!0}),y.destroy(!0)}),this.perforationRopeAndTextureReferences=[],this.internalLayerVisibility.perforationLayerId){const{perforationOptions:g}=this.options,y=i.filter(Oe),P=i.filter(Ee),F=i.filter(ze);y.forEach(S=>{const I=this.createPerforationShape(S,s,t).reduce((k,x)=>(k[x.diameter]||(k[x.diameter]=[]),k[x.diameter]=[...k[x.diameter],x],k),{});Object.values(I).forEach(k=>{const x=mt(S,k[0],g),w=this.drawComplexRope(k,x);this.perforationRopeAndTextureReferences.push({rope:w,texture:x})})}),P.forEach(S=>{const k=this.createPerforationShape(S,s,t).map(x=>({...x,diameter:x.diameter*3})).reduce((x,w)=>(x[w.diameter]||(x[w.diameter]=[]),x[w.diameter]=[...x[w.diameter],w],x),{});Object.values(k).forEach(x=>{x.forEach(w=>{const E=ft(S,w,g),Z=this.drawComplexRope([w],E);this.perforationRopeAndTextureReferences.push({rope:Z,texture:E})})})}),F.forEach(S=>{const k=this.createPerforationShape(S,s,t).map(x=>({...x,diameter:x.diameter*3})).reduce((x,w)=>(x[w.diameter]||(x[w.diameter]=[]),x[w.diameter]=[...x[w.diameter],w],x),{});Object.values(k).forEach(x=>{x.forEach(w=>{const E=pt(S,i,w,g),Z=this.drawComplexRope([w],E);this.perforationRopeAndTextureReferences.push({rope:Z,texture:E})})})})}this.internalLayerVisibility.completionLayerId&&a.forEach(Ie(g=>this.drawScreen(g),g=>this.drawTubing(g),g=>{const y=this.prepareSymbolRenderObject(g);this.drawSymbolComponent(y)})),this.internalLayerVisibility.pAndALayerId&&f.forEach(g=>{if(Re(g)){const y=this.prepareSymbolRenderObject(g);this.drawSymbolComponent(y)}He(g)&&this.drawCementPlug(g,s,a,t)})}updateSymbolCache(e){if(this.textureSymbolCacheArray||(this.textureSymbolCacheArray={}),!e)return;const t=Object.keys(this.textureSymbolCacheArray);Object.entries(e).forEach(([s,o])=>{t.includes(s)||(this.textureSymbolCacheArray[s]=T.from(o))})}drawCementPlug(e,t,s,o){const{exaggerationFactor:a,cementPlugOptions:c}=this.options,l=tt(e,t,s,o,a,this.getZFactorScaledPathForPoints);this.drawComplexRope(l,this.getCementPlugTexture(c));const{rightPath:i,leftPath:h}=l.reduce((d,m)=>{const{leftPath:p,rightPath:f}=z(m.diameter/2,m.points);return{rightPath:[...d.rightPath,...f],leftPath:[...d.leftPath,...p]}},{rightPath:[],leftPath:[]});this.drawOutline(h,i,A("black"),.25,"TopAndBottom")}createCasingRenderObject(e){const{exaggerationFactor:t}=this.options;return dt(t,e,this.getZFactorScaledPathForPoints)}getCementPlugTexture(e){return this.cementPlugTextureCache||(this.cementPlugTextureCache=it(e)),this.cementPlugTextureCache}drawSVGRope(e,t){if(e.length===0)return null;const s=new wt(t,e);this.addChild(s)}getSymbolTexture(e,t){return new T(this.textureSymbolCacheArray[e].baseTexture,null,new B(0,0,0,t),null,Q.MAIN_DIAGONAL)}drawHoleRope(e,t,s){if(e.length===0)return null;const o=new de(t,e,s/L);this.addChild(o)}getHoleTexture(e,t,s){const o=L,a=o,c=o,l=t/s*o;this.holeTextureCache||(this.holeTextureCache=rt(e,c,a));const i=this.holeTextureCache.baseTexture,h=(a-l)/2,d=new B(0,h,c,l);return new T(i,d)}sortCementAndCasingRenderObjects(e,t,s){let o=0;const{result:a}=e.reduce((c,l)=>{const i=c.remainingCement.find(d=>d.casingIds.includes(l.id)),h=c.remainingCementSqueezes.filter(d=>d.casingIds.includes(l.id));return i&&(i.zIndex=o++),h.forEach(d=>d.zIndex=o++),l.zIndex=o++,{result:[...c.result,i,l,...h],remainingCement:c.remainingCement.filter(d=>d!==i),remainingCementSqueezes:c.remainingCementSqueezes.filter(d=>!h.includes(d))}},{result:[],remainingCement:t,remainingCementSqueezes:s});return a.filter(c=>c!==void 0).sort((c,l)=>c.zIndex-l.zIndex)}drawComplexRope(e,t){if(e.length===0)return null;const{exaggerationFactor:s}=this.options,o=new Ct(t,e,s);return this.addChild(o),o}createCasingTexture(e){return new T(T.WHITE.baseTexture,null,new B(0,0,16,e))}drawShoe(e,t){const{exaggerationFactor:s,casingOptions:o}=this.options,a=o.shoeSize.width*s,c=o.shoeSize.length*s,l=this.generateShoe(e,t,c,a),i=this.generateShoe(e,t,c,-a);this.drawBigPolygon(i),this.drawBigPolygon(l)}getCementTexture(){if(!this.cementTextureCache){const{cementOptions:e}=this.options;this.cementTextureCache=at(e)}return this.cementTextureCache}getCementSqueezeTexture(){if(!this.cementSqueezeTextureCache){const{cementSqueezeOptions:e}=this.options;this.cementSqueezeTextureCache=ct(e)}return this.cementSqueezeTextureCache}drawScreen({start:e,end:t,diameter:s}){const{exaggerationFactor:o,screenOptions:a}=this.options,c=o*s,l=this.getZFactorScaledPathForPoints(e,t),{leftPath:i,rightPath:h}=z(c/2,l),d=M(i,h),m=this.getScreenTexture();this.renderType()===G.CANVAS?this.drawBigTexturedPolygon(d,m):this.drawCompletionRope(l,m,c),this.drawOutline(i,h,A(a.lineColor),Ae*o,"TopAndBottom")}drawTubing({diameter:e,start:t,end:s}){const{exaggerationFactor:o,tubingOptions:a}=this.options,c=o*e,l=this.getZFactorScaledPathForPoints(t,s),{leftPath:i,rightPath:h}=z(c/2,l),d=M(i,h),m=this.getTubingTexture(a);this.renderType()===G.CANVAS?this.drawBigTexturedPolygon(d,m):this.drawCompletionRope(l,m,c)}getTubingTexture(e){return this.tubingTextureCache||(this.tubingTextureCache=ot(e)),this.tubingTextureCache}getScreenTexture(){if(!this.screenTextureCache){const{screenOptions:e}=this.options;this.screenTextureCache=st(e)}return this.screenTextureCache}drawCompletionRope(e,t,s){if(e.length===0)return;const o=new Pt(t,e,s);this.addChild(o)}};let X=he;C(X,"getOutlineClosureType",(e,t)=>e===0?e===t?"TopAndBottom":"Top":e===t?"Bottom":"None");export{X as S,re as a};
//# sourceMappingURL=SchematicLayer.d0a5c34c.js.map
